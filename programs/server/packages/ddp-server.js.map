{"version":3,"sources":["meteor://ðŸ’»app/packages/ddp-server/stream_server.js","meteor://ðŸ’»app/packages/ddp-server/livedata_server.js","meteor://ðŸ’»app/packages/ddp-server/writefence.js","meteor://ðŸ’»app/packages/ddp-server/crossbar.js","meteor://ðŸ’»app/packages/ddp-server/server_convenience.js","meteor://ðŸ’»app/packages/ddp-server/dummy_document_view.ts","meteor://ðŸ’»app/packages/ddp-server/session_collection_view.ts","meteor://ðŸ’»app/packages/ddp-server/session_document_view.ts"],"names":["websocketExtensions","once","extensions","websocketCompressionConfig","process","env","SERVER_WEBSOCKET_COMPRESSION","JSON","parse","push","Npm","require","configure","threshold","level","zlib","constants","Z_BEST_SPEED","memLevel","Z_MIN_MEMLEVEL","noContextTakeover","maxWindowBits","Z_MIN_WINDOWBITS","pathPrefix","__meteor_runtime_config__","ROOT_URL_PATH_PREFIX","StreamServer","self","registration_callbacks","open_sockets","prefix","RoutePolicy","declare","sockjs","serverOptions","log","heartbeat_delay","disconnect_delay","disable_cors","DISABLE_SOCKJS_CORS","jsessionid","USE_JSESSIONID","DISABLE_WEBSOCKETS","websocket","faye_server_options","server","createServer","WebApp","httpServer","removeListener","_timeoutAdjustmentRequestCallback","installHandlers","addListener","_redirectWebsocketEndpoint","on","socket","setWebsocketTimeout","timeout","protocol","_session","recv","connection","setTimeout","send","data","write","filter","value","TEST_METADATA","stringify","testMessageOnConnect","forEach","callback","Object","assign","prototype","register","all_sockets","values","event","oldHttpServerListeners","listeners","slice","removeAllListeners","newListener","request","args","arguments","url","parsedUrl","pathname","format","oldListener","apply","DDPServer","publicationStrategies","SERVER_MERGE","useDummyDocumentView","useCollectionView","doAccountingForCollection","NO_MERGE_NO_HISTORY","NO_MERGE","NO_MERGE_MULTI","_SessionDocumentView","SessionDocumentView","_getCurrentFence","currentInvocation","_CurrentWriteFence","get","DDP","_CurrentMethodInvocation","fence","undefined","_SessionCollectionView","SessionCollectionView","Session","version","options","id","Random","initialized","inQueue","Meteor","_DoubleEndedQueue","blocked","workerRunning","cachedUnblock","_namedSubs","Map","_universalSubs","userId","collectionViews","_isSending","_dontStartNewUniversalSubs","_pendingReady","_closeCallbacks","_socketUrl","_respondToPings","respondToPings","connectionHandle","close","onClose","fn","cb","bindEnvironment","defer","clientAddress","_clientAddress","httpHeaders","headers","msg","session","startUniversalSubs","heartbeatInterval","heartbeat","DDPCommon","Heartbeat","heartbeatTimeout","onTimeout","sendPing","start","Package","Facts","incrementServerFact","sendReady","subscriptionIds","subs","subscriptionId","_canSend","collectionName","getPublicationStrategy","sendAdded","fields","collection","sendChanged","isEmpty","sendRemoved","getSendCallbacks","added","bind","changed","removed","getCollectionView","ret","set","subscriptionHandle","view","delete","handlers","universal_publish_handlers","handler","_startSubscription","stop","_meteorSession","_deactivateAllSubscriptions","_removeSession","_printSentDDP","_debug","stringifyDDP","sendError","reason","offendingMessage","processMessage","msg_in","messageReceived","processNext","shift","runHandlers","unblock","setImmediate","onMessageHook","each","protocol_handlers","result","call","_isPromise","finally","sub","name","params","Array","publish_handlers","error","Error","has","DDPRateLimiter","rateLimiterInput","type","connectionId","_increment","rateLimitResult","_check","allowed","getErrorMessage","timeToReset","unsub","_stopSubscription","method","randomSeed","_WriteFence","onAllCommitted","retire","methods","method_handlers","arm","invocation","MethodInvocation","isSimulation","setUserId","_setUserId","promise","Promise","resolve","reject","withValue","maybeAuditArgumentChecks","finish","payload","then","exception","wrapInternalException","_eachSub","f","_diffCollectionViews","beforeCVs","DiffSequence","diffMaps","both","leftValue","rightValue","diff","rightOnly","documents","docView","getFields","leftOnly","doc","_deactivate","oldNamedSubs","all","map","newSub","_recreate","_runHandler","_noYieldsAllowed","subId","Subscription","unblockHander","subName","maybeSub","_name","_removeAllDocuments","response","httpForwardedCount","parseInt","remoteAddress","forwardedFor","isString","split","length","ip","trim","_handler","_subscriptionId","_params","_subscriptionHandle","_deactivated","_stopCallbacks","_documents","_ready","_idFilter","idStringify","MongoID","idParse","resultOrThenable","_CurrentPublicationInvocation","EJSON","clone","e","_isDeactivated","isThenable","_publishHandlerResult","res","isCursor","c","_publishCursor","ready","isArray","every","collectionNames","i","_getCollectionName","cur","_callStopCallbacks","callbacks","collectionDocs","strId","onStop","ids","Set","add","Server","defaultPublicationStrategy","onConnectionHook","Hook","debugPrintExceptions","_publicationStrategies","sessions","stream_server","raw_msg","_printReceivedDDP","parseDDP","err","_handleConnect","onConnection","setPublicationStrategy","strategy","includes","onMessage","support","SUPPORTED_DDP_VERSIONS","calculateVersion","publish","isObject","autopublish","is_auto","warned_about_autopublish","entries","key","isAsyncCall","_isCallAsyncMethodRunning","func","pop","callAsync","hasOwnProperty","_setCallAsyncMethodRunning","_CurrentCallAsyncInvocation","_set","hasCallAsyncParent","applyAsync","isFromCallAsync","catch","currentMethodInvocation","currentPublicationInvocation","makeRpcSeed","r","_urlForSession","sessionId","clientSupportedVersions","serverSupportedVersions","correctVersion","find","_calculateVersion","context","isClientSafe","originalMessage","message","details","_expectedByTest","stack","sanitizedError","description","Match","_failIfArgumentsAreNotAllChecked","beginWrite","retired","committed","fired","outstanding_writes","_maybeFire","armed","onBeforeFire","before_fire_callbacks","completion_callbacks","_armAndWait","resolver","returnValue","armAndWait","invokeCallback","beforeCallbacks","EnvironmentVariable","_Crossbar","nextId","listenersByCollection","listenersByCollectionCount","factPackage","factName","_collectionForMessage","listen","trigger","record","fire","notification","listenersForCollection","callbackIds","l","_matches","ObjectID","equals","keys","_InvalidationCrossbar","DDP_DEFAULT_CONNECTION_URL","refresh","DummyDocumentView","clearField","changeCollector","changeField","isAdd","existsIn","dataByKey","size","previous","diffDocument","nowDV","prevDV","diffObjects","prev","now","changedResult","precedenceList","sessionCallbacks","removedValue","precedence","splice","elt"],"mappings":"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","file":"/packages/ddp-server.js","sourcesContent":["import once from 'lodash.once';\nimport zlib from 'node:zlib';\n\n// By default, we use the permessage-deflate extension with default\n// configuration. If $SERVER_WEBSOCKET_COMPRESSION is set, then it must be valid\n// JSON. If it represents a falsey value, then we do not use permessage-deflate\n// at all; otherwise, the JSON value is used as an argument to deflate's\n// configure method; see\n// https://github.com/faye/permessage-deflate-node/blob/master/README.md\n//\n// (We do this in an _.once instead of at startup, because we don't want to\n// crash the tool during isopacket load if your JSON doesn't parse. This is only\n// a problem because the tool has to load the DDP server code just in order to\n// be a DDP client; see https://github.com/meteor/meteor/issues/3452 .)\nvar websocketExtensions = once(function () {\n  var extensions = [];\n\n  var websocketCompressionConfig = process.env.SERVER_WEBSOCKET_COMPRESSION ?\n    JSON.parse(process.env.SERVER_WEBSOCKET_COMPRESSION) : {};\n\n  if (websocketCompressionConfig) {\n    extensions.push(Npm.require('permessage-deflate2').configure({\n      threshold: 1024,\n      level: zlib.constants.Z_BEST_SPEED,\n      memLevel: zlib.constants.Z_MIN_MEMLEVEL,\n      noContextTakeover: true,\n      maxWindowBits: zlib.constants.Z_MIN_WINDOWBITS,\n      ...(websocketCompressionConfig || {})\n    }));\n  }\n\n  return extensions;\n});\n\nvar pathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX ||  \"\";\n\nStreamServer = function () {\n  var self = this;\n  self.registration_callbacks = [];\n  self.open_sockets = [];\n\n  // Because we are installing directly onto WebApp.httpServer instead of using\n  // WebApp.app, we have to process the path prefix ourselves.\n  self.prefix = pathPrefix + '/sockjs';\n  RoutePolicy.declare(self.prefix + '/', 'network');\n\n  // set up sockjs\n  var sockjs = Npm.require('sockjs');\n  var serverOptions = {\n    prefix: self.prefix,\n    log: function() {},\n    // this is the default, but we code it explicitly because we depend\n    // on it in stream_client:HEARTBEAT_TIMEOUT\n    heartbeat_delay: 45000,\n    // The default disconnect_delay is 5 seconds, but if the server ends up CPU\n    // bound for that much time, SockJS might not notice that the user has\n    // reconnected because the timer (of disconnect_delay ms) can fire before\n    // SockJS processes the new connection. Eventually we'll fix this by not\n    // combining CPU-heavy processing with SockJS termination (eg a proxy which\n    // converts to Unix sockets) but for now, raise the delay.\n    disconnect_delay: 60 * 1000,\n    // Allow disabling of CORS requests to address\n    // https://github.com/meteor/meteor/issues/8317.\n    disable_cors: !!process.env.DISABLE_SOCKJS_CORS,\n    // Set the USE_JSESSIONID environment variable to enable setting the\n    // JSESSIONID cookie. This is useful for setting up proxies with\n    // session affinity.\n    jsessionid: !!process.env.USE_JSESSIONID\n  };\n\n  // If you know your server environment (eg, proxies) will prevent websockets\n  // from ever working, set $DISABLE_WEBSOCKETS and SockJS clients (ie,\n  // browsers) will not waste time attempting to use them.\n  // (Your server will still have a /websocket endpoint.)\n  if (process.env.DISABLE_WEBSOCKETS) {\n    serverOptions.websocket = false;\n  } else {\n    serverOptions.faye_server_options = {\n      extensions: websocketExtensions()\n    };\n  }\n\n  self.server = sockjs.createServer(serverOptions);\n\n  // Install the sockjs handlers, but we want to keep around our own particular\n  // request handler that adjusts idle timeouts while we have an outstanding\n  // request.  This compensates for the fact that sockjs removes all listeners\n  // for \"request\" to add its own.\n  WebApp.httpServer.removeListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n  self.server.installHandlers(WebApp.httpServer);\n  WebApp.httpServer.addListener(\n    'request', WebApp._timeoutAdjustmentRequestCallback);\n\n  // Support the /websocket endpoint\n  self._redirectWebsocketEndpoint();\n\n  self.server.on('connection', function (socket) {\n    // sockjs sometimes passes us null instead of a socket object\n    // so we need to guard against that. see:\n    // https://github.com/sockjs/sockjs-node/issues/121\n    // https://github.com/meteor/meteor/issues/10468\n    if (!socket) return;\n\n    // We want to make sure that if a client connects to us and does the initial\n    // Websocket handshake but never gets to the DDP handshake, that we\n    // eventually kill the socket.  Once the DDP handshake happens, DDP\n    // heartbeating will work. And before the Websocket handshake, the timeouts\n    // we set at the server level in webapp_server.js will work. But\n    // faye-websocket calls setTimeout(0) on any socket it takes over, so there\n    // is an \"in between\" state where this doesn't happen.  We work around this\n    // by explicitly setting the socket timeout to a relatively large time here,\n    // and setting it back to zero when we set up the heartbeat in\n    // livedata_server.js.\n    socket.setWebsocketTimeout = function (timeout) {\n      if ((socket.protocol === 'websocket' ||\n           socket.protocol === 'websocket-raw')\n          && socket._session.recv) {\n        socket._session.recv.connection.setTimeout(timeout);\n      }\n    };\n    socket.setWebsocketTimeout(45 * 1000);\n\n    socket.send = function (data) {\n      socket.write(data);\n    };\n    socket.on('close', function () {\n      self.open_sockets = self.open_sockets.filter(function(value) {\n        return value !== socket;\n      });\n    });\n    self.open_sockets.push(socket);\n\n    // only to send a message after connection on tests, useful for\n    // socket-stream-client/server-tests.js\n    if (process.env.TEST_METADATA && process.env.TEST_METADATA !== \"{}\") {\n      socket.send(JSON.stringify({ testMessageOnConnect: true }));\n    }\n\n    // call all our callbacks when we get a new socket. they will do the\n    // work of setting up handlers and such for specific messages.\n    self.registration_callbacks.forEach(function (callback) {\n      callback(socket);\n    });\n  });\n\n};\n\nObject.assign(StreamServer.prototype, {\n  // call my callback when a new socket connects.\n  // also call it for all current connections.\n  register: function (callback) {\n    var self = this;\n    self.registration_callbacks.push(callback);\n    self.all_sockets().forEach(function (socket) {\n      callback(socket);\n    });\n  },\n\n  // get a list of all sockets\n  all_sockets: function () {\n    var self = this;\n    return Object.values(self.open_sockets);\n  },\n\n  // Redirect /websocket to /sockjs/websocket in order to not expose\n  // sockjs to clients that want to use raw websockets\n  _redirectWebsocketEndpoint: function() {\n    var self = this;\n    // Unfortunately we can't use a connect middleware here since\n    // sockjs installs itself prior to all existing listeners\n    // (meaning prior to any connect middlewares) so we need to take\n    // an approach similar to overshadowListeners in\n    // https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\n    ['request', 'upgrade'].forEach((event) => {\n      var httpServer = WebApp.httpServer;\n      var oldHttpServerListeners = httpServer.listeners(event).slice(0);\n      httpServer.removeAllListeners(event);\n\n      // request and upgrade have different arguments passed but\n      // we only care about the first one which is always request\n      var newListener = function(request /*, moreArguments */) {\n        // Store arguments for use within the closure below\n        var args = arguments;\n\n        // TODO replace with url package\n        var url = Npm.require('url');\n\n        // Rewrite /websocket and /websocket/ urls to /sockjs/websocket while\n        // preserving query string.\n        var parsedUrl = url.parse(request.url);\n        if (parsedUrl.pathname === pathPrefix + '/websocket' ||\n            parsedUrl.pathname === pathPrefix + '/websocket/') {\n          parsedUrl.pathname = self.prefix + '/websocket';\n          request.url = url.format(parsedUrl);\n        }\n        oldHttpServerListeners.forEach(function(oldListener) {\n          oldListener.apply(httpServer, args);\n        });\n      };\n      httpServer.addListener(event, newListener);\n    });\n  }\n});","import isEmpty from 'lodash.isempty';\nimport isObject from 'lodash.isobject';\nimport isString from 'lodash.isstring';\nimport { SessionCollectionView } from './session_collection_view';\nimport { SessionDocumentView } from './session_document_view';\n\nDDPServer = {};\n\n\n// Publication strategies define how we handle data from published cursors at the collection level\n// This allows someone to:\n// - Choose a trade-off between client-server bandwidth and server memory usage\n// - Implement special (non-mongo) collections like volatile message queues\nconst publicationStrategies = {\n  // SERVER_MERGE is the default strategy.\n  // When using this strategy, the server maintains a copy of all data a connection is subscribed to.\n  // This allows us to only send deltas over multiple publications.\n  SERVER_MERGE: {\n    useDummyDocumentView: false,\n    useCollectionView: true,\n    doAccountingForCollection: true,\n  },\n  // The NO_MERGE_NO_HISTORY strategy results in the server sending all publication data\n  // directly to the client. It does not remember what it has previously sent\n  // to it will not trigger removed messages when a subscription is stopped.\n  // This should only be chosen for special use cases like send-and-forget queues.\n  NO_MERGE_NO_HISTORY: {\n    useDummyDocumentView: false,\n    useCollectionView: false,\n    doAccountingForCollection: false,\n  },\n  // NO_MERGE is similar to NO_MERGE_NO_HISTORY but the server will remember the IDs it has\n  // sent to the client so it can remove them when a subscription is stopped.\n  // This strategy can be used when a collection is only used in a single publication.\n  NO_MERGE: {\n    useDummyDocumentView: false,\n    useCollectionView: false,\n    doAccountingForCollection: true,\n  },\n  // NO_MERGE_MULTI is similar to `NO_MERGE`, but it does track whether a document is\n  // used by multiple publications. This has some memory overhead, but it still does not do\n  // diffing so it's faster and slimmer than SERVER_MERGE.\n  NO_MERGE_MULTI: {\n    useDummyDocumentView: true,\n    useCollectionView: true,\n    doAccountingForCollection: true\n  }\n};\n\nDDPServer.publicationStrategies = publicationStrategies;\n\n// This file contains classes:\n// * Session - The server's connection to a single DDP client\n// * Subscription - A single subscription for a single client\n// * Server - An entire server that may talk to > 1 client. A DDP endpoint.\n//\n// Session and Subscription are file scope. For now, until we freeze\n// the interface, Server is package scope (in the future it should be\n// exported).\n\n\nDDPServer._SessionDocumentView = SessionDocumentView;\n\nDDPServer._getCurrentFence = function () {\n  let currentInvocation = this._CurrentWriteFence.get();\n  if (currentInvocation) {\n    return currentInvocation;\n  }\n  currentInvocation = DDP._CurrentMethodInvocation.get();\n  return currentInvocation ? currentInvocation.fence : undefined;\n};\n\n\nDDPServer._SessionCollectionView = SessionCollectionView;\n\n/******************************************************************************/\n/* Session                                                                    */\n/******************************************************************************/\n\nvar Session = function (server, version, socket, options) {\n  var self = this;\n  self.id = Random.id();\n\n  self.server = server;\n  self.version = version;\n\n  self.initialized = false;\n  self.socket = socket;\n\n  // Set to null when the session is destroyed. Multiple places below\n  // use this to determine if the session is alive or not.\n  self.inQueue = new Meteor._DoubleEndedQueue();\n\n  self.blocked = false;\n  self.workerRunning = false;\n\n  self.cachedUnblock = null;\n\n  // Sub objects for active subscriptions\n  self._namedSubs = new Map();\n  self._universalSubs = [];\n\n  self.userId = null;\n\n  self.collectionViews = new Map();\n\n  // Set this to false to not send messages when collectionViews are\n  // modified. This is done when rerunning subs in _setUserId and those messages\n  // are calculated via a diff instead.\n  self._isSending = true;\n\n  // If this is true, don't start a newly-created universal publisher on this\n  // session. The session will take care of starting it when appropriate.\n  self._dontStartNewUniversalSubs = false;\n\n  // When we are rerunning subscriptions, any ready messages\n  // we want to buffer up for when we are done rerunning subscriptions\n  self._pendingReady = [];\n\n  // List of callbacks to call when this connection is closed.\n  self._closeCallbacks = [];\n\n\n  // XXX HACK: If a sockjs connection, save off the URL. This is\n  // temporary and will go away in the near future.\n  self._socketUrl = socket.url;\n\n  // Allow tests to disable responding to pings.\n  self._respondToPings = options.respondToPings;\n\n  // This object is the public interface to the session. In the public\n  // API, it is called the `connection` object.  Internally we call it\n  // a `connectionHandle` to avoid ambiguity.\n  self.connectionHandle = {\n    id: self.id,\n    close: function () {\n      self.close();\n    },\n    onClose: function (fn) {\n      var cb = Meteor.bindEnvironment(fn, \"connection onClose callback\");\n      if (self.inQueue) {\n        self._closeCallbacks.push(cb);\n      } else {\n        // if we're already closed, call the callback.\n        Meteor.defer(cb);\n      }\n    },\n    clientAddress: self._clientAddress(),\n    httpHeaders: self.socket.headers\n  };\n\n  self.send({ msg: 'connected', session: self.id });\n\n  // On initial connect, spin up all the universal publishers.\n  self.startUniversalSubs();\n\n  if (version !== 'pre1' && options.heartbeatInterval !== 0) {\n    // We no longer need the low level timeout because we have heartbeats.\n    socket.setWebsocketTimeout(0);\n\n    self.heartbeat = new DDPCommon.Heartbeat({\n      heartbeatInterval: options.heartbeatInterval,\n      heartbeatTimeout: options.heartbeatTimeout,\n      onTimeout: function () {\n        self.close();\n      },\n      sendPing: function () {\n        self.send({msg: 'ping'});\n      }\n    });\n    self.heartbeat.start();\n  }\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"livedata\", \"sessions\", 1);\n};\n\nObject.assign(Session.prototype, {\n  sendReady: function (subscriptionIds) {\n    var self = this;\n    if (self._isSending) {\n      self.send({msg: \"ready\", subs: subscriptionIds});\n    } else {\n      subscriptionIds.forEach(function (subscriptionId) {\n        self._pendingReady.push(subscriptionId);\n      });\n    }\n  },\n\n  _canSend(collectionName) {\n    return this._isSending || !this.server.getPublicationStrategy(collectionName).useCollectionView;\n  },\n\n\n  sendAdded(collectionName, id, fields) {\n    if (this._canSend(collectionName)) {\n      this.send({ msg: 'added', collection: collectionName, id, fields });\n    }\n  },\n\n  sendChanged(collectionName, id, fields) {\n    if (isEmpty(fields))\n      return;\n\n    if (this._canSend(collectionName)) {\n      this.send({\n        msg: \"changed\",\n        collection: collectionName,\n        id,\n        fields\n      });\n    }\n  },\n\n  sendRemoved(collectionName, id) {\n    if (this._canSend(collectionName)) {\n      this.send({msg: \"removed\", collection: collectionName, id});\n    }\n  },\n\n  getSendCallbacks: function () {\n    var self = this;\n    return {\n      added: self.sendAdded.bind(self),\n      changed: self.sendChanged.bind(self),\n      removed: self.sendRemoved.bind(self)\n    };\n  },\n\n  getCollectionView: function (collectionName) {\n    var self = this;\n    var ret = self.collectionViews.get(collectionName);\n    if (!ret) {\n      ret = new SessionCollectionView(collectionName,\n                                        self.getSendCallbacks());\n      self.collectionViews.set(collectionName, ret);\n    }\n    return ret;\n  },\n\n  added(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.added(subscriptionHandle, id, fields);\n    } else {\n      this.sendAdded(collectionName, id, fields);\n    }\n  },\n\n  removed(subscriptionHandle, collectionName, id) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.removed(subscriptionHandle, id);\n      if (view.isEmpty()) {\n         this.collectionViews.delete(collectionName);\n      }\n    } else {\n      this.sendRemoved(collectionName, id);\n    }\n  },\n\n  changed(subscriptionHandle, collectionName, id, fields) {\n    if (this.server.getPublicationStrategy(collectionName).useCollectionView) {\n      const view = this.getCollectionView(collectionName);\n      view.changed(subscriptionHandle, id, fields);\n    } else {\n      this.sendChanged(collectionName, id, fields);\n    }\n  },\n\n  startUniversalSubs: function () {\n    var self = this;\n    // Make a shallow copy of the set of universal handlers and start them. If\n    // additional universal publishers start while we're running them (due to\n    // yielding), they will run separately as part of Server.publish.\n    var handlers = [...self.server.universal_publish_handlers];\n    handlers.forEach(function (handler) {\n      self._startSubscription(handler);\n    });\n  },\n\n  // Destroy this session and unregister it at the server.\n  close: function () {\n    var self = this;\n\n    // Destroy this session, even if it's not registered at the\n    // server. Stop all processing and tear everything down. If a socket\n    // was attached, close it.\n\n    // Already destroyed.\n    if (! self.inQueue)\n      return;\n\n    // Drop the merge box data immediately.\n    self.inQueue = null;\n    self.collectionViews = new Map();\n\n    if (self.heartbeat) {\n      self.heartbeat.stop();\n      self.heartbeat = null;\n    }\n\n    if (self.socket) {\n      self.socket.close();\n      self.socket._meteorSession = null;\n    }\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"livedata\", \"sessions\", -1);\n\n    Meteor.defer(function () {\n      // Stop callbacks can yield, so we defer this on close.\n      // sub._isDeactivated() detects that we set inQueue to null and\n      // treats it as semi-deactivated (it will ignore incoming callbacks, etc).\n      self._deactivateAllSubscriptions();\n\n      // Defer calling the close callbacks, so that the caller closing\n      // the session isn't waiting for all the callbacks to complete.\n      self._closeCallbacks.forEach(function (callback) {\n        callback();\n      });\n    });\n\n    // Unregister the session.\n    self.server._removeSession(self);\n  },\n\n  // Send a message (doing nothing if no socket is connected right now).\n  // It should be a JSON object (it will be stringified).\n  send: function (msg) {\n    const self = this;\n    if (self.socket) {\n      if (Meteor._printSentDDP)\n        Meteor._debug(\"Sent DDP\", DDPCommon.stringifyDDP(msg));\n      self.socket.send(DDPCommon.stringifyDDP(msg));\n    }\n  },\n\n  // Send a connection error.\n  sendError: function (reason, offendingMessage) {\n    var self = this;\n    var msg = {msg: 'error', reason: reason};\n    if (offendingMessage)\n      msg.offendingMessage = offendingMessage;\n    self.send(msg);\n  },\n\n  // Process 'msg' as an incoming message. As a guard against\n  // race conditions during reconnection, ignore the message if\n  // 'socket' is not the currently connected socket.\n  //\n  // We run the messages from the client one at a time, in the order\n  // given by the client. The message handler is passed an idempotent\n  // function 'unblock' which it may call to allow other messages to\n  // begin running in parallel in another fiber (for example, a method\n  // that wants to yield). Otherwise, it is automatically unblocked\n  // when it returns.\n  //\n  // Actually, we don't have to 'totally order' the messages in this\n  // way, but it's the easiest thing that's correct. (unsub needs to\n  // be ordered against sub, methods need to be ordered against each\n  // other).\n  processMessage: function (msg_in) {\n    var self = this;\n    if (!self.inQueue) // we have been destroyed.\n      return;\n\n    // Respond to ping and pong messages immediately without queuing.\n    // If the negotiated DDP version is \"pre1\" which didn't support\n    // pings, preserve the \"pre1\" behavior of responding with a \"bad\n    // request\" for the unknown messages.\n    //\n    // Fibers are needed because heartbeats use Meteor.setTimeout, which\n    // needs a Fiber. We could actually use regular setTimeout and avoid\n    // these new fibers, but it is easier to just make everything use\n    // Meteor.setTimeout and not think too hard.\n    //\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the client is still alive.\n    if (self.heartbeat) {\n      self.heartbeat.messageReceived();\n    };\n\n    if (self.version !== 'pre1' && msg_in.msg === 'ping') {\n      if (self._respondToPings)\n        self.send({msg: \"pong\", id: msg_in.id});\n      return;\n    }\n    if (self.version !== 'pre1' && msg_in.msg === 'pong') {\n      // Since everything is a pong, there is nothing to do\n      return;\n    }\n\n    self.inQueue.push(msg_in);\n    if (self.workerRunning)\n      return;\n    self.workerRunning = true;\n\n    var processNext = function () {\n      var msg = self.inQueue && self.inQueue.shift();\n\n      if (!msg) {\n        self.workerRunning = false;\n        return;\n      }\n\n      function runHandlers() {\n        var blocked = true;\n\n        var unblock = function () {\n          if (!blocked)\n            return; // idempotent\n          blocked = false;\n          setImmediate(processNext);\n        };\n\n        self.server.onMessageHook.each(function (callback) {\n          callback(msg, self);\n          return true;\n        });\n\n        if (msg.msg in self.protocol_handlers) {\n          const result = self.protocol_handlers[msg.msg].call(\n            self,\n            msg,\n            unblock\n          );\n\n          if (Meteor._isPromise(result)) {\n            result.finally(() => unblock());\n          } else {\n            unblock();\n          }\n        } else {\n          self.sendError('Bad request', msg);\n          unblock(); // in case the handler didn't already do it\n        }\n      }\n\n      runHandlers();\n    };\n\n    processNext();\n  },\n\n  protocol_handlers: {\n    sub: async function (msg, unblock) {\n      var self = this;\n\n      // cacheUnblock temporarly, so we can capture it later\n      // we will use unblock in current eventLoop, so this is safe\n      self.cachedUnblock = unblock;\n\n      // reject malformed messages\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.name) !== \"string\" ||\n          ('params' in msg && !(msg.params instanceof Array))) {\n        self.sendError(\"Malformed subscription\", msg);\n        return;\n      }\n\n      if (!self.server.publish_handlers[msg.name]) {\n        self.send({\n          msg: 'nosub', id: msg.id,\n          error: new Meteor.Error(404, `Subscription '${msg.name}' not found`)});\n        return;\n      }\n\n      if (self._namedSubs.has(msg.id))\n        // subs are idempotent, or rather, they are ignored if a sub\n        // with that id already exists. this is important during\n        // reconnect.\n        return;\n\n      // XXX It'd be much better if we had generic hooks where any package can\n      // hook into subscription handling, but in the mean while we special case\n      // ddp-rate-limiter package. This is also done for weak requirements to\n      // add the ddp-rate-limiter package in case we don't have Accounts. A\n      // user trying to use the ddp-rate-limiter must explicitly require it.\n      if (Package['ddp-rate-limiter']) {\n        var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n        var rateLimiterInput = {\n          userId: self.userId,\n          clientAddress: self.connectionHandle.clientAddress,\n          type: \"subscription\",\n          name: msg.name,\n          connectionId: self.id\n        };\n\n        DDPRateLimiter._increment(rateLimiterInput);\n        var rateLimitResult = DDPRateLimiter._check(rateLimiterInput);\n        if (!rateLimitResult.allowed) {\n          self.send({\n            msg: 'nosub', id: msg.id,\n            error: new Meteor.Error(\n              'too-many-requests',\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset})\n          });\n          return;\n        }\n      }\n\n      var handler = self.server.publish_handlers[msg.name];\n\n      await self._startSubscription(handler, msg.id, msg.params, msg.name);\n\n      // cleaning cached unblock\n      self.cachedUnblock = null;\n    },\n\n    unsub: function (msg) {\n      var self = this;\n\n      self._stopSubscription(msg.id);\n    },\n\n    method: async function (msg, unblock) {\n      var self = this;\n\n      // Reject malformed messages.\n      // For now, we silently ignore unknown attributes,\n      // for forwards compatibility.\n      if (typeof (msg.id) !== \"string\" ||\n          typeof (msg.method) !== \"string\" ||\n          ('params' in msg && !(msg.params instanceof Array)) ||\n          (('randomSeed' in msg) && (typeof msg.randomSeed !== \"string\"))) {\n        self.sendError(\"Malformed method invocation\", msg);\n        return;\n      }\n\n      var randomSeed = msg.randomSeed || null;\n\n      // Set up to mark the method as satisfied once all observers\n      // (and subscriptions) have reacted to any writes that were\n      // done.\n      var fence = new DDPServer._WriteFence;\n      fence.onAllCommitted(function () {\n        // Retire the fence so that future writes are allowed.\n        // This means that callbacks like timers are free to use\n        // the fence, and if they fire before it's armed (for\n        // example, because the method waits for them) their\n        // writes will be included in the fence.\n        fence.retire();\n        self.send({msg: 'updated', methods: [msg.id]});\n      });\n\n      // Find the handler\n      var handler = self.server.method_handlers[msg.method];\n      if (!handler) {\n        self.send({\n          msg: 'result', id: msg.id,\n          error: new Meteor.Error(404, `Method '${msg.method}' not found`)});\n        await fence.arm();\n        return;\n      }\n\n      var invocation = new DDPCommon.MethodInvocation({\n        name: msg.method,\n        isSimulation: false,\n        userId: self.userId,\n        setUserId(userId) {\n          return self._setUserId(userId);\n        },\n        unblock: unblock,\n        connection: self.connectionHandle,\n        randomSeed: randomSeed,\n        fence,\n      });\n\n      const promise = new Promise((resolve, reject) => {\n        // XXX It'd be better if we could hook into method handlers better but\n        // for now, we need to check if the ddp-rate-limiter exists since we\n        // have a weak requirement for the ddp-rate-limiter package to be added\n        // to our application.\n        if (Package['ddp-rate-limiter']) {\n          var DDPRateLimiter = Package['ddp-rate-limiter'].DDPRateLimiter;\n          var rateLimiterInput = {\n            userId: self.userId,\n            clientAddress: self.connectionHandle.clientAddress,\n            type: \"method\",\n            name: msg.method,\n            connectionId: self.id\n          };\n          DDPRateLimiter._increment(rateLimiterInput);\n          var rateLimitResult = DDPRateLimiter._check(rateLimiterInput)\n          if (!rateLimitResult.allowed) {\n            reject(new Meteor.Error(\n              \"too-many-requests\",\n              DDPRateLimiter.getErrorMessage(rateLimitResult),\n              {timeToReset: rateLimitResult.timeToReset}\n            ));\n            return;\n          }\n        }\n\n        resolve(DDPServer._CurrentWriteFence.withValue(\n          fence,\n          () => DDP._CurrentMethodInvocation.withValue(\n            invocation,\n            () => maybeAuditArgumentChecks(\n              handler, invocation, msg.params,\n              \"call to '\" + msg.method + \"'\"\n            )\n          )\n        ));\n      });\n\n      async function finish() {\n        await fence.arm();\n        unblock();\n      }\n\n      const payload = {\n        msg: \"result\",\n        id: msg.id\n      };\n      return promise.then(async result => {\n        await finish();\n        if (result !== undefined) {\n          payload.result = result;\n        }\n        self.send(payload);\n      }, async (exception) => {\n        await finish();\n        payload.error = wrapInternalException(\n          exception,\n          `while invoking method '${msg.method}'`\n        );\n        self.send(payload);\n      });\n    }\n  },\n\n  _eachSub: function (f) {\n    var self = this;\n    self._namedSubs.forEach(f);\n    self._universalSubs.forEach(f);\n  },\n\n  _diffCollectionViews: function (beforeCVs) {\n    var self = this;\n    DiffSequence.diffMaps(beforeCVs, self.collectionViews, {\n      both: function (collectionName, leftValue, rightValue) {\n        rightValue.diff(leftValue);\n      },\n      rightOnly: function (collectionName, rightValue) {\n        rightValue.documents.forEach(function (docView, id) {\n          self.sendAdded(collectionName, id, docView.getFields());\n        });\n      },\n      leftOnly: function (collectionName, leftValue) {\n        leftValue.documents.forEach(function (doc, id) {\n          self.sendRemoved(collectionName, id);\n        });\n      }\n    });\n  },\n\n  // Sets the current user id in all appropriate contexts and reruns\n  // all subscriptions\n  async _setUserId(userId) {\n    var self = this;\n\n    if (userId !== null && typeof userId !== \"string\")\n      throw new Error(\"setUserId must be called on string or null, not \" +\n                      typeof userId);\n\n    // Prevent newly-created universal subscriptions from being added to our\n    // session. They will be found below when we call startUniversalSubs.\n    //\n    // (We don't have to worry about named subscriptions, because we only add\n    // them when we process a 'sub' message. We are currently processing a\n    // 'method' message, and the method did not unblock, because it is illegal\n    // to call setUserId after unblock. Thus we cannot be concurrently adding a\n    // new named subscription).\n    self._dontStartNewUniversalSubs = true;\n\n    // Prevent current subs from updating our collectionViews and call their\n    // stop callbacks. This may yield.\n    self._eachSub(function (sub) {\n      sub._deactivate();\n    });\n\n    // All subs should now be deactivated. Stop sending messages to the client,\n    // save the state of the published collections, reset to an empty view, and\n    // update the userId.\n    self._isSending = false;\n    var beforeCVs = self.collectionViews;\n    self.collectionViews = new Map();\n    self.userId = userId;\n\n    // _setUserId is normally called from a Meteor method with\n    // DDP._CurrentMethodInvocation set. But DDP._CurrentMethodInvocation is not\n    // expected to be set inside a publish function, so we temporary unset it.\n    // Inside a publish function DDP._CurrentPublicationInvocation is set.\n    await DDP._CurrentMethodInvocation.withValue(undefined, async function () {\n      // Save the old named subs, and reset to having no subscriptions.\n      var oldNamedSubs = self._namedSubs;\n      self._namedSubs = new Map();\n      self._universalSubs = [];\n\n\n\n      await Promise.all([...oldNamedSubs].map(async ([subscriptionId, sub]) => {\n        const newSub = sub._recreate();\n        self._namedSubs.set(subscriptionId, newSub);\n        // nb: if the handler throws or calls this.error(), it will in fact\n        // immediately send its 'nosub'. This is OK, though.\n        await newSub._runHandler();\n      }));\n\n      // Allow newly-created universal subs to be started on our connection in\n      // parallel with the ones we're spinning up here, and spin up universal\n      // subs.\n      self._dontStartNewUniversalSubs = false;\n      self.startUniversalSubs();\n    }, { name: '_setUserId' });\n\n    // Start sending messages again, beginning with the diff from the previous\n    // state of the world to the current state. No yields are allowed during\n    // this diff, so that other changes cannot interleave.\n    Meteor._noYieldsAllowed(function () {\n      self._isSending = true;\n      self._diffCollectionViews(beforeCVs);\n      if (!isEmpty(self._pendingReady)) {\n        self.sendReady(self._pendingReady);\n        self._pendingReady = [];\n      }\n    });\n  },\n\n  _startSubscription: function (handler, subId, params, name) {\n    var self = this;\n\n    var sub = new Subscription(\n      self, handler, subId, params, name);\n\n    let unblockHander = self.cachedUnblock;\n    // _startSubscription may call from a lot places\n    // so cachedUnblock might be null in somecases\n    // assign the cachedUnblock\n    sub.unblock = unblockHander || (() => {});\n\n    if (subId)\n      self._namedSubs.set(subId, sub);\n    else\n      self._universalSubs.push(sub);\n\n    return sub._runHandler();\n  },\n\n  // Tear down specified subscription\n  _stopSubscription: function (subId, error) {\n    var self = this;\n\n    var subName = null;\n    if (subId) {\n      var maybeSub = self._namedSubs.get(subId);\n      if (maybeSub) {\n        subName = maybeSub._name;\n        maybeSub._removeAllDocuments();\n        maybeSub._deactivate();\n        self._namedSubs.delete(subId);\n      }\n    }\n\n    var response = {msg: 'nosub', id: subId};\n\n    if (error) {\n      response.error = wrapInternalException(\n        error,\n        subName ? (\"from sub \" + subName + \" id \" + subId)\n          : (\"from sub id \" + subId));\n    }\n\n    self.send(response);\n  },\n\n  // Tear down all subscriptions. Note that this does NOT send removed or nosub\n  // messages, since we assume the client is gone.\n  _deactivateAllSubscriptions: function () {\n    var self = this;\n\n    self._namedSubs.forEach(function (sub, id) {\n      sub._deactivate();\n    });\n    self._namedSubs = new Map();\n\n    self._universalSubs.forEach(function (sub) {\n      sub._deactivate();\n    });\n    self._universalSubs = [];\n  },\n\n  // Determine the remote client's IP address, based on the\n  // HTTP_FORWARDED_COUNT environment variable representing how many\n  // proxies the server is behind.\n  _clientAddress: function () {\n    var self = this;\n\n    // For the reported client address for a connection to be correct,\n    // the developer must set the HTTP_FORWARDED_COUNT environment\n    // variable to an integer representing the number of hops they\n    // expect in the `x-forwarded-for` header. E.g., set to \"1\" if the\n    // server is behind one proxy.\n    //\n    // This could be computed once at startup instead of every time.\n    var httpForwardedCount = parseInt(process.env['HTTP_FORWARDED_COUNT']) || 0;\n\n    if (httpForwardedCount === 0)\n      return self.socket.remoteAddress;\n\n    var forwardedFor = self.socket.headers[\"x-forwarded-for\"];\n    if (!isString(forwardedFor))\n      return null;\n    forwardedFor = forwardedFor.split(',')\n\n    // Typically the first value in the `x-forwarded-for` header is\n    // the original IP address of the client connecting to the first\n    // proxy.  However, the end user can easily spoof the header, in\n    // which case the first value(s) will be the fake IP address from\n    // the user pretending to be a proxy reporting the original IP\n    // address value.  By counting HTTP_FORWARDED_COUNT back from the\n    // end of the list, we ensure that we get the IP address being\n    // reported by *our* first proxy.\n\n    if (httpForwardedCount < 0 || httpForwardedCount !== forwardedFor.length)\n      return null;\n    forwardedFor = forwardedFor.map((ip) => ip.trim());\n    return forwardedFor[forwardedFor.length - httpForwardedCount];\n  }\n});\n\n/******************************************************************************/\n/* Subscription                                                               */\n/******************************************************************************/\n\n// Ctor for a sub handle: the input to each publish function\n\n// Instance name is this because it's usually referred to as this inside a\n// publish\n/**\n * @summary The server's side of a subscription\n * @class Subscription\n * @instanceName this\n * @showInstanceName true\n */\nvar Subscription = function (\n    session, handler, subscriptionId, params, name) {\n  var self = this;\n  self._session = session; // type is Session\n\n  /**\n   * @summary Access inside the publish function. The incoming [connection](#meteor_onconnection) for this subscription.\n   * @locus Server\n   * @name  connection\n   * @memberOf Subscription\n   * @instance\n   */\n  self.connection = session.connectionHandle; // public API object\n\n  self._handler = handler;\n\n  // My subscription ID (generated by client, undefined for universal subs).\n  self._subscriptionId = subscriptionId;\n  // Undefined for universal subs\n  self._name = name;\n\n  self._params = params || [];\n\n  // Only named subscriptions have IDs, but we need some sort of string\n  // internally to keep track of all subscriptions inside\n  // SessionDocumentViews. We use this subscriptionHandle for that.\n  if (self._subscriptionId) {\n    self._subscriptionHandle = 'N' + self._subscriptionId;\n  } else {\n    self._subscriptionHandle = 'U' + Random.id();\n  }\n\n  // Has _deactivate been called?\n  self._deactivated = false;\n\n  // Stop callbacks to g/c this sub.  called w/ zero arguments.\n  self._stopCallbacks = [];\n\n  // The set of (collection, documentid) that this subscription has\n  // an opinion about.\n  self._documents = new Map();\n\n  // Remember if we are ready.\n  self._ready = false;\n\n  // Part of the public API: the user of this sub.\n\n  /**\n   * @summary Access inside the publish function. The id of the logged-in user, or `null` if no user is logged in.\n   * @locus Server\n   * @memberOf Subscription\n   * @name  userId\n   * @instance\n   */\n  self.userId = session.userId;\n\n  // For now, the id filter is going to default to\n  // the to/from DDP methods on MongoID, to\n  // specifically deal with mongo/minimongo ObjectIds.\n\n  // Later, you will be able to make this be \"raw\"\n  // if you want to publish a collection that you know\n  // just has strings for keys and no funny business, to\n  // a DDP consumer that isn't minimongo.\n\n  self._idFilter = {\n    idStringify: MongoID.idStringify,\n    idParse: MongoID.idParse\n  };\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"livedata\", \"subscriptions\", 1);\n};\n\nObject.assign(Subscription.prototype, {\n  _runHandler: async function() {\n    // XXX should we unblock() here? Either before running the publish\n    // function, or before running _publishCursor.\n    //\n    // Right now, each publish function blocks all future publishes and\n    // methods waiting on data from Mongo (or whatever else the function\n    // blocks on). This probably slows page load in common cases.\n\n    if (!this.unblock) {\n      this.unblock = () => {};\n    }\n\n    const self = this;\n    let resultOrThenable = null;\n    try {\n      resultOrThenable = DDP._CurrentPublicationInvocation.withValue(\n        self,\n        () =>\n          maybeAuditArgumentChecks(\n            self._handler,\n            self,\n            EJSON.clone(self._params),\n            // It's OK that this would look weird for universal subscriptions,\n            // because they have no arguments so there can never be an\n            // audit-argument-checks failure.\n            \"publisher '\" + self._name + \"'\"\n          ),\n        { name: self._name }\n      );\n    } catch (e) {\n      self.error(e);\n      return;\n    }\n\n    // Did the handler call this.error or this.stop?\n    if (self._isDeactivated()) return;\n\n    // Both conventional and async publish handler functions are supported.\n    // If an object is returned with a then() function, it is either a promise\n    // or thenable and will be resolved asynchronously.\n    const isThenable =\n      resultOrThenable && typeof resultOrThenable.then === 'function';\n    if (isThenable) {\n      try {\n        await self._publishHandlerResult(await resultOrThenable);\n      } catch(e) {\n        self.error(e)\n      }\n    } else {\n      await self._publishHandlerResult(resultOrThenable);\n    }\n  },\n\n  async _publishHandlerResult (res) {\n    // SPECIAL CASE: Instead of writing their own callbacks that invoke\n    // this.added/changed/ready/etc, the user can just return a collection\n    // cursor or array of cursors from the publish function; we call their\n    // _publishCursor method which starts observing the cursor and publishes the\n    // results. Note that _publishCursor does NOT call ready().\n    //\n    // XXX This uses an undocumented interface which only the Mongo cursor\n    // interface publishes. Should we make this interface public and encourage\n    // users to implement it themselves? Arguably, it's unnecessary; users can\n    // already write their own functions like\n    //   var publishMyReactiveThingy = function (name, handler) {\n    //     Meteor.publish(name, function () {\n    //       var reactiveThingy = handler();\n    //       reactiveThingy.publishMe();\n    //     });\n    //   };\n\n    var self = this;\n    var isCursor = function (c) {\n      return c && c._publishCursor;\n    };\n    if (isCursor(res)) {\n      try {\n        await res._publishCursor(self);\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      // _publishCursor only returns after the initial added callbacks have run.\n      // mark subscription as ready.\n      self.ready();\n    } else if (Array.isArray(res)) {\n      // Check all the elements are cursors\n      if (! res.every(isCursor)) {\n        self.error(new Error(\"Publish function returned an array of non-Cursors\"));\n        return;\n      }\n      // Find duplicate collection names\n      // XXX we should support overlapping cursors, but that would require the\n      // merge box to allow overlap within a subscription\n      var collectionNames = {};\n\n      for (var i = 0; i < res.length; ++i) {\n        var collectionName = res[i]._getCollectionName();\n        if (collectionNames[collectionName]) {\n          self.error(new Error(\n            \"Publish function returned multiple cursors for collection \" +\n              collectionName));\n          return;\n        }\n        collectionNames[collectionName] = true;\n      }\n\n      try {\n        await Promise.all(res.map(cur => cur._publishCursor(self)));\n      } catch (e) {\n        self.error(e);\n        return;\n      }\n      self.ready();\n    } else if (res) {\n      // Truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      self.error(new Error(\"Publish function can only return a Cursor or \"\n                           + \"an array of Cursors\"));\n    }\n  },\n\n  // This calls all stop callbacks and prevents the handler from updating any\n  // SessionCollectionViews further. It's used when the user unsubscribes or\n  // disconnects, as well as during setUserId re-runs. It does *NOT* send\n  // removed messages for the published objects; if that is necessary, call\n  // _removeAllDocuments first.\n  _deactivate: function() {\n    var self = this;\n    if (self._deactivated)\n      return;\n    self._deactivated = true;\n    self._callStopCallbacks();\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n      \"livedata\", \"subscriptions\", -1);\n  },\n\n  _callStopCallbacks: function () {\n    var self = this;\n    // Tell listeners, so they can clean up\n    var callbacks = self._stopCallbacks;\n    self._stopCallbacks = [];\n    callbacks.forEach(function (callback) {\n      callback();\n    });\n  },\n\n  // Send remove messages for every document.\n  _removeAllDocuments: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._documents.forEach(function (collectionDocs, collectionName) {\n        collectionDocs.forEach(function (strId) {\n          self.removed(collectionName, self._idFilter.idParse(strId));\n        });\n      });\n    });\n  },\n\n  // Returns a new Subscription for the same session with the same\n  // initial creation parameters. This isn't a clone: it doesn't have\n  // the same _documents cache, stopped state or callbacks; may have a\n  // different _subscriptionHandle, and gets its userId from the\n  // session, not from this object.\n  _recreate: function () {\n    var self = this;\n    return new Subscription(\n      self._session, self._handler, self._subscriptionId, self._params,\n      self._name);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription, triggering a call on the client to the `onStop` callback passed to [`Meteor.subscribe`](#meteor_subscribe), if any. If `error` is not a [`Meteor.Error`](#meteor_error), it will be [sanitized](#meteor_error).\n   * @locus Server\n   * @param {Error} error The error to pass to the client.\n   * @instance\n   * @memberOf Subscription\n   */\n  error: function (error) {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId, error);\n  },\n\n  // Note that while our DDP client will notice that you've called stop() on the\n  // server (and clean up its _subscriptions table) we don't actually provide a\n  // mechanism for an app to notice this (the subscribe onError callback only\n  // triggers if there is an error).\n\n  /**\n   * @summary Call inside the publish function.  Stops this client's subscription and invokes the client's `onStop` callback with no error.\n   * @locus Server\n   * @instance\n   * @memberOf Subscription\n   */\n  stop: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    self._session._stopSubscription(self._subscriptionId);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Registers a callback function to run when the subscription is stopped.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {Function} func The callback function\n   */\n  onStop: function (callback) {\n    var self = this;\n    callback = Meteor.bindEnvironment(callback, 'onStop callback', self);\n    if (self._isDeactivated())\n      callback();\n    else\n      self._stopCallbacks.push(callback);\n  },\n\n  // This returns true if the sub has been deactivated, *OR* if the session was\n  // destroyed but the deferred call to _deactivateAllSubscriptions hasn't\n  // happened yet.\n  _isDeactivated: function () {\n    var self = this;\n    return self._deactivated || self._session.inQueue === null;\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been added to the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the new document.\n   * @param {String} id The new document's ID.\n   * @param {Object} fields The fields in the new document.  If `_id` is present it is ignored.\n   */\n  added (collectionName, id, fields) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      let ids = this._documents.get(collectionName);\n      if (ids == null) {\n        ids = new Set();\n        this._documents.set(collectionName, ids);\n      }\n      ids.add(id);\n    }\n\n    this._session.added(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document in the record set has been modified.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that contains the changed document.\n   * @param {String} id The changed document's ID.\n   * @param {Object} fields The fields in the document that have changed, together with their new values.  If a field is not present in `fields` it was left unchanged; if it is present in `fields` and has a value of `undefined` it was removed from the document.  If `_id` is present it is ignored.\n   */\n  changed (collectionName, id, fields) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n    this._session.changed(this._subscriptionHandle, collectionName, id, fields);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that a document has been removed from the record set.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   * @param {String} collection The name of the collection that the document has been removed from.\n   * @param {String} id The ID of the document that has been removed.\n   */\n  removed (collectionName, id) {\n    if (this._isDeactivated())\n      return;\n    id = this._idFilter.idStringify(id);\n\n    if (this._session.server.getPublicationStrategy(collectionName).doAccountingForCollection) {\n      // We don't bother to delete sets of things in a collection if the\n      // collection is empty.  It could break _removeAllDocuments.\n      this._documents.get(collectionName).delete(id);\n    }\n\n    this._session.removed(this._subscriptionHandle, collectionName, id);\n  },\n\n  /**\n   * @summary Call inside the publish function.  Informs the subscriber that an initial, complete snapshot of the record set has been sent.  This will trigger a call on the client to the `onReady` callback passed to  [`Meteor.subscribe`](#meteor_subscribe), if any.\n   * @locus Server\n   * @memberOf Subscription\n   * @instance\n   */\n  ready: function () {\n    var self = this;\n    if (self._isDeactivated())\n      return;\n    if (!self._subscriptionId)\n      return;  // Unnecessary but ignored for universal sub\n    if (!self._ready) {\n      self._session.sendReady([self._subscriptionId]);\n      self._ready = true;\n    }\n  }\n});\n\n/******************************************************************************/\n/* Server                                                                     */\n/******************************************************************************/\n\nServer = function (options = {}) {\n  var self = this;\n\n  // The default heartbeat interval is 30 seconds on the server and 35\n  // seconds on the client.  Since the client doesn't need to send a\n  // ping as long as it is receiving pings, this means that pings\n  // normally go from the server to the client.\n  //\n  // Note: Troposphere depends on the ability to mutate\n  // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n  self.options = {\n    heartbeatInterval: 15000,\n    heartbeatTimeout: 15000,\n    // For testing, allow responding to pings to be disabled.\n    respondToPings: true,\n    defaultPublicationStrategy: publicationStrategies.SERVER_MERGE,\n    ...options,\n  };\n\n  // Map of callbacks to call when a new connection comes in to the\n  // server and completes DDP version negotiation. Use an object instead\n  // of an array so we can safely remove one from the list while\n  // iterating over it.\n  self.onConnectionHook = new Hook({\n    debugPrintExceptions: \"onConnection callback\"\n  });\n\n  // Map of callbacks to call when a new message comes in.\n  self.onMessageHook = new Hook({\n    debugPrintExceptions: \"onMessage callback\"\n  });\n\n  self.publish_handlers = {};\n  self.universal_publish_handlers = [];\n\n  self.method_handlers = {};\n\n  self._publicationStrategies = {};\n\n  self.sessions = new Map(); // map from id to session\n\n  self.stream_server = new StreamServer();\n\n  self.stream_server.register(function (socket) {\n    // socket implements the SockJSConnection interface\n    socket._meteorSession = null;\n\n    var sendError = function (reason, offendingMessage) {\n      var msg = {msg: 'error', reason: reason};\n      if (offendingMessage)\n        msg.offendingMessage = offendingMessage;\n      socket.send(DDPCommon.stringifyDDP(msg));\n    };\n\n    socket.on('data', function (raw_msg) {\n      if (Meteor._printReceivedDDP) {\n        Meteor._debug(\"Received DDP\", raw_msg);\n      }\n      try {\n        try {\n          var msg = DDPCommon.parseDDP(raw_msg);\n        } catch (err) {\n          sendError('Parse error');\n          return;\n        }\n        if (msg === null || !msg.msg) {\n          sendError('Bad request', msg);\n          return;\n        }\n\n        if (msg.msg === 'connect') {\n          if (socket._meteorSession) {\n            sendError(\"Already connected\", msg);\n            return;\n          }\n\n          self._handleConnect(socket, msg);\n\n          return;\n        }\n\n        if (!socket._meteorSession) {\n          sendError('Must connect first', msg);\n          return;\n        }\n        socket._meteorSession.processMessage(msg);\n      } catch (e) {\n        // XXX print stack nicely\n        Meteor._debug(\"Internal exception while processing message\", msg, e);\n      }\n    });\n\n    socket.on('close', function () {\n      if (socket._meteorSession) {\n        socket._meteorSession.close();\n      }\n    });\n  });\n};\n\nObject.assign(Server.prototype, {\n\n  /**\n   * @summary Register a callback to be called when a new DDP connection is made to the server.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP connection is established.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onConnection: function (fn) {\n    var self = this;\n    return self.onConnectionHook.register(fn);\n  },\n\n  /**\n   * @summary Set publication strategy for the given collection. Publications strategies are available from `DDPServer.publicationStrategies`. You call this method from `Meteor.server`, like `Meteor.server.setPublicationStrategy()`\n   * @locus Server\n   * @alias setPublicationStrategy\n   * @param collectionName {String}\n   * @param strategy {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   */\n  setPublicationStrategy(collectionName, strategy) {\n    if (!Object.values(publicationStrategies).includes(strategy)) {\n      throw new Error(`Invalid merge strategy: ${strategy} \n        for collection ${collectionName}`);\n    }\n    this._publicationStrategies[collectionName] = strategy;\n  },\n\n  /**\n   * @summary Gets the publication strategy for the requested collection. You call this method from `Meteor.server`, like `Meteor.server.getPublicationStrategy()`\n   * @locus Server\n   * @alias getPublicationStrategy\n   * @param collectionName {String}\n   * @memberOf Meteor.server\n   * @importFromPackage meteor\n   * @return {{useCollectionView: boolean, doAccountingForCollection: boolean}}\n   */\n  getPublicationStrategy(collectionName) {\n    return this._publicationStrategies[collectionName]\n      || this.options.defaultPublicationStrategy;\n  },\n\n  /**\n   * @summary Register a callback to be called when a new DDP message is received.\n   * @locus Server\n   * @param {function} callback The function to call when a new DDP message is received.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  onMessage: function (fn) {\n    var self = this;\n    return self.onMessageHook.register(fn);\n  },\n\n  _handleConnect: function (socket, msg) {\n    var self = this;\n\n    // The connect message must specify a version and an array of supported\n    // versions, and it must claim to support what it is proposing.\n    if (!(typeof (msg.version) === 'string' &&\n          Array.isArray(msg.support) &&\n          msg.support.every(isString) &&\n          msg.support.includes(msg.version))) {\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed',\n                                version: DDPCommon.SUPPORTED_DDP_VERSIONS[0]}));\n      socket.close();\n      return;\n    }\n\n    // In the future, handle session resumption: something like:\n    //  socket._meteorSession = self.sessions[msg.session]\n    var version = calculateVersion(msg.support, DDPCommon.SUPPORTED_DDP_VERSIONS);\n\n    if (msg.version !== version) {\n      // The best version to use (according to the client's stated preferences)\n      // is not the one the client is trying to use. Inform them about the best\n      // version to use.\n      socket.send(DDPCommon.stringifyDDP({msg: 'failed', version: version}));\n      socket.close();\n      return;\n    }\n\n    // Yay, version matches! Create a new session.\n    // Note: Troposphere depends on the ability to mutate\n    // Meteor.server.options.heartbeatTimeout! This is a hack, but it's life.\n    socket._meteorSession = new Session(self, version, socket, self.options);\n    self.sessions.set(socket._meteorSession.id, socket._meteorSession);\n    self.onConnectionHook.each(function (callback) {\n      if (socket._meteorSession)\n        callback(socket._meteorSession.connectionHandle);\n      return true;\n    });\n  },\n  /**\n   * Register a publish handler function.\n   *\n   * @param name {String} identifier for query\n   * @param handler {Function} publish handler\n   * @param options {Object}\n   *\n   * Server will call handler function on each new subscription,\n   * either when receiving DDP sub message for a named subscription, or on\n   * DDP connect for a universal subscription.\n   *\n   * If name is null, this will be a subscription that is\n   * automatically established and permanently on for all connected\n   * client, instead of a subscription that can be turned on and off\n   * with subscribe().\n   *\n   * options to contain:\n   *  - (mostly internal) is_auto: true if generated automatically\n   *    from an autopublish hook. this is for cosmetic purposes only\n   *    (it lets us determine whether to print a warning suggesting\n   *    that you turn off autopublish).\n   */\n\n  /**\n   * @summary Publish a record set.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @locus Server\n   * @param {String|Object} name If String, name of the record set.  If Object, publications Dictionary of publish functions by name.  If `null`, the set has no name, and the record set is automatically sent to all connected clients.\n   * @param {Function} func Function called on the server each time a client subscribes.  Inside the function, `this` is the publish handler object, described below.  If the client passed arguments to `subscribe`, the function is called with the same arguments.\n   */\n  publish: function (name, handler, options) {\n    var self = this;\n\n    if (!isObject(name)) {\n      options = options || {};\n\n      if (name && name in self.publish_handlers) {\n        Meteor._debug(\"Ignoring duplicate publish named '\" + name + \"'\");\n        return;\n      }\n\n      if (Package.autopublish && !options.is_auto) {\n        // They have autopublish on, yet they're trying to manually\n        // pick stuff to publish. They probably should turn off\n        // autopublish. (This check isn't perfect -- if you create a\n        // publish before you turn on autopublish, it won't catch\n        // it, but this will definitely handle the simple case where\n        // you've added the autopublish package to your app, and are\n        // calling publish from your app code).\n        if (!self.warned_about_autopublish) {\n          self.warned_about_autopublish = true;\n          Meteor._debug(\n    \"** You've set up some data subscriptions with Meteor.publish(), but\\n\" +\n    \"** you still have autopublish turned on. Because autopublish is still\\n\" +\n    \"** on, your Meteor.publish() calls won't have much effect. All data\\n\" +\n    \"** will still be sent to all clients.\\n\" +\n    \"**\\n\" +\n    \"** Turn off autopublish by removing the autopublish package:\\n\" +\n    \"**\\n\" +\n    \"**   $ meteor remove autopublish\\n\" +\n    \"**\\n\" +\n    \"** .. and make sure you have Meteor.publish() and Meteor.subscribe() calls\\n\" +\n    \"** for each collection that you want clients to see.\\n\");\n        }\n      }\n\n      if (name)\n        self.publish_handlers[name] = handler;\n      else {\n        self.universal_publish_handlers.push(handler);\n        // Spin up the new publisher on any existing session too. Run each\n        // session's subscription in a new Fiber, so that there's no change for\n        // self.sessions to change while we're running this loop.\n        self.sessions.forEach(function (session) {\n          if (!session._dontStartNewUniversalSubs) {\n            session._startSubscription(handler);\n          }\n        });\n      }\n    }\n    else{\n      Object.entries(name).forEach(function([key, value]) {\n        self.publish(key, value, {});\n      });\n    }\n  },\n\n  _removeSession: function (session) {\n    var self = this;\n    self.sessions.delete(session.id);\n  },\n\n  /**\n   * @summary Tells if the method call came from a call or a callAsync.\n   * @locus Anywhere\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   * @returns boolean\n   */\n  isAsyncCall: function(){\n    return DDP._CurrentMethodInvocation._isCallAsyncMethodRunning()\n  },\n\n  /**\n   * @summary Defines functions that can be invoked over the network by clients.\n   * @locus Anywhere\n   * @param {Object} methods Dictionary whose keys are method names and values are functions.\n   * @memberOf Meteor\n   * @importFromPackage meteor\n   */\n  methods: function (methods) {\n    var self = this;\n    Object.entries(methods).forEach(function ([name, func]) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self.method_handlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self.method_handlers[name] = func;\n    });\n  },\n\n  call: function (name, ...args) {\n    if (args.length && typeof args[args.length - 1] === \"function\") {\n      // If it's a function, the last argument is the result callback, not\n      // a parameter to the remote method.\n      var callback = args.pop();\n    }\n\n    return this.apply(name, args, callback);\n  },\n\n  // A version of the call method that always returns a Promise.\n  callAsync: function (name, ...args) {\n    const options = args[0]?.hasOwnProperty('returnStubValue')\n      ? args.shift()\n      : {};\n    DDP._CurrentMethodInvocation._setCallAsyncMethodRunning(true);\n    const promise = new Promise((resolve, reject) => {\n      DDP._CurrentCallAsyncInvocation._set({ name, hasCallAsyncParent: true });\n      this.applyAsync(name, args, { isFromCallAsync: true, ...options })\n        .then(resolve)\n        .catch(reject)\n        .finally(() => {\n          DDP._CurrentCallAsyncInvocation._set();\n        });\n    });\n    return promise.finally(() =>\n      DDP._CurrentMethodInvocation._setCallAsyncMethodRunning(false)\n    );\n  },\n\n  apply: function (name, args, options, callback) {\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (! callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else {\n      options = options || {};\n    }\n    const promise = this.applyAsync(name, args, options);\n\n    // Return the result in whichever way the caller asked for it. Note that we\n    // do NOT block on the write fence in an analogous way to how the client\n    // blocks on the relevant data being visible, so you are NOT guaranteed that\n    // cursor observe callbacks have fired when your callback is invoked. (We\n    // can change this if there's a real use case).\n    if (callback) {\n      promise.then(\n        result => callback(undefined, result),\n        exception => callback(exception)\n      );\n    } else {\n      return promise;\n    }\n  },\n\n  // @param options {Optional Object}\n  applyAsync: function (name, args, options) {\n    // Run the handler\n    var handler = this.method_handlers[name];\n\n    if (! handler) {\n      return Promise.reject(\n        new Meteor.Error(404, `Method '${name}' not found`)\n      );\n    }\n    // If this is a method call from within another method or publish function,\n    // get the user state from the outer method or publish function, otherwise\n    // don't allow setUserId to be called\n    var userId = null;\n    let setUserId = () => {\n      throw new Error(\"Can't call setUserId on a server initiated method call\");\n    };\n    var connection = null;\n    var currentMethodInvocation = DDP._CurrentMethodInvocation.get();\n    var currentPublicationInvocation = DDP._CurrentPublicationInvocation.get();\n    var randomSeed = null;\n\n    if (currentMethodInvocation) {\n      userId = currentMethodInvocation.userId;\n      setUserId = (userId) => currentMethodInvocation.setUserId(userId);\n      connection = currentMethodInvocation.connection;\n      randomSeed = DDPCommon.makeRpcSeed(currentMethodInvocation, name);\n    } else if (currentPublicationInvocation) {\n      userId = currentPublicationInvocation.userId;\n      setUserId = (userId) => currentPublicationInvocation._session._setUserId(userId);\n      connection = currentPublicationInvocation.connection;\n    }\n\n    var invocation = new DDPCommon.MethodInvocation({\n      isSimulation: false,\n      userId,\n      setUserId,\n      connection,\n      randomSeed\n    });\n\n    return new Promise((resolve, reject) => {\n      let result;\n      try {\n        result = DDP._CurrentMethodInvocation.withValue(invocation, () =>\n          maybeAuditArgumentChecks(\n            handler,\n            invocation,\n            EJSON.clone(args),\n            \"internal call to '\" + name + \"'\"\n          )\n        );\n      } catch (e) {\n        return reject(e);\n      }\n      if (!Meteor._isPromise(result)) {\n        return resolve(result);\n      }\n      result.then(r => resolve(r)).catch(reject);\n    }).then(EJSON.clone);\n  },\n\n  _urlForSession: function (sessionId) {\n    var self = this;\n    var session = self.sessions.get(sessionId);\n    if (session)\n      return session._socketUrl;\n    else\n      return null;\n  }\n});\n\nvar calculateVersion = function (clientSupportedVersions,\n                                 serverSupportedVersions) {\n  var correctVersion = clientSupportedVersions.find(function (version) {\n    return serverSupportedVersions.includes(version);\n  });\n  if (!correctVersion) {\n    correctVersion = serverSupportedVersions[0];\n  }\n  return correctVersion;\n};\n\nDDPServer._calculateVersion = calculateVersion;\n\n\n// \"blind\" exceptions other than those that were deliberately thrown to signal\n// errors to the client\nvar wrapInternalException = function (exception, context) {\n  if (!exception) return exception;\n\n  // To allow packages to throw errors intended for the client but not have to\n  // depend on the Meteor.Error class, `isClientSafe` can be set to true on any\n  // error before it is thrown.\n  if (exception.isClientSafe) {\n    if (!(exception instanceof Meteor.Error)) {\n      const originalMessage = exception.message;\n      exception = new Meteor.Error(exception.error, exception.reason, exception.details);\n      exception.message = originalMessage;\n    }\n    return exception;\n  }\n\n  // Tests can set the '_expectedByTest' flag on an exception so it won't go to\n  // the server log.\n  if (!exception._expectedByTest) {\n    Meteor._debug(\"Exception \" + context, exception.stack);\n    if (exception.sanitizedError) {\n      Meteor._debug(\"Sanitized and reported to the client as:\", exception.sanitizedError);\n      Meteor._debug();\n    }\n  }\n\n  // Did the error contain more details that could have been useful if caught in\n  // server code (or if thrown from non-client-originated code), but also\n  // provided a \"sanitized\" version with more context than 500 Internal server error? Use that.\n  if (exception.sanitizedError) {\n    if (exception.sanitizedError.isClientSafe)\n      return exception.sanitizedError;\n    Meteor._debug(\"Exception \" + context + \" provides a sanitizedError that \" +\n                  \"does not have isClientSafe property set; ignoring\");\n  }\n\n  return new Meteor.Error(500, \"Internal server error\");\n};\n\n\n// Audit argument checks, if the audit-argument-checks package exists (it is a\n// weak dependency of this package).\nvar maybeAuditArgumentChecks = function (f, context, args, description) {\n  args = args || [];\n  if (Package['audit-argument-checks']) {\n    return Match._failIfArgumentsAreNotAllChecked(\n      f, context, args, description);\n  }\n  return f.apply(context, args);\n};","DDPServer._WriteFence = class {\n  constructor() {\n    this.armed = false;\n    this.fired = false;\n    this.retired = false;\n    this.outstanding_writes = 0;\n    this.before_fire_callbacks = [];\n    this.completion_callbacks = [];\n  }\n\n  beginWrite() {\n    if (this.retired) {\n      return { committed: () => {} };\n    }\n\n    if (this.fired) {\n      throw new Error(\"fence has already activated -- too late to add writes\");\n    }\n\n    this.outstanding_writes++;\n    let committed = false;\n\n    return {\n      committed: async () => {\n        if (committed) {\n          throw new Error(\"committed called twice on the same write\");\n        }\n        committed = true;\n        this.outstanding_writes--;\n        await this._maybeFire();\n      }\n    };\n  }\n\n  arm() {\n    if (this === DDPServer._getCurrentFence()) {\n      throw Error(\"Can't arm the current fence\");\n    }\n    this.armed = true;\n    return this._maybeFire();\n  }\n\n  onBeforeFire(func) {\n    if (this.fired) {\n      throw new Error(\"fence has already activated -- too late to add a callback\");\n    }\n    this.before_fire_callbacks.push(func);\n  }\n\n  onAllCommitted(func) {\n    if (this.fired) {\n      throw new Error(\"fence has already activated -- too late to add a callback\");\n    }\n    this.completion_callbacks.push(func);\n  }\n\n  async _armAndWait() {\n    let resolver;\n    const returnValue = new Promise(r => resolver = r);\n    this.onAllCommitted(resolver);\n    await this.arm();\n    return returnValue;\n  }\n\n  armAndWait() {\n    return this._armAndWait();\n  }\n\n  async _maybeFire() {\n    if (this.fired) {\n      throw new Error(\"write fence already activated?\");\n    }\n\n    if (!this.armed || this.outstanding_writes > 0) {\n      return;\n    }\n\n    const invokeCallback = async (func) => {\n      try {\n        await func(this);\n      } catch (err) {\n        Meteor._debug(\"exception in write fence callback:\", err);\n      }\n    };\n\n    this.outstanding_writes++;\n\n    // Process all before_fire callbacks in parallel\n    const beforeCallbacks = [...this.before_fire_callbacks];\n    this.before_fire_callbacks = [];\n    await Promise.all(beforeCallbacks.map(cb => invokeCallback(cb)));\n\n    this.outstanding_writes--;\n\n    if (this.outstanding_writes === 0) {\n      this.fired = true;\n      // Process all completion callbacks in parallel\n      const callbacks = [...this.completion_callbacks];\n      this.completion_callbacks = [];\n      await Promise.all(callbacks.map(cb => invokeCallback(cb)));\n    }\n  }\n\n  retire() {\n    if (!this.fired) {\n      throw new Error(\"Can't retire a fence that hasn't fired.\");\n    }\n    this.retired = true;\n  }\n};\n\nDDPServer._CurrentWriteFence = new Meteor.EnvironmentVariable;","// A \"crossbar\" is a class that provides structured notification registration.\n// See _match for the definition of how a notification matches a trigger.\n// All notifications and triggers must have a string key named 'collection'.\n\nDDPServer._Crossbar = function (options) {\n  var self = this;\n  options = options || {};\n\n  self.nextId = 1;\n  // map from collection name (string) -> listener id -> object. each object has\n  // keys 'trigger', 'callback'.  As a hack, the empty string means \"no\n  // collection\".\n  self.listenersByCollection = {};\n  self.listenersByCollectionCount = {};\n  self.factPackage = options.factPackage || \"livedata\";\n  self.factName = options.factName || null;\n};\n\nObject.assign(DDPServer._Crossbar.prototype, {\n  // msg is a trigger or a notification\n  _collectionForMessage: function (msg) {\n    var self = this;\n    if (!('collection' in msg)) {\n      return '';\n    } else if (typeof(msg.collection) === 'string') {\n      if (msg.collection === '')\n        throw Error(\"Message has empty collection!\");\n      return msg.collection;\n    } else {\n      throw Error(\"Message has non-string collection!\");\n    }\n  },\n\n  // Listen for notification that match 'trigger'. A notification\n  // matches if it has the key-value pairs in trigger as a\n  // subset. When a notification matches, call 'callback', passing\n  // the actual notification.\n  //\n  // Returns a listen handle, which is an object with a method\n  // stop(). Call stop() to stop listening.\n  //\n  // XXX It should be legal to call fire() from inside a listen()\n  // callback?\n  listen: function (trigger, callback) {\n    var self = this;\n    var id = self.nextId++;\n\n    var collection = self._collectionForMessage(trigger);\n    var record = {trigger: EJSON.clone(trigger), callback: callback};\n    if (! (collection in self.listenersByCollection)) {\n      self.listenersByCollection[collection] = {};\n      self.listenersByCollectionCount[collection] = 0;\n    }\n    self.listenersByCollection[collection][id] = record;\n    self.listenersByCollectionCount[collection]++;\n\n    if (self.factName && Package['facts-base']) {\n      Package['facts-base'].Facts.incrementServerFact(\n        self.factPackage, self.factName, 1);\n    }\n\n    return {\n      stop: function () {\n        if (self.factName && Package['facts-base']) {\n          Package['facts-base'].Facts.incrementServerFact(\n            self.factPackage, self.factName, -1);\n        }\n        delete self.listenersByCollection[collection][id];\n        self.listenersByCollectionCount[collection]--;\n        if (self.listenersByCollectionCount[collection] === 0) {\n          delete self.listenersByCollection[collection];\n          delete self.listenersByCollectionCount[collection];\n        }\n      }\n    };\n  },\n\n  // Fire the provided 'notification' (an object whose attribute\n  // values are all JSON-compatibile) -- inform all matching listeners\n  // (registered with listen()).\n  //\n  // If fire() is called inside a write fence, then each of the\n  // listener callbacks will be called inside the write fence as well.\n  //\n  // The listeners may be invoked in parallel, rather than serially.\n  fire: async function (notification) {\n    var self = this;\n\n    var collection = self._collectionForMessage(notification);\n\n    if (!(collection in self.listenersByCollection)) {\n      return;\n    }\n\n    var listenersForCollection = self.listenersByCollection[collection];\n    var callbackIds = [];\n    Object.entries(listenersForCollection).forEach(function ([id, l]) {\n      if (self._matches(notification, l.trigger)) {\n        callbackIds.push(id);\n      }\n    });\n\n    // Listener callbacks can yield, so we need to first find all the ones that\n    // match in a single iteration over self.listenersByCollection (which can't\n    // be mutated during this iteration), and then invoke the matching\n    // callbacks, checking before each call to ensure they haven't stopped.\n    // Note that we don't have to check that\n    // self.listenersByCollection[collection] still === listenersForCollection,\n    // because the only way that stops being true is if listenersForCollection\n    // first gets reduced down to the empty object (and then never gets\n    // increased again).\n    for (const id of callbackIds) {\n      if (id in listenersForCollection) {\n        await listenersForCollection[id].callback(notification);\n      }\n    }\n  },\n\n  // A notification matches a trigger if all keys that exist in both are equal.\n  //\n  // Examples:\n  //  N:{collection: \"C\"} matches T:{collection: \"C\"}\n  //    (a non-targeted write to a collection matches a\n  //     non-targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\"}\n  //    (a targeted write to a collection matches a non-targeted query)\n  //  N:{collection: \"C\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a non-targeted write to a collection matches a\n  //     targeted query)\n  //  N:{collection: \"C\", id: \"X\"} matches T:{collection: \"C\", id: \"X\"}\n  //    (a targeted write to a collection matches a targeted query targeted\n  //     at the same document)\n  //  N:{collection: \"C\", id: \"X\"} does not match T:{collection: \"C\", id: \"Y\"}\n  //    (a targeted write to a collection does not match a targeted query\n  //     targeted at a different document)\n  _matches: function (notification, trigger) {\n    // Most notifications that use the crossbar have a string `collection` and\n    // maybe an `id` that is a string or ObjectID. We're already dividing up\n    // triggers by collection, but let's fast-track \"nope, different ID\" (and\n    // avoid the overly generic EJSON.equals). This makes a noticeable\n    // performance difference; see https://github.com/meteor/meteor/pull/3697\n    if (typeof(notification.id) === 'string' &&\n        typeof(trigger.id) === 'string' &&\n        notification.id !== trigger.id) {\n      return false;\n    }\n    if (notification.id instanceof MongoID.ObjectID &&\n        trigger.id instanceof MongoID.ObjectID &&\n        ! notification.id.equals(trigger.id)) {\n      return false;\n    }\n\n    return Object.keys(trigger).every(function (key) {\n      return !(key in notification) || EJSON.equals(trigger[key], notification[key]);\n     });\n  }\n});\n\n// The \"invalidation crossbar\" is a specific instance used by the DDP server to\n// implement write fence notifications. Listener callbacks on this crossbar\n// should call beginWrite on the current write fence before they return, if they\n// want to delay the write fence from firing (ie, the DDP method-data-updated\n// message from being sent).\nDDPServer._InvalidationCrossbar = new DDPServer._Crossbar({\n  factName: \"invalidation-crossbar-listeners\"\n});","if (process.env.DDP_DEFAULT_CONNECTION_URL) {\n  __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL =\n    process.env.DDP_DEFAULT_CONNECTION_URL;\n}\n\nMeteor.server = new Server();\n\nMeteor.refresh = async function (notification) {\n  await DDPServer._InvalidationCrossbar.fire(notification);\n};\n\n// Proxy the public methods of Meteor.server so they can\n// be called directly on Meteor.\n\n  [\n    'publish',\n    'isAsyncCall',\n    'methods',\n    'call',\n    'callAsync',\n    'apply',\n    'applyAsync',\n    'onConnection',\n    'onMessage',\n  ].forEach(\n  function(name) {\n    Meteor[name] = Meteor.server[name].bind(Meteor.server);\n  }\n);\n","interface ChangeCollector {\n  [key: string]: any;\n}\n\ninterface DataEntry {\n  subscriptionHandle: string;\n  value: any;\n}\n\nexport class DummyDocumentView {\n  private existsIn: Set<string>;\n  private dataByKey: Map<string, DataEntry[]>;\n\n  constructor() {\n    this.existsIn = new Set<string>(); // set of subscriptionHandle\n    this.dataByKey = new Map<string, DataEntry[]>(); // key-> [ {subscriptionHandle, value} by precedence]\n  }\n\n  getFields(): Record<string, never> {\n    return {};\n  }\n\n  clearField(\n    subscriptionHandle: string, \n    key: string, \n    changeCollector: ChangeCollector\n  ): void {\n    changeCollector[key] = undefined;\n  }\n\n  changeField(\n    subscriptionHandle: string,\n    key: string,\n    value: any,\n    changeCollector: ChangeCollector,\n    isAdd?: boolean\n  ): void {\n    changeCollector[key] = value;\n  }\n}","import { DummyDocumentView } from \"./dummy_document_view\";\nimport { SessionDocumentView } from \"./session_document_view\";\n\ninterface SessionCallbacks {\n  added: (collectionName: string, id: string, fields: Record<string, any>) => void;\n  changed: (collectionName: string, id: string, fields: Record<string, any>) => void;\n  removed: (collectionName: string, id: string) => void;\n}\n\ntype DocumentView = SessionDocumentView | DummyDocumentView;\n\nexport class SessionCollectionView {\n  private readonly collectionName: string;\n  private readonly documents: Map<string, DocumentView>;\n  private readonly callbacks: SessionCallbacks;\n\n  /**\n   * Represents a client's view of a single collection\n   * @param collectionName - Name of the collection it represents\n   * @param sessionCallbacks - The callbacks for added, changed, removed\n   */\n  constructor(collectionName: string, sessionCallbacks: SessionCallbacks) {\n    this.collectionName = collectionName;\n    this.documents = new Map();\n    this.callbacks = sessionCallbacks;\n  }\n\n  public isEmpty(): boolean {\n    return this.documents.size === 0;\n  }\n\n  public diff(previous: SessionCollectionView): void {\n    DiffSequence.diffMaps(previous.documents, this.documents, {\n      both: this.diffDocument.bind(this),\n      rightOnly: (id: string, nowDV: DocumentView) => {\n        this.callbacks.added(this.collectionName, id, nowDV.getFields());\n      },\n      leftOnly: (id: string, prevDV: DocumentView) => {\n        this.callbacks.removed(this.collectionName, id);\n      }\n    });\n  }\n\n  private diffDocument(id: string, prevDV: DocumentView, nowDV: DocumentView): void {\n    const fields: Record<string, any> = {};\n    \n    DiffSequence.diffObjects(prevDV.getFields(), nowDV.getFields(), {\n      both: (key: string, prev: any, now: any) => {\n        if (!EJSON.equals(prev, now)) {\n          fields[key] = now;\n        }\n      },\n      rightOnly: (key: string, now: any) => {\n        fields[key] = now;\n      },\n      leftOnly: (key: string, prev: any) => {\n        fields[key] = undefined;\n      }\n    });\n    \n    this.callbacks.changed(this.collectionName, id, fields);\n  }\n\n  public added(subscriptionHandle: string, id: string, fields: Record<string, any>): void {\n    let docView: DocumentView | undefined = this.documents.get(id);\n    let added = false;\n\n    if (!docView) {\n      added = true;\n      if (Meteor.server.getPublicationStrategy(this.collectionName).useDummyDocumentView) {\n        docView = new DummyDocumentView();\n      } else {\n        docView = new SessionDocumentView();\n      }\n      this.documents.set(id, docView);\n    }\n\n    docView.existsIn.add(subscriptionHandle);\n    const changeCollector: Record<string, any> = {};\n\n    Object.entries(fields).forEach(([key, value]) => {\n      docView!.changeField(\n        subscriptionHandle,\n        key,\n        value,\n        changeCollector,\n        true\n      );\n    });\n\n    if (added) {\n      this.callbacks.added(this.collectionName, id, changeCollector);\n    } else {\n      this.callbacks.changed(this.collectionName, id, changeCollector);\n    }\n  }\n\n  public changed(subscriptionHandle: string, id: string, changed: Record<string, any>): void {\n    const changedResult: Record<string, any> = {};\n    const docView = this.documents.get(id);\n\n    if (!docView) {\n      throw new Error(`Could not find element with id ${id} to change`);\n    }\n\n    Object.entries(changed).forEach(([key, value]) => {\n      if (value === undefined) {\n        docView.clearField(subscriptionHandle, key, changedResult);\n      } else {\n        docView.changeField(subscriptionHandle, key, value, changedResult);\n      }\n    });\n\n    this.callbacks.changed(this.collectionName, id, changedResult);\n  }\n\n  public removed(subscriptionHandle: string, id: string): void {\n    const docView = this.documents.get(id);\n\n    if (!docView) {\n      throw new Error(`Removed nonexistent document ${id}`);\n    }\n\n    docView.existsIn.delete(subscriptionHandle);\n\n    if (docView.existsIn.size === 0) {\n      // it is gone from everyone\n      this.callbacks.removed(this.collectionName, id);\n      this.documents.delete(id);\n    } else {\n      const changed: Record<string, any> = {};\n      // remove this subscription from every precedence list\n      // and record the changes\n      docView.dataByKey.forEach((precedenceList, key) => {\n        docView.clearField(subscriptionHandle, key, changed);\n      });\n      this.callbacks.changed(this.collectionName, id, changed);\n    }\n  }\n}","interface PrecedenceItem {\n  subscriptionHandle: string;\n  value: any;\n}\n\ninterface ChangeCollector {\n  [key: string]: any;\n}\n\nexport class SessionDocumentView {\n  private existsIn: Set<string>;\n  private dataByKey: Map<string, PrecedenceItem[]>;\n\n  constructor() {\n    this.existsIn = new Set(); // set of subscriptionHandle\n    // Memory Growth\n    this.dataByKey = new Map(); // key-> [ {subscriptionHandle, value} by precedence]\n  }\n\n  getFields(): Record<string, any> {\n    const ret: Record<string, any> = {};\n    this.dataByKey.forEach((precedenceList, key) => {\n      ret[key] = precedenceList[0].value;\n    });\n    return ret;\n  }\n\n  clearField(\n    subscriptionHandle: string,\n    key: string,\n    changeCollector: ChangeCollector\n  ): void {\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\") return;\n\n    const precedenceList = this.dataByKey.get(key);\n    // It's okay to clear fields that didn't exist. No need to throw\n    // an error.\n    if (!precedenceList) return;\n\n    let removedValue: any = undefined;\n\n    for (let i = 0; i < precedenceList.length; i++) {\n      const precedence = precedenceList[i];\n      if (precedence.subscriptionHandle === subscriptionHandle) {\n        // The view's value can only change if this subscription is the one that\n        // used to have precedence.\n        if (i === 0) removedValue = precedence.value;\n        precedenceList.splice(i, 1);\n        break;\n      }\n    }\n\n    if (precedenceList.length === 0) {\n      this.dataByKey.delete(key);\n      changeCollector[key] = undefined;\n    } else if (\n      removedValue !== undefined &&\n      !EJSON.equals(removedValue, precedenceList[0].value)\n    ) {\n      changeCollector[key] = precedenceList[0].value;\n    }\n  }\n\n  changeField(\n    subscriptionHandle: string,\n    key: string,\n    value: any,\n    changeCollector: ChangeCollector,\n    isAdd: boolean = false\n  ): void {\n    // Publish API ignores _id if present in fields\n    if (key === \"_id\") return;\n\n    // Don't share state with the data passed in by the user.\n    value = EJSON.clone(value);\n\n    if (!this.dataByKey.has(key)) {\n      this.dataByKey.set(key, [\n        { subscriptionHandle: subscriptionHandle, value: value },\n      ]);\n      changeCollector[key] = value;\n      return;\n    }\n\n    const precedenceList = this.dataByKey.get(key)!;\n    let elt: PrecedenceItem | undefined;\n\n    if (!isAdd) {\n      elt = precedenceList.find(\n        (precedence) => precedence.subscriptionHandle === subscriptionHandle\n      );\n    }\n\n    if (elt) {\n      if (elt === precedenceList[0] && !EJSON.equals(value, elt.value)) {\n        // this subscription is changing the value of this field.\n        changeCollector[key] = value;\n      }\n      elt.value = value;\n    } else {\n      // this subscription is newly caring about this field\n      precedenceList.push({ subscriptionHandle: subscriptionHandle, value: value });\n    }\n  }\n}"]}