{"version":3,"sources":["meteor://ðŸ’»app/packages/diff-sequence/diff.js"],"names":["DiffSequence","hasOwn","Object","prototype","hasOwnProperty","isObjEmpty","obj","key","call","diffQueryChanges","ordered","oldResults","newResults","observer","options","diffQueryOrderedChanges","diffQueryUnorderedChanges","projectionFn","EJSON","clone","movedBefore","Error","forEach","newDoc","id","oldDoc","get","changed","equals","projectedNew","projectedOld","changedFields","makeChangedFields","added","fields","_id","removed","has","old_results","new_results","new_presence_of_id","doc","Meteor","_debug","old_index_of_id","i","unmoved","max_seq_len","N","length","seq_ends","Array","ptrs","old_idx_seq","i_new","undefined","j","idx","push","reverse","startOfGroup","endOfGroup","groupId","addedBefore","diffObjects","left","right","callbacks","keys","leftValue","both","leftOnly","rightOnly","rightValue","diffMaps","value","applyChanges","changeFields"],"mappings":"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","file":"/packages/diff-sequence.js","sourcesContent":["export const DiffSequence = {};\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nfunction isObjEmpty(obj) {\n  for (let key in Object(obj)) {\n    if (hasOwn.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// ordered: bool.\n// old_results and new_results: collections of documents.\n//    if ordered, they are arrays.\n//    if unordered, they are IdMaps\nDiffSequence.diffQueryChanges = function (ordered, oldResults, newResults,\n                                              observer, options) {\n  if (ordered)\n    DiffSequence.diffQueryOrderedChanges(\n      oldResults, newResults, observer, options);\n  else\n    DiffSequence.diffQueryUnorderedChanges(\n      oldResults, newResults, observer, options);\n};\n\nDiffSequence.diffQueryUnorderedChanges = function (oldResults, newResults,\n                                                       observer, options) {\n  options = options || {};\n  var projectionFn = options.projectionFn || EJSON.clone;\n\n  if (observer.movedBefore) {\n    throw new Error(\"_diffQueryUnordered called with a movedBefore observer!\");\n  }\n\n  newResults.forEach(function (newDoc, id) {\n    var oldDoc = oldResults.get(id);\n    if (oldDoc) {\n      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {\n        var projectedNew = projectionFn(newDoc);\n        var projectedOld = projectionFn(oldDoc);\n        var changedFields =\n              DiffSequence.makeChangedFields(projectedNew, projectedOld);\n        if (! isObjEmpty(changedFields)) {\n          observer.changed(id, changedFields);\n        }\n      }\n    } else if (observer.added) {\n      var fields = projectionFn(newDoc);\n      delete fields._id;\n      observer.added(newDoc._id, fields);\n    }\n  });\n\n  if (observer.removed) {\n    oldResults.forEach(function (oldDoc, id) {\n      if (!newResults.has(id))\n        observer.removed(id);\n    });\n  }\n};\n\nDiffSequence.diffQueryOrderedChanges = function (old_results, new_results,\n                                                     observer, options) {\n  options = options || {};\n  var projectionFn = options.projectionFn || EJSON.clone;\n\n  var new_presence_of_id = {};\n  new_results.forEach(function (doc) {\n    if (new_presence_of_id[doc._id])\n      Meteor._debug(\"Duplicate _id in new_results\");\n    new_presence_of_id[doc._id] = true;\n  });\n\n  var old_index_of_id = {};\n  old_results.forEach(function (doc, i) {\n    if (doc._id in old_index_of_id)\n      Meteor._debug(\"Duplicate _id in old_results\");\n    old_index_of_id[doc._id] = i;\n  });\n\n  // ALGORITHM:\n  //\n  // To determine which docs should be considered \"moved\" (and which\n  // merely change position because of other docs moving) we run\n  // a \"longest common subsequence\" (LCS) algorithm.  The LCS of the\n  // old doc IDs and the new doc IDs gives the docs that should NOT be\n  // considered moved.\n\n  // To actually call the appropriate callbacks to get from the old state to the\n  // new state:\n\n  // First, we call removed() on all the items that only appear in the old\n  // state.\n\n  // Then, once we have the items that should not move, we walk through the new\n  // results array group-by-group, where a \"group\" is a set of items that have\n  // moved, anchored on the end by an item that should not move.  One by one, we\n  // move each of those elements into place \"before\" the anchoring end-of-group\n  // item, and fire changed events on them if necessary.  Then we fire a changed\n  // event on the anchor, and move on to the next group.  There is always at\n  // least one group; the last group is anchored by a virtual \"null\" id at the\n  // end.\n\n  // Asymptotically: O(N k) where k is number of ops, or potentially\n  // O(N log N) if inner loop of LCS were made to be binary search.\n\n\n  //////// LCS (longest common sequence, with respect to _id)\n  // (see Wikipedia article on Longest Increasing Subsequence,\n  // where the LIS is taken of the sequence of old indices of the\n  // docs in new_results)\n  //\n  // unmoved: the output of the algorithm; members of the LCS,\n  // in the form of indices into new_results\n  var unmoved = [];\n  // max_seq_len: length of LCS found so far\n  var max_seq_len = 0;\n  // seq_ends[i]: the index into new_results of the last doc in a\n  // common subsequence of length of i+1 <= max_seq_len\n  var N = new_results.length;\n  var seq_ends = new Array(N);\n  // ptrs:  the common subsequence ending with new_results[n] extends\n  // a common subsequence ending with new_results[ptr[n]], unless\n  // ptr[n] is -1.\n  var ptrs = new Array(N);\n  // virtual sequence of old indices of new results\n  var old_idx_seq = function(i_new) {\n    return old_index_of_id[new_results[i_new]._id];\n  };\n  // for each item in new_results, use it to extend a common subsequence\n  // of length j <= max_seq_len\n  for(var i=0; i<N; i++) {\n    if (old_index_of_id[new_results[i]._id] !== undefined) {\n      var j = max_seq_len;\n      // this inner loop would traditionally be a binary search,\n      // but scanning backwards we will likely find a subseq to extend\n      // pretty soon, bounded for example by the total number of ops.\n      // If this were to be changed to a binary search, we'd still want\n      // to scan backwards a bit as an optimization.\n      while (j > 0) {\n        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))\n          break;\n        j--;\n      }\n\n      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);\n      seq_ends[j] = i;\n      if (j+1 > max_seq_len)\n        max_seq_len = j+1;\n    }\n  }\n\n  // pull out the LCS/LIS into unmoved\n  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);\n  while (idx >= 0) {\n    unmoved.push(idx);\n    idx = ptrs[idx];\n  }\n  // the unmoved item list is built backwards, so fix that\n  unmoved.reverse();\n\n  // the last group is always anchored by the end of the result list, which is\n  // an id of \"null\"\n  unmoved.push(new_results.length);\n\n  old_results.forEach(function (doc) {\n    if (!new_presence_of_id[doc._id])\n      observer.removed && observer.removed(doc._id);\n  });\n\n  // for each group of things in the new_results that is anchored by an unmoved\n  // element, iterate through the things before it.\n  var startOfGroup = 0;\n  unmoved.forEach(function (endOfGroup) {\n    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;\n    var oldDoc, newDoc, fields, projectedNew, projectedOld;\n    for (var i = startOfGroup; i < endOfGroup; i++) {\n      newDoc = new_results[i];\n      if (!hasOwn.call(old_index_of_id, newDoc._id)) {\n        fields = projectionFn(newDoc);\n        delete fields._id;\n        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);\n        observer.added && observer.added(newDoc._id, fields);\n      } else {\n        // moved\n        oldDoc = old_results[old_index_of_id[newDoc._id]];\n        projectedNew = projectionFn(newDoc);\n        projectedOld = projectionFn(oldDoc);\n        fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n        if (!isObjEmpty(fields)) {\n          observer.changed && observer.changed(newDoc._id, fields);\n        }\n        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);\n      }\n    }\n    if (groupId) {\n      newDoc = new_results[endOfGroup];\n      oldDoc = old_results[old_index_of_id[newDoc._id]];\n      projectedNew = projectionFn(newDoc);\n      projectedOld = projectionFn(oldDoc);\n      fields = DiffSequence.makeChangedFields(projectedNew, projectedOld);\n      if (!isObjEmpty(fields)) {\n        observer.changed && observer.changed(newDoc._id, fields);\n      }\n    }\n    startOfGroup = endOfGroup+1;\n  });\n\n\n};\n\n\n// General helper for diff-ing two objects.\n// callbacks is an object like so:\n// { leftOnly: function (key, leftValue) {...},\n//   rightOnly: function (key, rightValue) {...},\n//   both: function (key, leftValue, rightValue) {...},\n// }\nDiffSequence.diffObjects = function (left, right, callbacks) {\n  Object.keys(left).forEach(key => {\n    const leftValue = left[key];\n    if (hasOwn.call(right, key)) {\n      callbacks.both && callbacks.both(key, leftValue, right[key]);\n    } else {\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\n    }\n  });\n\n  if (callbacks.rightOnly) {\n    Object.keys(right).forEach(key => {\n      const rightValue = right[key];\n      if (! hasOwn.call(left, key)) {\n        callbacks.rightOnly(key, rightValue);\n      }\n    });\n  }\n};\n\nDiffSequence.diffMaps = function (left, right, callbacks) {\n  left.forEach(function (leftValue, key) {\n    if (right.has(key)){\n      callbacks.both && callbacks.both(key, leftValue, right.get(key));\n    } else {\n      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);\n    }\n  });\n\n  if (callbacks.rightOnly) {\n    right.forEach(function (rightValue, key) {\n      if (!left.has(key)){\n        callbacks.rightOnly(key, rightValue);\n      }\n    });\n  }\n};\n\n\nDiffSequence.makeChangedFields = function (newDoc, oldDoc) {\n  var fields = {};\n  DiffSequence.diffObjects(oldDoc, newDoc, {\n    leftOnly: function (key, value) {\n      fields[key] = undefined;\n    },\n    rightOnly: function (key, value) {\n      fields[key] = value;\n    },\n    both: function (key, leftValue, rightValue) {\n      if (!EJSON.equals(leftValue, rightValue))\n        fields[key] = rightValue;\n    }\n  });\n  return fields;\n};\n\nDiffSequence.applyChanges = function (doc, changeFields) {\n  Object.keys(changeFields).forEach(key => {\n    const value = changeFields[key];\n    if (typeof value === \"undefined\") {\n      delete doc[key];\n    } else {\n      doc[key] = value;\n    }\n  });\n};\n\n"]}