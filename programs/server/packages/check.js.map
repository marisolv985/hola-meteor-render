{"version":3,"sources":["meteor://ðŸ’»app/packages/check/match.js","meteor://ðŸ’»app/packages/check/isPlainObject.js"],"names":["currentArgumentChecker","Meteor","EnvironmentVariable","hasOwn","Object","prototype","hasOwnProperty","format","result","err","Match","Error","message","path","check","value","pattern","options","throwAllErrors","argChecker","getOrNullIfOutsideFiber","checking","testSubtree","Array","isArray","map","r","Optional","Maybe","OneOf","args","Any","Where","condition","ObjectIncluding","ObjectWithValues","Integer","makeErrorType","msg","sanitizedError","test","_failIfArgumentsAreNotAllChecked","f","context","description","ArgumentChecker","withValue","apply","throwUnlessAllArgumentsHaveBeenChecked","choices","length","stringForErrorMessage","onlyShowType","EJSON","stringify","JSON","stringifyError","name","typeofChecks","String","Number","Boolean","Function","undefined","collectErrors","errors","i","isArguments","arrPath","_prependPath","push","unknownKeysAllowed","unknownKeyPattern","isPlainObject","requiredPatterns","create","optionalPatterns","keys","forEach","key","subPattern","subValue","objPath","call","createMissingError","_checkingOneValue","bind","isNaN","splice","reverse","_jsKeywords","base","match","indexOf","isObject","baseIsArguments","item","toString","arguments","callee","class2type","fnToString","ObjectFunctionString","getProto","getPrototypeOf","obj","proto","Ctor"],"mappings":"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","file":"/packages/check.js","sourcesContent":["// XXX docs\nimport { isPlainObject } from './isPlainObject';\n\n// Things we explicitly do NOT support:\n//    - heterogenous arrays\n\nconst currentArgumentChecker = new Meteor.EnvironmentVariable;\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nconst format = result => {\n  const err = new Match.Error(result.message);\n  if (result.path) {\n    err.message += ` in field ${result.path}`;\n    err.path = result.path;\n  }\n\n  return err;\n}\n\n/**\n * @summary Check that a value matches a [pattern](#matchpatterns).\n * If the value does not match the pattern, throw a `Match.Error`.\n * By default, it will throw immediately at the first error encountered. Pass in { throwAllErrors: true } to throw all errors.\n *\n * Particularly useful to assert that arguments to a function have the right\n * types and structure.\n * @locus Anywhere\n * @param {Any} value The value to check\n * @param {MatchPattern} pattern The pattern to match `value` against\n * @param {Object} [options={}] Additional options for check\n * @param {Boolean} [options.throwAllErrors=false] If true, throw all errors\n */\nexport function check(value, pattern, options = { throwAllErrors: false }) {\n  // Record that check got called, if somebody cared.\n  //\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\n  // from non-Fiber server contexts; the downside is that if you forget to\n  // bindEnvironment on some random callback in your method/publisher,\n  // it might not find the argumentChecker and you'll get an error about\n  // not checking an argument that it looks like you're checking (instead\n  // of just getting a \"Node code must run in a Fiber\" error).\n  const argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n  if (argChecker) {\n    argChecker.checking(value);\n  }\n\n  const result = testSubtree(value, pattern, options.throwAllErrors);\n\n  if (result) {\n    if (options.throwAllErrors) {\n      throw Array.isArray(result) ? result.map(r => format(r)) : [format(result)]\n    } else {\n      throw format(result)\n    }\n  }\n};\n\n/**\n * @namespace Match\n * @summary The namespace for all Match types and methods.\n */\nexport const Match = {\n  Optional: function(pattern) {\n    return new Optional(pattern);\n  },\n\n  Maybe: function(pattern) {\n    return new Maybe(pattern);\n  },\n\n  OneOf: function(...args) {\n    return new OneOf(args);\n  },\n\n  Any: ['__any__'],\n  Where: function(condition) {\n    return new Where(condition);\n  },\n\n  ObjectIncluding: function(pattern) {\n    return new ObjectIncluding(pattern)\n  },\n\n  ObjectWithValues: function(pattern) {\n    return new ObjectWithValues(pattern);\n  },\n\n  // Matches only signed 32-bit integers\n  Integer: ['__integer__'],\n\n  // XXX matchers should know how to describe themselves for errors\n  Error: Meteor.makeErrorType('Match.Error', function (msg) {\n    this.message = `Match error: ${msg}`;\n\n    // The path of the value that failed to match. Initially empty, this gets\n    // populated by catching and rethrowing the exception as it goes back up the\n    // stack.\n    // E.g.: \"vals[3].entity.created\"\n    this.path = '';\n\n    // If this gets sent over DDP, don't give full internal details but at least\n    // provide something better than 500 Internal server error.\n    this.sanitizedError = new Meteor.Error(400, 'Match failed');\n  }),\n\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\n  // or false (unless an error other than Match.Error was thrown). It does not\n  // interact with _failIfArgumentsAreNotAllChecked.\n  // XXX maybe also implement a Match.match which returns more information about\n  //     failures but without using exception handling or doing what check()\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n  /**\n   * @summary Returns true if the value matches the pattern.\n   * @locus Anywhere\n   * @param {Any} value The value to check\n   * @param {MatchPattern} pattern The pattern to match `value` against\n   */\n  test(value, pattern) {\n    return !testSubtree(value, pattern);\n  },\n\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\n  // `args` (either directly or in the first level of an array), throws an error\n  // (using `description` in the message).\n  _failIfArgumentsAreNotAllChecked(f, context, args, description) {\n    const argChecker = new ArgumentChecker(args, description);\n    const result = currentArgumentChecker.withValue(\n      argChecker,\n      () => f.apply(context, args)\n    );\n\n    // If f didn't itself throw, make sure it checked all of its arguments.\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n    return result;\n  }\n};\n\nclass Optional {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nclass Maybe {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nclass OneOf {\n  constructor(choices) {\n    if (!choices || choices.length === 0) {\n      throw new Error('Must provide at least one choice to Match.OneOf');\n    }\n\n    this.choices = choices;\n  }\n}\n\nclass Where {\n  constructor(condition) {\n    this.condition = condition;\n  }\n}\n\nclass ObjectIncluding {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nclass ObjectWithValues {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n}\n\nconst stringForErrorMessage = (value, options = {}) => {\n  if ( value === null ) {\n    return 'null';\n  }\n\n  if ( options.onlyShowType ) {\n    return typeof value;\n  }\n\n  // Your average non-object things.  Saves from doing the try/catch below for.\n  if ( typeof value !== 'object' ) {\n    return EJSON.stringify(value)\n  }\n\n  try {\n\n    // Find objects with circular references since EJSON doesn't support them yet (Issue #4778 + Unaccepted PR)\n    // If the native stringify is going to choke, EJSON.stringify is going to choke too.\n    JSON.stringify(value);\n  } catch (stringifyError) {\n    if ( stringifyError.name === 'TypeError' ) {\n      return typeof value;\n    }\n  }\n\n  return EJSON.stringify(value);\n};\n\nconst typeofChecks = [\n  [String, 'string'],\n  [Number, 'number'],\n  [Boolean, 'boolean'],\n\n  // While we don't allow undefined/function in EJSON, this is good for optional\n  // arguments with OneOf.\n  [Function, 'function'],\n  [undefined, 'undefined'],\n];\n\n// Return `false` if it matches. Otherwise, returns an object with a `message` and a `path` field or an array of objects each with a `message` and a `path` field when collecting errors.\nconst testSubtree = (value, pattern, collectErrors = false, errors = [], path = '') => {\n  // Match anything!\n  if (pattern === Match.Any) {\n    return false;\n  }\n\n  // Basic atomic types.\n  // Do not match boxed objects (e.g. String, Boolean)\n  for (let i = 0; i < typeofChecks.length; ++i) {\n    if (pattern === typeofChecks[i][0]) {\n      if (typeof value === typeofChecks[i][1]) {\n        return false;\n      }\n\n      return {\n        message: `Expected ${typeofChecks[i][1]}, got ${stringForErrorMessage(value, { onlyShowType: true })}`,\n        path: '',\n      };\n    }\n  }\n\n  if (pattern === null) {\n    if (value === null) {\n      return false;\n    }\n\n    return {\n      message: `Expected null, got ${stringForErrorMessage(value)}`,\n      path: '',\n    };\n  }\n\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n  if (typeof pattern === 'string' || typeof pattern === 'number' || typeof pattern === 'boolean') {\n    if (value === pattern) {\n      return false;\n    }\n\n    return {\n      message: `Expected ${pattern}, got ${stringForErrorMessage(value)}`,\n      path: '',\n    };\n  }\n\n  // Match.Integer is special type encoded with array\n  if (pattern === Match.Integer) {\n\n    // There is no consistent and reliable way to check if variable is a 64-bit\n    // integer. One of the popular solutions is to get reminder of division by 1\n    // but this method fails on really large floats with big precision.\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n    // Bitwise operators work consistantly but always cast variable to 32-bit\n    // signed integer according to JavaScript specs.\n    if (typeof value === 'number' && (value | 0) === value) {\n      return false;\n    }\n\n    return {\n      message: `Expected Integer, got ${stringForErrorMessage(value)}`,\n      path: '',\n    };\n  }\n\n  // 'Object' is shorthand for Match.ObjectIncluding({});\n  if (pattern === Object) {\n    pattern = Match.ObjectIncluding({});\n  }\n\n  // Array (checked AFTER Any, which is implemented as an Array).\n  if (pattern instanceof Array) {\n    if (pattern.length !== 1) {\n      return {\n        message: `Bad pattern: arrays must have one type element ${stringForErrorMessage(pattern)}`,\n        path: '',\n      };\n    }\n\n    if (!Array.isArray(value) && !isArguments(value)) {\n      return {\n        message: `Expected array, got ${stringForErrorMessage(value)}`,\n        path: '',\n      };\n    }\n\n\n    for (let i = 0, length = value.length; i < length; i++) {\n      const arrPath = `${path}[${i}]`\n      const result = testSubtree(value[i], pattern[0], collectErrors, errors, arrPath);\n      if (result) {\n        result.path = _prependPath(collectErrors ? arrPath : i, result.path)\n        if (!collectErrors) return result;\n        if (typeof value[i] !== 'object' || result.message) errors.push(result)\n      }\n    }\n\n    if (!collectErrors) return false;\n    return errors.length === 0 ? false : errors;\n  }\n\n  // Arbitrary validation checks. The condition can return false or throw a\n  // Match.Error (ie, it can internally use check()) to fail.\n  if (pattern instanceof Where) {\n    let result;\n    try {\n      result = pattern.condition(value);\n    } catch (err) {\n      if (!(err instanceof Match.Error)) {\n        throw err;\n      }\n\n      return {\n        message: err.message,\n        path: err.path\n      };\n    }\n\n    if (result) {\n      return false;\n    }\n\n    // XXX this error is terrible\n\n    return {\n      message: 'Failed Match.Where validation',\n      path: '',\n    };\n  }\n\n  if (pattern instanceof Maybe) {\n    pattern = Match.OneOf(undefined, null, pattern.pattern);\n  } else if (pattern instanceof Optional) {\n    pattern = Match.OneOf(undefined, pattern.pattern);\n  }\n\n  if (pattern instanceof OneOf) {\n    for (let i = 0; i < pattern.choices.length; ++i) {\n      const result = testSubtree(value, pattern.choices[i]);\n      if (!result) {\n\n        // No error? Yay, return.\n        return false;\n      }\n\n      // Match errors just mean try another choice.\n    }\n\n    // XXX this error is terrible\n    return {\n      message: 'Failed Match.OneOf, Match.Maybe or Match.Optional validation',\n      path: '',\n    };\n  }\n\n  // A function that isn't something we special-case is assumed to be a\n  // constructor.\n  if (pattern instanceof Function) {\n    if (value instanceof pattern) {\n      return false;\n    }\n\n    return {\n      message: `Expected ${pattern.name || 'particular constructor'}`,\n      path: '',\n    };\n  }\n\n  let unknownKeysAllowed = false;\n  let unknownKeyPattern;\n  if (pattern instanceof ObjectIncluding) {\n    unknownKeysAllowed = true;\n    pattern = pattern.pattern;\n  }\n\n  if (pattern instanceof ObjectWithValues) {\n    unknownKeysAllowed = true;\n    unknownKeyPattern = [pattern.pattern];\n    pattern = {};  // no required keys\n  }\n\n  if (typeof pattern !== 'object') {\n    return {\n      message: 'Bad pattern: unknown pattern type',\n      path: '',\n    };\n  }\n\n  // An object, with required and optional keys. Note that this does NOT do\n  // structural matches against objects of special types that happen to match\n  // the pattern: this really needs to be a plain old {Object}!\n  if (typeof value !== 'object') {\n    return {\n      message: `Expected object, got ${typeof value}`,\n      path: '',\n    };\n  }\n\n  if (value === null) {\n    return {\n      message: `Expected object, got null`,\n      path: '',\n    };\n  }\n\n  if (! isPlainObject(value)) {\n    return {\n      message: `Expected plain object`,\n      path: '',\n    };\n  }\n\n  const requiredPatterns = Object.create(null);\n  const optionalPatterns = Object.create(null);\n\n  Object.keys(pattern).forEach(key => {\n    const subPattern = pattern[key];\n    if (subPattern instanceof Optional ||\n        subPattern instanceof Maybe) {\n      optionalPatterns[key] = subPattern.pattern;\n    } else {\n      requiredPatterns[key] = subPattern;\n    }\n  });\n\n  for (let key in Object(value)) {\n    const subValue = value[key];\n    const objPath = path ? `${path}.${key}` : key;\n    if (hasOwn.call(requiredPatterns, key)) {\n      const result = testSubtree(subValue, requiredPatterns[key], collectErrors, errors, objPath);\n      if (result) {\n        result.path = _prependPath(collectErrors ? objPath : key, result.path)\n        if (!collectErrors) return result;\n        if (typeof subValue !== 'object' || result.message) errors.push(result);\n      }\n\n      delete requiredPatterns[key];\n    } else if (hasOwn.call(optionalPatterns, key)) {\n      const result = testSubtree(subValue, optionalPatterns[key], collectErrors, errors, objPath);\n      if (result) {\n        result.path = _prependPath(collectErrors ? objPath : key, result.path)\n        if (!collectErrors) return result;\n        if (typeof subValue !== 'object' || result.message) errors.push(result);\n      }\n\n    } else {\n      if (!unknownKeysAllowed) {\n        const result = {\n          message: 'Unknown key',\n          path: key,\n        };\n        if (!collectErrors) return result;\n        errors.push(result);\n      }\n\n      if (unknownKeyPattern) {\n        const result = testSubtree(subValue, unknownKeyPattern[0], collectErrors, errors, objPath);\n        if (result) {\n          result.path = _prependPath(collectErrors ? objPath : key, result.path)\n          if (!collectErrors) return result;\n          if (typeof subValue !== 'object' || result.message) errors.push(result);\n        }\n      }\n    }\n  }\n\n  const keys = Object.keys(requiredPatterns);\n  if (keys.length) {\n    const createMissingError = key => ({\n      message: `Missing key '${key}'`,\n      path: collectErrors ? path : '',\n    });\n\n    if (!collectErrors) {\n      return createMissingError(keys[0]);\n    }\n\n    for (const key of keys) {\n      errors.push(createMissingError(key));\n    }\n  }\n\n  if (!collectErrors) return false;\n  return errors.length === 0 ? false : errors;\n};\n\nclass ArgumentChecker {\n  constructor (args, description) {\n\n    // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n    // against its contents.)\n    this.args = [...args];\n\n    // Since the common case will be to check arguments in order, and we splice\n    // out arguments when we check them, make it so we splice out from the end\n    // rather than the beginning.\n    this.args.reverse();\n    this.description = description;\n  }\n\n  checking(value) {\n    if (this._checkingOneValue(value)) {\n      return;\n    }\n\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n    // or check([foo, bar], [String]) to count... but only if value wasn't\n    // itself an argument.\n    if (Array.isArray(value) || isArguments(value)) {\n      Array.prototype.forEach.call(value, this._checkingOneValue.bind(this));\n    }\n  }\n\n  _checkingOneValue(value) {\n    for (let i = 0; i < this.args.length; ++i) {\n\n      // Is this value one of the arguments? (This can have a false positive if\n      // the argument is an interned primitive, but it's still a good enough\n      // check.)\n      // (NaN is not === to itself, so we have to check specially.)\n      if (value === this.args[i] ||\n          (Number.isNaN(value) && Number.isNaN(this.args[i]))) {\n        this.args.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  throwUnlessAllArgumentsHaveBeenChecked() {\n    if (this.args.length > 0)\n      throw new Error(`Did not check() all arguments during ${this.description}`);\n  }\n}\n\nconst _jsKeywords = ['do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case',\n  'else', 'enum', 'eval', 'false', 'null', 'this', 'true', 'void', 'with',\n  'break', 'catch', 'class', 'const', 'super', 'throw', 'while', 'yield',\n  'delete', 'export', 'import', 'public', 'return', 'static', 'switch',\n  'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue',\n  'debugger', 'function', 'arguments', 'interface', 'protected', 'implements',\n  'instanceof'];\n\n// Assumes the base of path is already escaped properly\n// returns key + base\nconst _prependPath = (key, base) => {\n  if ((typeof key) === 'number' || key.match(/^[0-9]+$/)) {\n    key = `[${key}]`;\n  } else if (!key.match(/^[a-z_$][0-9a-z_$.[\\]]*$/i) ||\n             _jsKeywords.indexOf(key) >= 0) {\n    key = JSON.stringify([key]);\n  }\n\n  if (base && base[0] !== '[') {\n    return `${key}.${base}`;\n  }\n\n  return key + base;\n}\n\nconst isObject = value => typeof value === 'object' && value !== null;\n\nconst baseIsArguments = item =>\n  isObject(item) &&\n  Object.prototype.toString.call(item) === '[object Arguments]';\n\nconst isArguments = baseIsArguments(function() { return arguments; }()) ?\n  baseIsArguments :\n  value => isObject(value) && typeof value.callee === 'function';\n","// Copy of jQuery.isPlainObject for the server side from jQuery v3.1.1.\n\nconst class2type = {};\n\nconst toString = class2type.toString;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nconst fnToString = hasOwn.toString;\n\nconst ObjectFunctionString = fnToString.call(Object);\n\nconst getProto = Object.getPrototypeOf;\n\nexport const isPlainObject = obj => {\n  let proto;\n  let Ctor;\n\n  // Detect obvious negatives\n  // Use toString instead of jQuery.type to catch host objects\n  if (!obj || toString.call(obj) !== '[object Object]') {\n    return false;\n  }\n\n  proto = getProto(obj);\n\n  // Objects with no prototype (e.g., `Object.create( null )`) are plain\n  if (!proto) {\n    return true;\n  }\n\n  // Objects with prototype are plain iff they were constructed by a global Object function\n  Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor === 'function' && \n    fnToString.call(Ctor) === ObjectFunctionString;\n};\n"]}