{"version":3,"sources":["meteor://ðŸ’»app/packages/mongo/mongo_driver.js","meteor://ðŸ’»app/packages/mongo/oplog_tailing.ts","meteor://ðŸ’»app/packages/mongo/observe_multiplex.ts","meteor://ðŸ’»app/packages/mongo/doc_fetcher.js","meteor://ðŸ’»app/packages/mongo/polling_observe_driver.ts","meteor://ðŸ’»app/packages/mongo/oplog_observe_driver.js","meteor://ðŸ’»app/packages/mongo/oplog_v2_converter.ts","meteor://ðŸ’»app/packages/mongo/cursor_description.ts","meteor://ðŸ’»app/packages/mongo/mongo_connection.js","meteor://ðŸ’»app/packages/mongo/mongo_common.js","meteor://ðŸ’»app/packages/mongo/asynchronous_cursor.js","meteor://ðŸ’»app/packages/mongo/cursor.ts","meteor://ðŸ’»app/packages/mongo/local_collection_driver.js","meteor://ðŸ’»app/packages/mongo/remote_collection_driver.ts","meteor://ðŸ’»app/packages/mongo/collection/collection.js","meteor://ðŸ’»app/packages/mongo/collection/collection_utils.js","meteor://ðŸ’»app/packages/mongo/collection/methods_async.js","meteor://ðŸ’»app/packages/mongo/collection/methods_index.js","meteor://ðŸ’»app/packages/mongo/collection/methods_replication.js","meteor://ðŸ’»app/packages/mongo/collection/methods_sync.js","meteor://ðŸ’»app/packages/mongo/connection_options.ts","meteor://ðŸ’»app/packages/mongo/mongo_utils.js","meteor://ðŸ’»app/packages/mongo/observe_handle.ts"],"names":["MongoInternals","global","__packageName","NpmModules","mongodb","version","NpmModuleMongodbVersion","module","MongoDB","NpmModule","Proxy","get","target","propertyKey","receiver","Meteor","deprecate","Reflect","OplogHandle","Connection","MongoConnection","OplogObserveDriver","Timestamp","prototype","clone","listenAll","cursorDescription","listenCallback","listeners","forEachTrigger","trigger","push","DDPServer","_InvalidationCrossbar","listen","stop","forEach","listener","triggerCallback","key","collection","collectionName","specificIds","LocalCollection","_idsMatchedBySelector","selector","id","Object","assign","dropCollection","dropDatabase","MongoTimestamp","Long","NpmModuleMongodb","OPLOG_COLLECTION","TOO_FAR_BEHIND","process","env","METEOR_OPLOG_TOO_FAR_BEHIND","TAIL_TIMEOUT","METEOR_OPLOG_TAIL_TIMEOUT","_getOplogSelector","lastProcessedTS","oplogCriteria","$or","op","$in","$exists","nsRegex","RegExp","_escapeRegExp","_dbName","join","_oplogOptions","excludeCollections","length","ns","$regex","$nin","map","collName","includeCollections","ts","$gt","$and","_stopped","_tailHandle","_onOplogEntry","callback","Error","_readyPromise","originalCallback","bindEnvironment","notification","err","_debug","listenHandle","_crossbar","onOplogEntry","onSkippedEntries","_onSkippedEntriesHook","register","_waitUntilCaughtUp","lastEntry","oplogSelector","_oplogLastEntryConnection","findOneAsync","projection","sort","$natural","e","sleep","JSON","stringify","_lastProcessedTS","lessThanOrEqual","insertAfter","_catchingUpResolvers","greaterThan","promiseResolver","promiseToAwait","Promise","r","clearTimeout","_resolveTimeout","setTimeout","console","error","splice","resolver","waitUntilCaughtUp","_startTailing","mongodbUri","require","parse","_oplogUrl","database","_oplogTailConnection","maxPoolSize","minPoolSize","isMasterDoc","db","admin","command","ismaster","setName","lastOplogEntry","CursorDescription","tailable","tail","doc","_entryQueue","_maybeStartWorker","_readyPromiseResolver","_workerPromise","_workerActive","isEmpty","pop","clear","each","_setLastProcessedTS","shift","handleDoc","sequencer","_defineTooFarBehind","value","_resetTooFarBehind","oplogUrl","dbName","_startTrailingPromise","_DoubleEndedQueue","_Crossbar","factPackage","factName","settings","packages","mongo","oplogIncludeCollections","oplogExcludeCollections","Hook","debugPrintExceptions","idForOp","o","_id","o2","handle","applyOps","nextTimestamp","add","ONE","startsWith","slice","drop","fire","resolve","setImmediate","ObserveMultiplexer","addHandleAndSendInitialAdds","_addHandleAndSendInitialAdds","_addHandleTasksScheduledButNotPerformed","Package","Facts","incrementServerFact","_queue","runTask","_handles","_sendAdds","removeHandle","_ready","_stop","options","fromQueryError","_onStop","ready","queueTask","_resolver","_isReady","queryError","onFlush","cb","callbackNames","_ordered","_applyCallback","callbackName","args","_cache","applyChange","apply","handleId","keys","result","nonMutatingCallbacks","EJSON","_isPromise","catch","initialAddsSent","then","_addedBefore","_added","addPromises","docs","fields","promise","reject","allSettled","p","status","reason","initialAddsSentResolver","ordered","onStop","undefined","_AsynchronousQueue","_CachingChangeObserver","DocFetcher","fetch","self","check","String","_callbacksForOp","has","callbacks","set","_mongoConnection","delete","mongoConnection","Map","POLLING_THROTTLE_MS","METEOR_POLLING_THROTTLE_MS","POLLING_INTERVAL_MS","METEOR_POLLING_INTERVAL_MS","PollingObserveDriver","_init","_options","listenersHandle","_cursorDescription","fence","_getCurrentFence","_pendingWrites","beginWrite","_pollsScheduledButNotStarted","_ensurePollIsScheduled","_stopCallbacks","_testOnlyPollCallback","pollingInterval","pollingIntervalMs","_pollingInterval","intervalHandle","setInterval","bind","clearInterval","_unthrottledEnsurePollIsScheduled","_taskQueue","_pollMongo","_suspendPolling","_resumePolling","first","newResults","oldResults","_results","_IdMap","writesForCycle","_cursor","getRawObjects","code","_multiplexer","message","Array","_diffQueryChanges","w","committed","_mongoHandle","mongoHandle","multiplexer","_createAsynchronousCursor","throttle","pollingThrottleMs","PHASE","QUERYING","FETCHING","STEADY","SwitchedToQuery","finishIfNeedToPollQuery","f","arguments","currentId","_usesOplog","sorter","comparator","getComparator","limit","heapOptions","IdMap","_limit","_comparator","_sorter","_unpublishedBuffer","MinMaxHeap","_published","MaxHeap","_safeAppendToBuffer","_stopHandles","_addStopHandles","newStopHandles","expectedPattern","Match","ObjectIncluding","Function","OneOf","_registerPhaseChange","_matcher","matcher","_projectionFn","_compileProjection","_sharedProjection","combineIntoProjection","_sharedProjectionFn","_needToFetch","_currentlyFetching","_fetchGeneration","_requeryWhenDoneThisQuery","_writesToCommitWhenWeReachSteady","_oplogHandle","_needToPollQuery","_phase","_handleOplogEntryQuerying","_handleOplogEntrySteadyOrFetching","fired","_oplogObserveDrivers","onBeforeFire","drivers","driver","values","write","_onFailover","_runInitialQuery","_addPublished","_noYieldsAllowed","added","size","overflowingDocId","maxElementId","overflowingDoc","equals","remove","removed","_addBuffered","_removePublished","empty","newDocId","minElementId","newDoc","_removeBuffered","_changePublished","oldDoc","projectedNew","projectedOld","changed","DiffSequence","makeChangedFields","maxBufferedId","_addMatching","maxPublished","maxBuffered","toPublish","canAppendToBuffer","canInsertIntoBuffer","toBuffer","_removeMatching","_handleDoc","matchesNow","documentMatches","publishedBefore","bufferedBefore","cachedBefore","minBuffered","staysInPublished","staysInBuffer","_fetchModifiedDocuments","defer","thisGeneration","fetchPromises","fetchPromise","_docFetcher","results","errors","filter","_beSteady","writes","oplogV2V1Converter","isReplace","canDirectlyModifyDoc","modifierCanBeDirectlyApplied","_modify","name","canBecomeTrueByModifier","affectedByModifier","_runInitialQueryAsync","_runQuery","initial","_doneQuerying","_pollQuery","_runQueryAsync","newBuffer","cursor","_cursorForQuery","i","_sleepForMs","_publishNewResults","optionsOverwrite","transform","description","Cursor","idsToRemove","_oplogEntryHandle","_listenersHandle","phase","now","Date","timeDiff","_phaseStartTime","cursorSupported","disableOplog","_disableOplog","skip","_checkSupportedProjection","hasWhere","hasGeoQuery","modifier","entries","every","operation","field","test","arrayOperatorKeyRegex","isArrayOperatorKey","isArrayOperator","operator","a","prefix","flattenObjectInto","source","isArray","Mongo","ObjectID","_isCustomType","convertOplogDiff","oplogEntry","diff","diffKey","$unset","$set","fieldValue","position","positionKey","$v","convertedOplogEntry","Collection","_rewriteSelector","FILE_ASSET_SUFFIX","ASSETS_FOLDER","APP_FOLDER","oplogCollectionWarnings","url","_observeMultiplexers","_onFailoverHook","userOptions","_connectionOptions","mongoOptions","ignoreUndefined","endsWith","optionName","replace","path","Assets","getServerDir","driverInfo","release","client","MongoClient","on","event","previousDescription","type","newDescription","databaseName","_close","oplogHandle","close","_setOplogHandle","rawCollection","createCappedCollectionAsync","byteSize","maxDocuments","createCollection","capped","max","_maybeBeginWrite","insertAsync","collection_name","document","_expectedByTest","_isPlainObject","refresh","insertOne","replaceTypes","replaceMeteorAtomWithMongo","safe","insertedId","_refresh","refreshKey","removeAsync","deleteMany","deletedCount","transformResult","modifiedCount","numberAffected","dropCollectionAsync","dropDatabaseAsync","_dropDatabase","updateAsync","mod","mongoOpts","arrayFilters","upsert","multi","fullResult","mongoSelector","mongoMod","isModify","_isModificationMod","_forbidReplace","knownId","_createUpsertDocument","generatedId","simulateUpsertWithInsertedId","_returnObject","hasOwnProperty","$setOnInsert","strings","updateMethod","meteorResult","ObjectId","toHexString","_isCannotChangeIdError","errmsg","indexOf","upsertAsync","find","createIndexAsync","index","createIndex","countDocuments","arg","estimatedDocumentCount","ensureIndexAsync","dropIndexAsync","indexName","dropIndex","CLIENT_ONLY_METHODS","m","getAsyncMethodName","NUM_OPTIMISTIC_TRIES","mongoOptsForUpdate","mongoOptsForInsert","replacementWithId","tries","doUpdate","method","updateMany","some","replaceOne","upsertedCount","upsertedId","doConditionalInsert","_observeChangesTailable","addedBefore","selfForIteration","useTransform","cursorOptions","readPreference","numberOfRetries","dbCursor","addCursorFlag","maxTimeMs","maxTimeMS","hint","AsynchronousCursor","docCallback","timeoutMS","stopped","lastTS","loop","_nextObjectPromiseWithTimeout","newSelector","_observeChanges","fieldsOptions","observeKey","observeDriver","firstHandle","observeHandle","ObserveHandle","oplogOptions","canUseOplog","includes","warn","Minimongo","Matcher","isClient","MiniMongoQueryError","Sorter","driverClass","_observeDriver","writeCallback","refreshErr","driverResult","mongoResult","n","matchedCount","isBinary","Binary","Buffer","from","Decimal","Decimal128","fromString","toString","replaceNames","makeMongoLegal","toJSONValue","atomTransformer","replacedTopLevelAtom","ret","val","valReplaced","replaceMongoAtomWithMeteor","sub_type","buffer","Uint8Array","fromJSONValue","unmakeMongoLegal","substr","thing","Symbol","asyncIterator","next","_nextObjectPromise","done","_rawNextObjectPromise","_closing","_pendingNext","_dbCursor","_visitedIds","_transform","nextObjectPromise","timeoutPromise","timeoutId","finally","race","thisArg","_rewind","idx","call","_selfForIteration","rewind","count","wrapTransform","countAsync","_mongo","getTransform","_publishCursor","sub","_getCollectionName","observe","_observeFromObserveChanges","observeAsync","observeChanges","_observeChangesCallbacksAreOrdered","observeChangesAsync","_synchronousCursor","ASYNC_CURSOR_METHODS","iterator","methodName","setupAsynchronousCursor","methodNameAsync","LocalCollectionDriver","open","conn","ensureCollection","noConnCollections","_mongo_livedata_collections","create","collections","RemoteCollectionDriver","REMOTE_COLLECTION_METHODS","mongoMethod","ASYNC_COLLECTION_METHODS","asyncMethodName","mongoUrl","defaultRemoteCollectionDriver","once","connectionOptions","MONGO_URL","MONGO_OPLOG_URL","startup","connect","ID_GENERATORS","validateCollectionName","normalizeOptions","_makeNewID","idGeneration","resolverType","_connection","setupConnection","setupDriver","_driver","_collection","_name","_settingUpReplicationPromise","_maybeSetUpReplication","setupMutationMethods","setupAutopublish","_collections","_getFindSelector","_getFindOptions","newOptions","normalizeProjection","Optional","Number","fallbackId","_selectorIsId","Random","ReplicationMethods","SyncMethods","AsyncMethods","IndexMethods","_isRemoteCollection","server","rawDatabase","getCollection","MongoID","AllowDeny","CollectionPrototype","MONGO","src","DDP","randomStream","insecure","hexString","STRING","connection","autopublish","_preventAutopublish","publish","is_auto","defineMutationMethods","_defineMutationMethods","useExisting","_suppressSameNameError","methods","manager","cleanedOptions","fromEntries","_","v","_insertAsync","getPrototypeOf","getOwnPropertyDescriptors","generateId","enclosing","_CurrentMethodInvocation","chooseReturnValueFromCollectionResult","_callMutatorMethodAsync","stubPromise","serverPromise","optionsAndCallback","Log","debug","reCreateIndexOnOptionMismatch","info","registerStoreResult","registerStoreClient","registerStoreServer","wrappedStoreCommon","saveOriginals","retrieveOriginals","_getCollection","wrappedStoreClient","beginUpdate","batchSize","reset","pauseObservers","update","msg","mongoId","idParse","_docs","_ref","insert","endUpdate","resumeObserversClient","getDoc","findOne","wrappedStoreServer","resumeObserversServer","logWarn","log","ok","_insert","wrappedCallback","wrapCallback","_callMutatorMethod","popCallbackFromArgs","convertResult","setConnectionOptions","otherOptions","nextObserveHandleId","_changed","_movedBefore","_removed","before","timeout"],"mappings":"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","file":"/packages/mongo.js","sourcesContent":["import { OplogHandle } from './oplog_tailing';\nimport { MongoConnection } from './mongo_connection';\nimport { OplogObserveDriver } from './oplog_observe_driver';\nimport { MongoDB } from './mongo_common';\n\nMongoInternals = global.MongoInternals = {};\n\nMongoInternals.__packageName = 'mongo';\n\nMongoInternals.NpmModules = {\n  mongodb: {\n    version: NpmModuleMongodbVersion,\n    module: MongoDB\n  }\n};\n\n// Older version of what is now available via\n// MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n// people do use it.\n// XXX COMPAT WITH 1.0.3.2\nMongoInternals.NpmModule = new Proxy(MongoDB, {\n  get(target, propertyKey, receiver) {\n    if (propertyKey === 'ObjectID') {\n      Meteor.deprecate(\n        `Accessing 'MongoInternals.NpmModule.ObjectID' directly is deprecated. ` +\n        `Use 'MongoInternals.NpmModule.ObjectId' instead.`\n      );\n    }\n    return Reflect.get(target, propertyKey, receiver);\n  },\n});\n\nMongoInternals.OplogHandle = OplogHandle;\n\nMongoInternals.Connection = MongoConnection;\n\nMongoInternals.OplogObserveDriver = OplogObserveDriver;\n\n// This is used to add or remove EJSON from the beginning of everything nested\n// inside an EJSON custom type. It should only be called on pure JSON!\n\n\n// Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n// doing a structural clone).\n// XXX how ok is this? what if there are multiple copies of MongoDB loaded?\nMongoDB.Timestamp.prototype.clone = function () {\n  // Timestamps should be immutable.\n  return this;\n};\n\n// Listen for the invalidation messages that will trigger us to poll the\n// database for changes. If this selector specifies specific IDs, specify them\n// here, so that updates to different specific IDs don't cause us to poll.\n// listenCallback is the same kind of (notification, complete) callback passed\n// to InvalidationCrossbar.listen.\n\nexport const listenAll = async function (cursorDescription, listenCallback) {\n  const listeners = [];\n  await forEachTrigger(cursorDescription, function (trigger) {\n    listeners.push(DDPServer._InvalidationCrossbar.listen(\n      trigger, listenCallback));\n  });\n\n  return {\n    stop: function () {\n      listeners.forEach(function (listener) {\n        listener.stop();\n      });\n    }\n  };\n};\n\nexport const forEachTrigger = async function (cursorDescription, triggerCallback) {\n  const key = {collection: cursorDescription.collectionName};\n  const specificIds = LocalCollection._idsMatchedBySelector(\n    cursorDescription.selector);\n  if (specificIds) {\n    for (const id of specificIds) {\n      await triggerCallback(Object.assign({id: id}, key));\n    }\n    await triggerCallback(Object.assign({dropCollection: true, id: null}, key));\n  } else {\n    await triggerCallback(key);\n  }\n  // Everyone cares about the database being dropped.\n  await triggerCallback({ dropDatabase: true });\n};\n\n\n\n// XXX We probably need to find a better way to expose this. Right now\n// it's only used by tests, but in fact you need it in normal\n// operation to interact with capped collections.\nMongoInternals.MongoTimestamp = MongoDB.Timestamp;\n","import isEmpty from 'lodash.isempty';\nimport { Meteor } from 'meteor/meteor';\nimport { CursorDescription } from './cursor_description';\nimport { MongoConnection } from './mongo_connection';\n\nimport { NpmModuleMongodb } from \"meteor/npm-mongo\";\nconst { Long } = NpmModuleMongodb;\n\nexport const OPLOG_COLLECTION = 'oplog.rs';\n\nlet TOO_FAR_BEHIND = +(process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000);\nconst TAIL_TIMEOUT = +(process.env.METEOR_OPLOG_TAIL_TIMEOUT || 30000);\n\nexport interface OplogEntry {\n  op: string;\n  o: any;\n  o2?: any;\n  ts: any;\n  ns: string;\n}\n\nexport interface CatchingUpResolver {\n  ts: any;\n  resolver: () => void;\n}\n\nexport interface OplogTrigger {\n  dropCollection: boolean;\n  dropDatabase: boolean;\n  op: OplogEntry;\n  collection?: string;\n  id?: string | null;\n}\n\nexport class OplogHandle {\n  private _oplogUrl: string;\n  public _dbName: string;\n  private _oplogLastEntryConnection: MongoConnection | null;\n  private _oplogTailConnection: MongoConnection | null;\n  private _oplogOptions: {\n    excludeCollections?: string[];\n    includeCollections?: string[];\n  };\n  private _stopped: boolean;\n  private _tailHandle: any;\n  private _readyPromiseResolver: (() => void) | null;\n  private _readyPromise: Promise<void>;\n  public _crossbar: any;\n  private _catchingUpResolvers: CatchingUpResolver[];\n  private _lastProcessedTS: any;\n  private _onSkippedEntriesHook: any;\n  private _startTrailingPromise: Promise<void>;\n  private _resolveTimeout: any;\n\n  private _entryQueue = new Meteor._DoubleEndedQueue();\n  private _workerActive = false;\n  private _workerPromise: Promise<void> | null = null;\n\n  constructor(oplogUrl: string, dbName: string) {\n    this._oplogUrl = oplogUrl;\n    this._dbName = dbName;\n\n    this._resolveTimeout = null;\n    this._oplogLastEntryConnection = null;\n    this._oplogTailConnection = null;\n    this._stopped = false;\n    this._tailHandle = null;\n    this._readyPromiseResolver = null;\n    this._readyPromise = new Promise(r => this._readyPromiseResolver = r); \n    this._crossbar = new DDPServer._Crossbar({\n      factPackage: \"mongo-livedata\", factName: \"oplog-watchers\"\n    });\n\n    const includeCollections =\n      Meteor.settings?.packages?.mongo?.oplogIncludeCollections;\n    const excludeCollections =\n      Meteor.settings?.packages?.mongo?.oplogExcludeCollections;\n    if (includeCollections?.length && excludeCollections?.length) {\n      throw new Error(\n        \"Can't use both mongo oplog settings oplogIncludeCollections and oplogExcludeCollections at the same time.\"\n      );\n    }\n    this._oplogOptions = { includeCollections, excludeCollections };\n\n    this._catchingUpResolvers = [];\n    this._lastProcessedTS = null;\n\n    this._onSkippedEntriesHook = new Hook({\n      debugPrintExceptions: \"onSkippedEntries callback\"\n    });\n\n    this._startTrailingPromise = this._startTailing();\n  }\n\n  private _getOplogSelector(lastProcessedTS?: any): any {\n    const oplogCriteria: any = [\n      {\n        $or: [\n          { op: { $in: [\"i\", \"u\", \"d\"] } },\n          { op: \"c\", \"o.drop\": { $exists: true } },\n          { op: \"c\", \"o.dropDatabase\": 1 },\n          { op: \"c\", \"o.applyOps\": { $exists: true } },\n        ],\n      },\n    ];\n\n    const nsRegex = new RegExp(\n      \"^(?:\" +\n        [\n          // @ts-ignore\n          Meteor._escapeRegExp(this._dbName + \".\"),\n          // @ts-ignore\n          Meteor._escapeRegExp(\"admin.$cmd\"),\n        ].join(\"|\") +\n        \")\"\n    );\n\n    if (this._oplogOptions.excludeCollections?.length) {\n      oplogCriteria.push({\n        ns: {\n          $regex: nsRegex,\n          $nin: this._oplogOptions.excludeCollections.map(\n            (collName: string) => `${this._dbName}.${collName}`\n          ),\n        },\n      });\n    } else if (this._oplogOptions.includeCollections?.length) {\n      oplogCriteria.push({\n        $or: [\n          { ns: /^admin\\.\\$cmd/ },\n          {\n            ns: {\n              $in: this._oplogOptions.includeCollections.map(\n                (collName: string) => `${this._dbName}.${collName}`\n              ),\n            },\n          },\n        ],\n      });\n    } else {\n      oplogCriteria.push({\n        ns: nsRegex,\n      });\n    }\n    if(lastProcessedTS) {\n      oplogCriteria.push({\n        ts: { $gt: lastProcessedTS },\n      });\n    }\n\n    return {\n      $and: oplogCriteria,\n    };\n  }\n\n  async stop(): Promise<void> {\n    if (this._stopped) return;\n    this._stopped = true;\n    if (this._tailHandle) {\n      await this._tailHandle.stop();\n    }\n  }\n\n  async _onOplogEntry(trigger: OplogTrigger, callback: Function): Promise<{ stop: () => Promise<void> }> {\n    if (this._stopped) {\n      throw new Error(\"Called onOplogEntry on stopped handle!\");\n    }\n\n    await this._readyPromise;\n\n    const originalCallback = callback;\n\n    /**\n     * This depends on AsynchronousQueue tasks being wrapped in `bindEnvironment` too.\n     *\n     * @todo Check after we simplify the `bindEnvironment` implementation if we can remove the second wrap.\n     */\n    callback = Meteor.bindEnvironment(\n      function (notification: any) {\n        originalCallback(notification);\n      },\n      // @ts-ignore\n      function (err) {\n        Meteor._debug(\"Error in oplog callback\", err);\n      }\n    );\n\n    const listenHandle = this._crossbar.listen(trigger, callback);\n    return {\n      stop: async function () {\n        await listenHandle.stop();\n      }\n    };\n  }\n\n  onOplogEntry(trigger: OplogTrigger, callback: Function): Promise<{ stop: () => Promise<void> }> {\n    return this._onOplogEntry(trigger, callback);\n  }\n\n  onSkippedEntries(callback: Function): { stop: () => void } {\n    if (this._stopped) {\n      throw new Error(\"Called onSkippedEntries on stopped handle!\");\n    }\n    return this._onSkippedEntriesHook.register(callback);\n  }\n\n  async _waitUntilCaughtUp(): Promise<void> {\n    if (this._stopped) {\n      throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n    }\n\n    await this._readyPromise;\n\n    let lastEntry: OplogEntry | null = null;\n\n    while (!this._stopped) {\n      const oplogSelector = this._getOplogSelector();\n      try {\n        lastEntry = await this._oplogLastEntryConnection.findOneAsync(\n          OPLOG_COLLECTION,\n          oplogSelector,\n          { projection: { ts: 1 }, sort: { $natural: -1 } }\n        );\n        break;\n      } catch (e) {\n        Meteor._debug(\"Got exception while reading last entry\", e);\n        // @ts-ignore\n        await Meteor.sleep(100);\n      }\n    }\n\n    if (this._stopped) return;\n\n    if (!lastEntry) return;\n\n    const ts = lastEntry.ts;\n    if (!ts) {\n      throw Error(\"oplog entry without ts: \" + JSON.stringify(lastEntry));\n    }\n\n    if (this._lastProcessedTS && ts.lessThanOrEqual(this._lastProcessedTS)) {\n      return;\n    }\n\n    let insertAfter = this._catchingUpResolvers.length;\n\n    while (insertAfter - 1 > 0 && this._catchingUpResolvers[insertAfter - 1].ts.greaterThan(ts)) {\n      insertAfter--;\n    }\n\n    let promiseResolver = null;\n\n    const promiseToAwait = new Promise(r => promiseResolver = r);\n\n    clearTimeout(this._resolveTimeout);\n\n    this._resolveTimeout = setTimeout(() => {\n      console.error(\"Meteor: oplog catching up took too long\", { ts });\n    }, 10000);\n\n    this._catchingUpResolvers.splice(insertAfter, 0, { ts, resolver: promiseResolver! });\n\n    await promiseToAwait;\n\n    clearTimeout(this._resolveTimeout);\n  }\n\n  async waitUntilCaughtUp(): Promise<void> {\n    return this._waitUntilCaughtUp();\n  }\n\n  async _startTailing(): Promise<void> {\n    const mongodbUri = require('mongodb-uri');\n    if (mongodbUri.parse(this._oplogUrl).database !== 'local') {\n      throw new Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of a Mongo replica set\");\n    }\n\n    this._oplogTailConnection = new MongoConnection(\n      this._oplogUrl, { maxPoolSize: 1, minPoolSize: 1 }\n    );\n    this._oplogLastEntryConnection = new MongoConnection(\n      this._oplogUrl, { maxPoolSize: 1, minPoolSize: 1 }\n    );\n\n    try {\n      const isMasterDoc = await this._oplogLastEntryConnection!.db\n        .admin()\n        .command({ ismaster: 1 });\n\n      if (!(isMasterDoc && isMasterDoc.setName)) {\n        throw new Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of a Mongo replica set\");\n      }\n\n      const lastOplogEntry = await this._oplogLastEntryConnection.findOneAsync(\n        OPLOG_COLLECTION,\n        {},\n        { sort: { $natural: -1 }, projection: { ts: 1 } }\n      );\n\n      const oplogSelector = this._getOplogSelector(lastOplogEntry?.ts);\n      if (lastOplogEntry) {\n        this._lastProcessedTS = lastOplogEntry.ts;\n      }\n\n      const cursorDescription = new CursorDescription(\n        OPLOG_COLLECTION,\n        oplogSelector,\n        { tailable: true }\n      );\n\n      this._tailHandle = this._oplogTailConnection.tail(\n        cursorDescription,\n        (doc: any) => {\n          this._entryQueue.push(doc);\n          this._maybeStartWorker();\n        },\n        TAIL_TIMEOUT\n      );\n\n      this._readyPromiseResolver!();\n    } catch (error) {\n      console.error('Error in _startTailing:', error);\n      throw error;\n    }\n  }\n\n  private _maybeStartWorker(): void {\n    if (this._workerPromise) return;\n    this._workerActive = true;\n\n    // Convert to a proper promise-based queue processor\n    this._workerPromise = (async () => {\n      try {\n        while (!this._stopped && !this._entryQueue.isEmpty()) {\n          // Are we too far behind? Just tell our observers that they need to\n          // repoll, and drop our queue.\n          if (this._entryQueue.length > TOO_FAR_BEHIND) {\n            const lastEntry = this._entryQueue.pop();\n            this._entryQueue.clear();\n\n            this._onSkippedEntriesHook.each((callback: Function) => {\n              callback();\n              return true;\n            });\n\n            // Free any waitUntilCaughtUp() calls that were waiting for us to\n            // pass something that we just skipped.\n            this._setLastProcessedTS(lastEntry.ts);\n            continue;\n          }\n\n          // Process next batch from the queue\n          const doc = this._entryQueue.shift();\n\n          try {\n            await handleDoc(this, doc);\n            // Process any waiting fence callbacks\n            if (doc.ts) {\n              this._setLastProcessedTS(doc.ts);\n            }\n          } catch (e) {\n            // Keep processing queue even if one entry fails\n            console.error('Error processing oplog entry:', e);\n          }\n        }\n      } finally {\n        this._workerPromise = null;\n        this._workerActive = false;\n      }\n    })();\n  }\n\n  _setLastProcessedTS(ts: any): void {\n    this._lastProcessedTS = ts;\n    while (!isEmpty(this._catchingUpResolvers) && this._catchingUpResolvers[0].ts.lessThanOrEqual(this._lastProcessedTS)) {\n      const sequencer = this._catchingUpResolvers.shift()!;\n      sequencer.resolver();\n    }\n  }\n\n  _defineTooFarBehind(value: number): void {\n    TOO_FAR_BEHIND = value;\n  }\n\n  _resetTooFarBehind(): void {\n    TOO_FAR_BEHIND = +(process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000);\n  }\n}\n\nexport function idForOp(op: OplogEntry): string {\n  if (op.op === 'd' || op.op === 'i') {\n    return op.o._id;\n  } else if (op.op === 'u') {\n    return op.o2._id;\n  } else if (op.op === 'c') {\n    throw Error(\"Operator 'c' doesn't supply an object with id: \" + JSON.stringify(op));\n  } else {\n    throw Error(\"Unknown op: \" + JSON.stringify(op));\n  }\n}\n\nasync function handleDoc(handle: OplogHandle, doc: OplogEntry): Promise<void> {\n  if (doc.ns === \"admin.$cmd\") {\n    if (doc.o.applyOps) {\n      // This was a successful transaction, so we need to apply the\n      // operations that were involved.\n      let nextTimestamp = doc.ts;\n      for (const op of doc.o.applyOps) {\n        // See https://github.com/meteor/meteor/issues/10420.\n        if (!op.ts) {\n          op.ts = nextTimestamp;\n          nextTimestamp = nextTimestamp.add(Long.ONE);\n        }\n        await handleDoc(handle, op);\n      }\n      return;\n    }\n    throw new Error(\"Unknown command \" + JSON.stringify(doc));\n  }\n\n  const trigger: OplogTrigger = {\n    dropCollection: false,\n    dropDatabase: false,\n    op: doc,\n  };\n\n  if (typeof doc.ns === \"string\" && doc.ns.startsWith(handle._dbName + \".\")) {\n    trigger.collection = doc.ns.slice(handle._dbName.length + 1);\n  }\n\n  // Is it a special command and the collection name is hidden\n  // somewhere in operator?\n  if (trigger.collection === \"$cmd\") {\n    if (doc.o.dropDatabase) {\n      delete trigger.collection;\n      trigger.dropDatabase = true;\n    } else if (\"drop\" in doc.o) {\n      trigger.collection = doc.o.drop;\n      trigger.dropCollection = true;\n      trigger.id = null;\n    } else if (\"create\" in doc.o && \"idIndex\" in doc.o) {\n      // A collection got implicitly created within a transaction. There's\n      // no need to do anything about it.\n    } else {\n      throw Error(\"Unknown command \" + JSON.stringify(doc));\n    }\n  } else {\n    // All other ops have an id.\n    trigger.id = idForOp(doc);\n  }\n\n  await handle._crossbar.fire(trigger);\n\n  await new Promise(resolve => setImmediate(resolve));\n}","import isEmpty from \"lodash.isempty\";\nimport { ObserveHandle } from \"./observe_handle\";\n\ninterface ObserveMultiplexerOptions {\n  ordered: boolean;\n  onStop?: () => void;\n}\n\nexport type ObserveHandleCallback =\n  | \"added\"\n  | \"addedBefore\"\n  | \"changed\"\n  | \"movedBefore\"\n  | \"removed\";\n\n/**\n * Allows multiple identical ObserveHandles to be driven by a single observe driver.\n *\n * This optimization ensures that multiple identical observations\n * don't result in duplicate database queries.\n */\nexport class ObserveMultiplexer {\n  private readonly _ordered: boolean;\n  private readonly _onStop: () => void;\n  private _queue: any;\n  private _handles: { [key: string]: ObserveHandle } | null;\n  private _resolver: ((value?: unknown) => void) | null;\n  private readonly _readyPromise: Promise<boolean | void>;\n  private _isReady: boolean;\n  private _cache: any;\n  private _addHandleTasksScheduledButNotPerformed: number;\n\n  constructor({ ordered, onStop = () => {} }: ObserveMultiplexerOptions) {\n    if (ordered === undefined) throw Error(\"must specify ordered\");\n\n    // @ts-ignore\n    Package[\"facts-base\"] &&\n      Package[\"facts-base\"].Facts.incrementServerFact(\n        \"mongo-livedata\",\n        \"observe-multiplexers\",\n        1\n      );\n\n    this._ordered = ordered;\n    this._onStop = onStop;\n    this._queue = new Meteor._AsynchronousQueue();\n    this._handles = {};\n    this._resolver = null;\n    this._isReady = false;\n    this._readyPromise = new Promise((r) => (this._resolver = r)).then(\n      () => (this._isReady = true)\n    );\n    // @ts-ignore\n    this._cache = new LocalCollection._CachingChangeObserver({ ordered });\n    this._addHandleTasksScheduledButNotPerformed = 0;\n\n    this.callbackNames().forEach((callbackName) => {\n      (this as any)[callbackName] = (...args: any[]) => {\n        this._applyCallback(callbackName, args);\n      };\n    });\n  }\n\n  addHandleAndSendInitialAdds(handle: ObserveHandle): Promise<void> {\n    return this._addHandleAndSendInitialAdds(handle);\n  }\n\n  async _addHandleAndSendInitialAdds(handle: ObserveHandle): Promise<void> {\n    ++this._addHandleTasksScheduledButNotPerformed;\n\n    // @ts-ignore\n    Package[\"facts-base\"] &&\n      Package[\"facts-base\"].Facts.incrementServerFact(\n        \"mongo-livedata\",\n        \"observe-handles\",\n        1\n      );\n\n    await this._queue.runTask(async () => {\n      this._handles![handle._id] = handle;\n      await this._sendAdds(handle);\n      --this._addHandleTasksScheduledButNotPerformed;\n    });\n\n    await this._readyPromise;\n  }\n\n  async removeHandle(id: number): Promise<void> {\n    if (!this._ready())\n      throw new Error(\"Can't remove handles until the multiplex is ready\");\n\n    delete this._handles![id];\n\n    // @ts-ignore\n    Package[\"facts-base\"] &&\n      Package[\"facts-base\"].Facts.incrementServerFact(\n        \"mongo-livedata\",\n        \"observe-handles\",\n        -1\n      );\n\n    if (\n      isEmpty(this._handles) &&\n      this._addHandleTasksScheduledButNotPerformed === 0\n    ) {\n      await this._stop();\n    }\n  }\n\n  async _stop(options: { fromQueryError?: boolean } = {}): Promise<void> {\n    if (!this._ready() && !options.fromQueryError)\n      throw Error(\"surprising _stop: not ready\");\n\n    await this._onStop();\n\n    // @ts-ignore\n    Package[\"facts-base\"] &&\n      Package[\"facts-base\"].Facts.incrementServerFact(\n        \"mongo-livedata\",\n        \"observe-multiplexers\",\n        -1\n      );\n\n    this._handles = null;\n  }\n\n  async ready(): Promise<void> {\n    await this._queue.queueTask(() => {\n      if (this._ready())\n        throw Error(\"can't make ObserveMultiplex ready twice!\");\n\n      if (!this._resolver) {\n        throw new Error(\"Missing resolver\");\n      }\n\n      this._resolver();\n      this._isReady = true;\n    });\n  }\n\n  async queryError(err: Error): Promise<void> {\n    await this._queue.runTask(() => {\n      if (this._ready())\n        throw Error(\"can't claim query has an error after it worked!\");\n      this._stop({ fromQueryError: true });\n      throw err;\n    });\n  }\n\n  async onFlush(cb: () => void): Promise<void> {\n    await this._queue.queueTask(async () => {\n      if (!this._ready())\n        throw Error(\"only call onFlush on a multiplexer that will be ready\");\n      await cb();\n    });\n  }\n\n  callbackNames(): ObserveHandleCallback[] {\n    return this._ordered\n      ? [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"]\n      : [\"added\", \"changed\", \"removed\"];\n  }\n\n  _ready(): boolean {\n    return !!this._isReady;\n  }\n\n  _applyCallback(callbackName: string, args: any[]) {\n    this._queue.queueTask(async () => {\n      if (!this._handles) return;\n\n      await this._cache.applyChange[callbackName].apply(null, args);\n      if (\n        !this._ready() &&\n        callbackName !== \"added\" &&\n        callbackName !== \"addedBefore\"\n      ) {\n        throw new Error(`Got ${callbackName} during initial adds`);\n      }\n\n      for (const handleId of Object.keys(this._handles)) {\n        const handle = this._handles && this._handles[handleId];\n\n        if (!handle) return;\n\n        const callback = (handle as any)[`_${callbackName}`];\n\n        if (!callback) continue;\n\n        const result = callback.apply(\n          null,\n          handle.nonMutatingCallbacks ? args : EJSON.clone(args)\n        );\n\n        if (result && Meteor._isPromise(result)) {\n          result.catch((error) => {\n            console.error(\n              `Error in observeChanges callback ${callbackName}:`,\n              error\n            );\n          });\n        }\n        handle.initialAddsSent.then(result);\n      }\n    });\n  }\n\n  async _sendAdds(handle: ObserveHandle): Promise<void> {\n    const add = this._ordered ? handle._addedBefore : handle._added;\n    if (!add) return;\n\n    const addPromises: (Promise<void> | void)[] = [];\n\n    // note: docs may be an _IdMap or an OrderedDict\n    this._cache.docs.forEach((doc: any, id: string) => {\n      if (!(handle._id in this._handles!)) {\n        throw Error(\"handle got removed before sending initial adds!\");\n      }\n\n      const { _id, ...fields } = handle.nonMutatingCallbacks\n        ? doc\n        : EJSON.clone(doc);\n\n      const promise = new Promise<void>((resolve, reject) => {\n        try {\n          const r = this._ordered ? add(id, fields, null) : add(id, fields);\n          resolve(r);\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      addPromises.push(promise);\n    });\n\n    await Promise.allSettled(addPromises).then((p) => {\n      p.forEach((result) => {\n        if (result.status === \"rejected\") {\n          console.error(`Error in adds for handle: ${result.reason}`);\n        }\n      });\n    });\n\n    handle.initialAddsSentResolver();\n  }\n}\n","export class DocFetcher {\n  constructor(mongoConnection) {\n    this._mongoConnection = mongoConnection;\n    // Map from op -> [callback]\n    this._callbacksForOp = new Map();\n  }\n\n  // Fetches document \"id\" from collectionName, returning it or null if not\n  // found.\n  //\n  // If you make multiple calls to fetch() with the same op reference,\n  // DocFetcher may assume that they all return the same document. (It does\n  // not check to see if collectionName/id match.)\n  //\n  // You may assume that callback is never called synchronously (and in fact\n  // OplogObserveDriver does so).\n  async fetch(collectionName, id, op, callback) {\n    const self = this;\n\n    \n    check(collectionName, String);\n    check(op, Object);\n\n\n    // If there's already an in-progress fetch for this cache key, yield until\n    // it's done and return whatever it returns.\n    if (self._callbacksForOp.has(op)) {\n      self._callbacksForOp.get(op).push(callback);\n      return;\n    }\n\n    const callbacks = [callback];\n    self._callbacksForOp.set(op, callbacks);\n\n    try {\n      var doc =\n        (await self._mongoConnection.findOneAsync(collectionName, {\n          _id: id,\n        })) || null;\n      // Return doc to all relevant callbacks. Note that this array can\n      // continue to grow during callback excecution.\n      while (callbacks.length > 0) {\n        // Clone the document so that the various calls to fetch don't return\n        // objects that are intertwingled with each other. Clone before\n        // popping the future, so that if clone throws, the error gets passed\n        // to the next callback.\n        callbacks.pop()(null, EJSON.clone(doc));\n      }\n    } catch (e) {\n      while (callbacks.length > 0) {\n        callbacks.pop()(e);\n      }\n    } finally {\n      // XXX consider keeping the doc around for a period of time before\n      // removing from the cache\n      self._callbacksForOp.delete(op);\n    }\n  }\n}\n","import throttle from 'lodash.throttle';\nimport { listenAll } from './mongo_driver';\nimport { ObserveMultiplexer } from './observe_multiplex';\n\ninterface PollingObserveDriverOptions {\n  cursorDescription: any;\n  mongoHandle: any;\n  ordered: boolean;\n  multiplexer: ObserveMultiplexer;\n  _testOnlyPollCallback?: () => void;\n}\n\nconst POLLING_THROTTLE_MS = +(process.env.METEOR_POLLING_THROTTLE_MS || '') || 50;\nconst POLLING_INTERVAL_MS = +(process.env.METEOR_POLLING_INTERVAL_MS || '') || 10 * 1000;\n\n/**\n * @class PollingObserveDriver\n *\n * One of two observe driver implementations.\n *\n * Characteristics:\n * - Caches the results of a query\n * - Reruns the query when necessary\n * - Suitable for cases where oplog tailing is not available or practical\n */\nexport class PollingObserveDriver {\n  private _options: PollingObserveDriverOptions;\n  private _cursorDescription: any;\n  private _mongoHandle: any;\n  private _ordered: boolean;\n  private _multiplexer: any;\n  private _stopCallbacks: Array<() => Promise<void>>;\n  private _stopped: boolean;\n  private _cursor: any;\n  private _results: any;\n  private _pollsScheduledButNotStarted: number;\n  private _pendingWrites: any[];\n  private _ensurePollIsScheduled: Function;\n  private _taskQueue: any;\n  private _testOnlyPollCallback?: () => void;\n\n  constructor(options: PollingObserveDriverOptions) {\n    this._options = options;\n    this._cursorDescription = options.cursorDescription;\n    this._mongoHandle = options.mongoHandle;\n    this._ordered = options.ordered;\n    this._multiplexer = options.multiplexer;\n    this._stopCallbacks = [];\n    this._stopped = false;\n\n    this._cursor = this._mongoHandle._createAsynchronousCursor(\n      this._cursorDescription);\n\n    this._results = null;\n    this._pollsScheduledButNotStarted = 0;\n    this._pendingWrites = [];\n\n    this._ensurePollIsScheduled = throttle(\n      this._unthrottledEnsurePollIsScheduled.bind(this),\n      this._cursorDescription.options.pollingThrottleMs || POLLING_THROTTLE_MS\n    );\n\n    this._taskQueue = new (Meteor as any)._AsynchronousQueue();\n  }\n\n  async _init(): Promise<void> {\n    const options = this._options;\n    const listenersHandle = await listenAll(\n      this._cursorDescription,\n      (notification: any) => {\n        const fence = (DDPServer as any)._getCurrentFence();\n        if (fence) {\n          this._pendingWrites.push(fence.beginWrite());\n        }\n        if (this._pollsScheduledButNotStarted === 0) {\n          this._ensurePollIsScheduled();\n        }\n      }\n    );\n\n    this._stopCallbacks.push(async () => { await listenersHandle.stop(); });\n\n    if (options._testOnlyPollCallback) {\n      this._testOnlyPollCallback = options._testOnlyPollCallback;\n    } else {\n      const pollingInterval =\n        this._cursorDescription.options.pollingIntervalMs ||\n        this._cursorDescription.options._pollingInterval ||\n        POLLING_INTERVAL_MS;\n\n      const intervalHandle = Meteor.setInterval(\n        this._ensurePollIsScheduled.bind(this),\n        pollingInterval\n      );\n\n      this._stopCallbacks.push(() => {\n        Meteor.clearInterval(intervalHandle);\n      });\n    }\n\n    await this._unthrottledEnsurePollIsScheduled();\n\n    (Package['facts-base'] as any)?.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-polling\", 1);\n  }\n\n  async _unthrottledEnsurePollIsScheduled(): Promise<void> {\n    if (this._pollsScheduledButNotStarted > 0) return;\n    ++this._pollsScheduledButNotStarted;\n    await this._taskQueue.runTask(async () => {\n      await this._pollMongo();\n    });\n  }\n\n  _suspendPolling(): void {\n    ++this._pollsScheduledButNotStarted;\n    this._taskQueue.runTask(() => {});\n\n    if (this._pollsScheduledButNotStarted !== 1) {\n      throw new Error(`_pollsScheduledButNotStarted is ${this._pollsScheduledButNotStarted}`);\n    }\n  }\n\n  async _resumePolling(): Promise<void> {\n    if (this._pollsScheduledButNotStarted !== 1) {\n      throw new Error(`_pollsScheduledButNotStarted is ${this._pollsScheduledButNotStarted}`);\n    }\n    await this._taskQueue.runTask(async () => {\n      await this._pollMongo();\n    });\n  }\n\n  async _pollMongo(): Promise<void> {\n    --this._pollsScheduledButNotStarted;\n\n    if (this._stopped) return;\n\n    let first = false;\n    let newResults;\n    let oldResults = this._results;\n\n    if (!oldResults) {\n      first = true;\n      oldResults = this._ordered ? [] : new (LocalCollection as any)._IdMap;\n    }\n\n    this._testOnlyPollCallback?.();\n\n    const writesForCycle = this._pendingWrites;\n    this._pendingWrites = [];\n\n    try {\n      newResults = await this._cursor.getRawObjects(this._ordered);\n    } catch (e: any) {\n      if (first && typeof(e.code) === 'number') {\n        await this._multiplexer.queryError(\n          new Error(\n            `Exception while polling query ${\n              JSON.stringify(this._cursorDescription)\n            }: ${e.message}`\n          )\n        );\n      }\n\n      Array.prototype.push.apply(this._pendingWrites, writesForCycle);\n      Meteor._debug(`Exception while polling query ${\n        JSON.stringify(this._cursorDescription)}`, e);\n      return;\n    }\n\n    if (!this._stopped) {\n      (LocalCollection as any)._diffQueryChanges(\n        this._ordered, oldResults, newResults, this._multiplexer);\n    }\n\n    if (first) this._multiplexer.ready();\n\n    this._results = newResults;\n\n    await this._multiplexer.onFlush(async () => {\n      for (const w of writesForCycle) {\n        await w.committed();\n      }\n    });\n  }\n\n  async stop(): Promise<void> {\n    this._stopped = true;\n\n    for (const callback of this._stopCallbacks) {\n      await callback();\n    }\n\n    for (const w of this._pendingWrites) {\n      await w.committed();\n    }\n\n    (Package['facts-base'] as any)?.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-polling\", -1);\n  }\n}","import has from 'lodash.has';\nimport isEmpty from 'lodash.isempty';\nimport { oplogV2V1Converter } from \"./oplog_v2_converter\";\nimport { check, Match } from 'meteor/check';\nimport { CursorDescription } from './cursor_description';\nimport { forEachTrigger, listenAll } from './mongo_driver';\nimport { Cursor } from './cursor';\nimport LocalCollection from 'meteor/minimongo/local_collection';\nimport { idForOp } from './oplog_tailing';\n\nvar PHASE = {\n  QUERYING: \"QUERYING\",\n  FETCHING: \"FETCHING\",\n  STEADY: \"STEADY\"\n};\n\n// Exception thrown by _needToPollQuery which unrolls the stack up to the\n// enclosing call to finishIfNeedToPollQuery.\nvar SwitchedToQuery = function () {};\nvar finishIfNeedToPollQuery = function (f) {\n  return function () {\n    try {\n      f.apply(this, arguments);\n    } catch (e) {\n      if (!(e instanceof SwitchedToQuery))\n        throw e;\n    }\n  };\n};\n\nvar currentId = 0;\n\n/**\n * @class OplogObserveDriver\n * An alternative to PollingObserveDriver which follows the MongoDB operation log\n * instead of re-polling the query.\n *\n * Characteristics:\n * - Follows the MongoDB operation log\n * - Directly observes database changes\n * - More efficient than polling for most use cases\n * - Requires access to MongoDB oplog\n *\n * Interface:\n * - Construction initiates observeChanges callbacks and ready() invocation to the ObserveMultiplexer\n * - Observation can be terminated via the stop() method\n */\nexport const OplogObserveDriver = function (options) {\n  const self = this;\n  self._usesOplog = true;  // tests look at this\n\n  self._id = currentId;\n  currentId++;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._multiplexer = options.multiplexer;\n\n  if (options.ordered) {\n    throw Error(\"OplogObserveDriver only supports unordered observeChanges\");\n  }\n\n  const sorter = options.sorter;\n  // We don't support $near and other geo-queries so it's OK to initialize the\n  // comparator only once in the constructor.\n  const comparator = sorter && sorter.getComparator();\n\n  if (options.cursorDescription.options.limit) {\n    // There are several properties ordered driver implements:\n    // - _limit is a positive number\n    // - _comparator is a function-comparator by which the query is ordered\n    // - _unpublishedBuffer is non-null Min/Max Heap,\n    //                      the empty buffer in STEADY phase implies that the\n    //                      everything that matches the queries selector fits\n    //                      into published set.\n    // - _published - Max Heap (also implements IdMap methods)\n\n    const heapOptions = { IdMap: LocalCollection._IdMap };\n    self._limit = self._cursorDescription.options.limit;\n    self._comparator = comparator;\n    self._sorter = sorter;\n    self._unpublishedBuffer = new MinMaxHeap(comparator, heapOptions);\n    // We need something that can find Max value in addition to IdMap interface\n    self._published = new MaxHeap(comparator, heapOptions);\n  } else {\n    self._limit = 0;\n    self._comparator = null;\n    self._sorter = null;\n    self._unpublishedBuffer = null;\n    // Memory Growth\n    self._published = new LocalCollection._IdMap;\n  }\n\n  // Indicates if it is safe to insert a new document at the end of the buffer\n  // for this query. i.e. it is known that there are no documents matching the\n  // selector those are not in published or buffer.\n  self._safeAppendToBuffer = false;\n\n  self._stopped = false;\n  self._stopHandles = [];\n  self._addStopHandles = function (newStopHandles) {\n    const expectedPattern = Match.ObjectIncluding({ stop: Function });\n    // Single item or array\n    check(newStopHandles, Match.OneOf([expectedPattern], expectedPattern));\n    self._stopHandles.push(newStopHandles);\n  }\n\n  Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-drivers-oplog\", 1);\n\n  self._registerPhaseChange(PHASE.QUERYING);\n\n  self._matcher = options.matcher;\n  // we are now using projection, not fields in the cursor description even if you pass {fields}\n  // in the cursor construction\n  const projection = self._cursorDescription.options.fields || self._cursorDescription.options.projection || {};\n  self._projectionFn = LocalCollection._compileProjection(projection);\n  // Projection function, result of combining important fields for selector and\n  // existing fields projection\n  self._sharedProjection = self._matcher.combineIntoProjection(projection);\n  if (sorter)\n    self._sharedProjection = sorter.combineIntoProjection(self._sharedProjection);\n  self._sharedProjectionFn = LocalCollection._compileProjection(\n    self._sharedProjection);\n\n  self._needToFetch = new LocalCollection._IdMap;\n  self._currentlyFetching = null;\n  self._fetchGeneration = 0;\n\n  self._requeryWhenDoneThisQuery = false;\n  self._writesToCommitWhenWeReachSteady = [];\n };\n\nObject.assign(OplogObserveDriver.prototype, {\n  _init: async function() {\n    const self = this;\n\n    // If the oplog handle tells us that it skipped some entries (because it got\n    // behind, say), re-poll.\n    self._addStopHandles(self._mongoHandle._oplogHandle.onSkippedEntries(\n      finishIfNeedToPollQuery(function () {\n        return self._needToPollQuery();\n      })\n    ));\n    \n    await forEachTrigger(self._cursorDescription, async function (trigger) {\n      self._addStopHandles(await self._mongoHandle._oplogHandle.onOplogEntry(\n        trigger, function (notification) {\n          finishIfNeedToPollQuery(function () {\n            const op = notification.op;\n            if (notification.dropCollection || notification.dropDatabase) {\n              // Note: this call is not allowed to block on anything (especially\n              // on waiting for oplog entries to catch up) because that will block\n              // onOplogEntry!\n              return self._needToPollQuery();\n            } else {\n              // All other operators should be handled depending on phase\n              if (self._phase === PHASE.QUERYING) {\n                return self._handleOplogEntryQuerying(op);\n              } else {\n                return self._handleOplogEntrySteadyOrFetching(op);\n              }\n            }\n          })();\n        }\n      ));\n    });\n  \n    // XXX ordering w.r.t. everything else?\n    self._addStopHandles(await listenAll(\n      self._cursorDescription, function () {\n        // If we're not in a pre-fire write fence, we don't have to do anything.\n        const fence = DDPServer._getCurrentFence();\n        if (!fence || fence.fired)\n          return;\n  \n        if (fence._oplogObserveDrivers) {\n          fence._oplogObserveDrivers[self._id] = self;\n          return;\n        }\n  \n        fence._oplogObserveDrivers = {};\n        fence._oplogObserveDrivers[self._id] = self;\n  \n        fence.onBeforeFire(async function () {\n          const drivers = fence._oplogObserveDrivers;\n          delete fence._oplogObserveDrivers;\n  \n          // This fence cannot fire until we've caught up to \"this point\" in the\n          // oplog, and all observers made it back to the steady state.\n          await self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n  \n          for (const driver of Object.values(drivers)) {\n            if (driver._stopped)\n              continue;\n  \n            const write = await fence.beginWrite();\n            if (driver._phase === PHASE.STEADY) {\n              // Make sure that all of the callbacks have made it through the\n              // multiplexer and been delivered to ObserveHandles before committing\n              // writes.\n              await driver._multiplexer.onFlush(write.committed);\n            } else {\n              driver._writesToCommitWhenWeReachSteady.push(write);\n            }\n          }\n        });\n      }\n    ));\n  \n    // When Mongo fails over, we need to repoll the query, in case we processed an\n    // oplog entry that got rolled back.\n    self._addStopHandles(self._mongoHandle._onFailover(finishIfNeedToPollQuery(\n      function () {\n        return self._needToPollQuery();\n      })));\n  \n    // Give _observeChanges a chance to add the new ObserveHandle to our\n    // multiplexer, so that the added calls get streamed.\n    return self._runInitialQuery();\n  },\n  _addPublished: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var fields = Object.assign({}, doc);\n      delete fields._id;\n      self._published.set(id, self._sharedProjectionFn(doc));\n      self._multiplexer.added(id, self._projectionFn(fields));\n\n      // After adding this document, the published set might be overflowed\n      // (exceeding capacity specified by limit). If so, push the maximum\n      // element to the buffer, we might want to save it in memory to reduce the\n      // amount of Mongo lookups in the future.\n      if (self._limit && self._published.size() > self._limit) {\n        // XXX in theory the size of published is no more than limit+1\n        if (self._published.size() !== self._limit + 1) {\n          throw new Error(\"After adding to published, \" +\n                          (self._published.size() - self._limit) +\n                          \" documents are overflowing the set\");\n        }\n\n        var overflowingDocId = self._published.maxElementId();\n        var overflowingDoc = self._published.get(overflowingDocId);\n\n        if (EJSON.equals(overflowingDocId, id)) {\n          throw new Error(\"The document just added is overflowing the published set\");\n        }\n\n        self._published.remove(overflowingDocId);\n        self._multiplexer.removed(overflowingDocId);\n        self._addBuffered(overflowingDocId, overflowingDoc);\n      }\n    });\n  },\n  _removePublished: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.remove(id);\n      self._multiplexer.removed(id);\n      if (! self._limit || self._published.size() === self._limit)\n        return;\n\n      if (self._published.size() > self._limit)\n        throw Error(\"self._published got too big\");\n\n      // OK, we are publishing less than the limit. Maybe we should look in the\n      // buffer to find the next element past what we were publishing before.\n\n      if (!self._unpublishedBuffer.empty()) {\n        // There's something in the buffer; move the first thing in it to\n        // _published.\n        var newDocId = self._unpublishedBuffer.minElementId();\n        var newDoc = self._unpublishedBuffer.get(newDocId);\n        self._removeBuffered(newDocId);\n        self._addPublished(newDocId, newDoc);\n        return;\n      }\n\n      // There's nothing in the buffer.  This could mean one of a few things.\n\n      // (a) We could be in the middle of re-running the query (specifically, we\n      // could be in _publishNewResults). In that case, _unpublishedBuffer is\n      // empty because we clear it at the beginning of _publishNewResults. In\n      // this case, our caller already knows the entire answer to the query and\n      // we don't need to do anything fancy here.  Just return.\n      if (self._phase === PHASE.QUERYING)\n        return;\n\n      // (b) We're pretty confident that the union of _published and\n      // _unpublishedBuffer contain all documents that match selector. Because\n      // _unpublishedBuffer is empty, that means we're confident that _published\n      // contains all documents that match selector. So we have nothing to do.\n      if (self._safeAppendToBuffer)\n        return;\n\n      // (c) Maybe there are other documents out there that should be in our\n      // buffer. But in that case, when we emptied _unpublishedBuffer in\n      // _removeBuffered, we should have called _needToPollQuery, which will\n      // either put something in _unpublishedBuffer or set _safeAppendToBuffer\n      // (or both), and it will put us in QUERYING for that whole time. So in\n      // fact, we shouldn't be able to get here.\n\n      throw new Error(\"Buffer inexplicably empty\");\n    });\n  },\n  _changePublished: function (id, oldDoc, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._published.set(id, self._sharedProjectionFn(newDoc));\n      var projectedNew = self._projectionFn(newDoc);\n      var projectedOld = self._projectionFn(oldDoc);\n      var changed = DiffSequence.makeChangedFields(\n        projectedNew, projectedOld);\n      if (!isEmpty(changed))\n        self._multiplexer.changed(id, changed);\n    });\n  },\n  _addBuffered: function (id, doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.set(id, self._sharedProjectionFn(doc));\n\n      // If something is overflowing the buffer, we just remove it from cache\n      if (self._unpublishedBuffer.size() > self._limit) {\n        var maxBufferedId = self._unpublishedBuffer.maxElementId();\n\n        self._unpublishedBuffer.remove(maxBufferedId);\n\n        // Since something matching is removed from cache (both published set and\n        // buffer), set flag to false\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Is called either to remove the doc completely from matching set or to move\n  // it to the published set later.\n  _removeBuffered: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._unpublishedBuffer.remove(id);\n      // To keep the contract \"buffer is never empty in STEADY phase unless the\n      // everything matching fits into published\" true, we poll everything as\n      // soon as we see the buffer becoming empty.\n      if (! self._unpublishedBuffer.size() && ! self._safeAppendToBuffer)\n        self._needToPollQuery();\n    });\n  },\n  // Called when a document has joined the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _addMatching: function (doc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = doc._id;\n      if (self._published.has(id))\n        throw Error(\"tried to add something already published \" + id);\n      if (self._limit && self._unpublishedBuffer.has(id))\n        throw Error(\"tried to add something already existed in buffer \" + id);\n\n      var limit = self._limit;\n      var comparator = self._comparator;\n      var maxPublished = (limit && self._published.size() > 0) ?\n        self._published.get(self._published.maxElementId()) : null;\n      var maxBuffered = (limit && self._unpublishedBuffer.size() > 0)\n        ? self._unpublishedBuffer.get(self._unpublishedBuffer.maxElementId())\n        : null;\n      // The query is unlimited or didn't publish enough documents yet or the\n      // new document would fit into published set pushing the maximum element\n      // out, then we need to publish the doc.\n      var toPublish = ! limit || self._published.size() < limit ||\n        comparator(doc, maxPublished) < 0;\n\n      // Otherwise we might need to buffer it (only in case of limited query).\n      // Buffering is allowed if the buffer is not filled up yet and all\n      // matching docs are either in the published set or in the buffer.\n      var canAppendToBuffer = !toPublish && self._safeAppendToBuffer &&\n        self._unpublishedBuffer.size() < limit;\n\n      // Or if it is small enough to be safely inserted to the middle or the\n      // beginning of the buffer.\n      var canInsertIntoBuffer = !toPublish && maxBuffered &&\n        comparator(doc, maxBuffered) <= 0;\n\n      var toBuffer = canAppendToBuffer || canInsertIntoBuffer;\n\n      if (toPublish) {\n        self._addPublished(id, doc);\n      } else if (toBuffer) {\n        self._addBuffered(id, doc);\n      } else {\n        // dropping it and not saving to the cache\n        self._safeAppendToBuffer = false;\n      }\n    });\n  },\n  // Called when a document leaves the \"Matching\" results set.\n  // Takes responsibility of keeping _unpublishedBuffer in sync with _published\n  // and the effect of limit enforced.\n  _removeMatching: function (id) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (! self._published.has(id) && ! self._limit)\n        throw Error(\"tried to remove something matching but not cached \" + id);\n\n      if (self._published.has(id)) {\n        self._removePublished(id);\n      } else if (self._unpublishedBuffer.has(id)) {\n        self._removeBuffered(id);\n      }\n    });\n  },\n  _handleDoc: function (id, newDoc) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var matchesNow = newDoc && self._matcher.documentMatches(newDoc).result;\n\n      var publishedBefore = self._published.has(id);\n      var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n      var cachedBefore = publishedBefore || bufferedBefore;\n\n      if (matchesNow && !cachedBefore) {\n        self._addMatching(newDoc);\n      } else if (cachedBefore && !matchesNow) {\n        self._removeMatching(id);\n      } else if (cachedBefore && matchesNow) {\n        var oldDoc = self._published.get(id);\n        var comparator = self._comparator;\n        var minBuffered = self._limit && self._unpublishedBuffer.size() &&\n          self._unpublishedBuffer.get(self._unpublishedBuffer.minElementId());\n        var maxBuffered;\n\n        if (publishedBefore) {\n          // Unlimited case where the document stays in published once it\n          // matches or the case when we don't have enough matching docs to\n          // publish or the changed but matching doc will stay in published\n          // anyways.\n          //\n          // XXX: We rely on the emptiness of buffer. Be sure to maintain the\n          // fact that buffer can't be empty if there are matching documents not\n          // published. Notably, we don't want to schedule repoll and continue\n          // relying on this property.\n          var staysInPublished = ! self._limit ||\n            self._unpublishedBuffer.size() === 0 ||\n            comparator(newDoc, minBuffered) <= 0;\n\n          if (staysInPublished) {\n            self._changePublished(id, oldDoc, newDoc);\n          } else {\n            // after the change doc doesn't stay in the published, remove it\n            self._removePublished(id);\n            // but it can move into buffered now, check it\n            maxBuffered = self._unpublishedBuffer.get(\n              self._unpublishedBuffer.maxElementId());\n\n            var toBuffer = self._safeAppendToBuffer ||\n                  (maxBuffered && comparator(newDoc, maxBuffered) <= 0);\n\n            if (toBuffer) {\n              self._addBuffered(id, newDoc);\n            } else {\n              // Throw away from both published set and buffer\n              self._safeAppendToBuffer = false;\n            }\n          }\n        } else if (bufferedBefore) {\n          oldDoc = self._unpublishedBuffer.get(id);\n          // remove the old version manually instead of using _removeBuffered so\n          // we don't trigger the querying immediately.  if we end this block\n          // with the buffer empty, we will need to trigger the query poll\n          // manually too.\n          self._unpublishedBuffer.remove(id);\n\n          var maxPublished = self._published.get(\n            self._published.maxElementId());\n          maxBuffered = self._unpublishedBuffer.size() &&\n                self._unpublishedBuffer.get(\n                  self._unpublishedBuffer.maxElementId());\n\n          // the buffered doc was updated, it could move to published\n          var toPublish = comparator(newDoc, maxPublished) < 0;\n\n          // or stays in buffer even after the change\n          var staysInBuffer = (! toPublish && self._safeAppendToBuffer) ||\n                (!toPublish && maxBuffered &&\n                 comparator(newDoc, maxBuffered) <= 0);\n\n          if (toPublish) {\n            self._addPublished(id, newDoc);\n          } else if (staysInBuffer) {\n            // stays in buffer but changes\n            self._unpublishedBuffer.set(id, newDoc);\n          } else {\n            // Throw away from both published set and buffer\n            self._safeAppendToBuffer = false;\n            // Normally this check would have been done in _removeBuffered but\n            // we didn't use it, so we need to do it ourself now.\n            if (! self._unpublishedBuffer.size()) {\n              self._needToPollQuery();\n            }\n          }\n        } else {\n          throw new Error(\"cachedBefore implies either of publishedBefore or bufferedBefore is true.\");\n        }\n      }\n    });\n  },\n  _fetchModifiedDocuments: function () {\n    var self = this;\n    self._registerPhaseChange(PHASE.FETCHING);\n    // Defer, because nothing called from the oplog entry handler may yield,\n    // but fetch() yields.\n    Meteor.defer(finishIfNeedToPollQuery(async function () {\n      while (!self._stopped && !self._needToFetch.empty()) {\n        if (self._phase === PHASE.QUERYING) {\n          // While fetching, we decided to go into QUERYING mode, and then we\n          // saw another oplog entry, so _needToFetch is not empty. But we\n          // shouldn't fetch these documents until AFTER the query is done.\n          break;\n        }\n\n        // Being in steady phase here would be surprising.\n        if (self._phase !== PHASE.FETCHING)\n          throw new Error(\"phase in fetchModifiedDocuments: \" + self._phase);\n\n        self._currentlyFetching = self._needToFetch;\n        var thisGeneration = ++self._fetchGeneration;\n        self._needToFetch = new LocalCollection._IdMap;\n\n        // Create an array of promises for all the fetch operations\n        const fetchPromises = [];\n\n        self._currentlyFetching.forEach(function (op, id) {\n          const fetchPromise = new Promise((resolve, reject) => {\n            self._mongoHandle._docFetcher.fetch(\n              self._cursorDescription.collectionName,\n              id,\n              op,\n              finishIfNeedToPollQuery(function(err, doc) {\n                if (err) {\n                  Meteor._debug('Got exception while fetching documents', err);\n                  // If we get an error from the fetcher (eg, trouble\n                  // connecting to Mongo), let's just abandon the fetch phase\n                  // altogether and fall back to polling. It's not like we're\n                  // getting live updates anyway.\n                  if (self._phase !== PHASE.QUERYING) {\n                    self._needToPollQuery();\n                  }\n                  resolve();\n                  return;\n                }\n\n                if (\n                  !self._stopped &&\n                  self._phase === PHASE.FETCHING &&\n                  self._fetchGeneration === thisGeneration\n                ) {\n                  // We re-check the generation in case we've had an explicit\n                  // _pollQuery call (eg, in another fiber) which should\n                  // effectively cancel this round of fetches.  (_pollQuery\n                  // increments the generation.)\n                  try {\n                    self._handleDoc(id, doc);\n                    resolve();\n                  } catch (err) {\n                    reject(err);\n                  }\n                } else {\n                  resolve();\n                }\n              })\n            )\n          })\n          fetchPromises.push(fetchPromise);\n        });\n        // Wait for all fetch operations to complete\n        try {\n          const results = await Promise.allSettled(fetchPromises);\n          const errors = results\n            .filter(result => result.status === 'rejected')\n            .map(result => result.reason);\n\n          if (errors.length > 0) {\n            Meteor._debug('Some fetch queries failed:', errors);\n          }\n        } catch (err) {\n          Meteor._debug('Got an exception in a fetch query', err);\n        }\n        // Exit now if we've had a _pollQuery call (here or in another fiber).\n        if (self._phase === PHASE.QUERYING)\n          return;\n        self._currentlyFetching = null;\n      }\n      // We're done fetching, so we can be steady, unless we've had a\n      // _pollQuery call (here or in another fiber).\n      if (self._phase !== PHASE.QUERYING)\n        await self._beSteady();\n    }));\n  },\n  _beSteady: async function () {\n    var self = this;\n    self._registerPhaseChange(PHASE.STEADY);\n    var writes = self._writesToCommitWhenWeReachSteady || [];\n    self._writesToCommitWhenWeReachSteady = [];\n    await self._multiplexer.onFlush(async function () {\n      try {\n        for (const w of writes) {\n          await w.committed();\n        }\n      } catch (e) {\n        console.error(\"_beSteady error\", {writes}, e);\n      }\n    });\n  },\n  _handleOplogEntryQuerying: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      self._needToFetch.set(idForOp(op), op);\n    });\n  },\n  _handleOplogEntrySteadyOrFetching: function (op) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var id = idForOp(op);\n      // If we're already fetching this one, or about to, we can't optimize;\n      // make sure that we fetch it again if necessary.\n\n      if (self._phase === PHASE.FETCHING &&\n          ((self._currentlyFetching && self._currentlyFetching.has(id)) ||\n           self._needToFetch.has(id))) {\n        self._needToFetch.set(id, op);\n        return;\n      }\n\n      if (op.op === 'd') {\n        if (self._published.has(id) ||\n            (self._limit && self._unpublishedBuffer.has(id)))\n          self._removeMatching(id);\n      } else if (op.op === 'i') {\n        if (self._published.has(id))\n          throw new Error(\"insert found for already-existing ID in published\");\n        if (self._unpublishedBuffer && self._unpublishedBuffer.has(id))\n          throw new Error(\"insert found for already-existing ID in buffer\");\n\n        // XXX what if selector yields?  for now it can't but later it could\n        // have $where\n        if (self._matcher.documentMatches(op.o).result)\n          self._addMatching(op.o);\n      } else if (op.op === 'u') {\n        // we are mapping the new oplog format on mongo 5\n        // to what we know better, $set\n        op.o = oplogV2V1Converter(op.o)\n        // Is this a modifier ($set/$unset, which may require us to poll the\n        // database to figure out if the whole document matches the selector) or\n        // a replacement (in which case we can just directly re-evaluate the\n        // selector)?\n        // oplog format has changed on mongodb 5, we have to support both now\n        // diff is the format in Mongo 5+ (oplog v2)\n        var isReplace = !has(op.o, '$set') && !has(op.o, 'diff') && !has(op.o, '$unset');\n        // If this modifier modifies something inside an EJSON custom type (ie,\n        // anything with EJSON$), then we can't try to use\n        // LocalCollection._modify, since that just mutates the EJSON encoding,\n        // not the actual object.\n        var canDirectlyModifyDoc =\n          !isReplace && modifierCanBeDirectlyApplied(op.o);\n\n        var publishedBefore = self._published.has(id);\n        var bufferedBefore = self._limit && self._unpublishedBuffer.has(id);\n\n        if (isReplace) {\n          self._handleDoc(id, Object.assign({_id: id}, op.o));\n        } else if ((publishedBefore || bufferedBefore) &&\n                   canDirectlyModifyDoc) {\n          // Oh great, we actually know what the document is, so we can apply\n          // this directly.\n          var newDoc = self._published.has(id)\n            ? self._published.get(id) : self._unpublishedBuffer.get(id);\n          newDoc = EJSON.clone(newDoc);\n\n          newDoc._id = id;\n          try {\n            LocalCollection._modify(newDoc, op.o);\n          } catch (e) {\n            if (e.name !== \"MinimongoError\")\n              throw e;\n            // We didn't understand the modifier.  Re-fetch.\n            self._needToFetch.set(id, op);\n            if (self._phase === PHASE.STEADY) {\n              self._fetchModifiedDocuments();\n            }\n            return;\n          }\n          self._handleDoc(id, self._sharedProjectionFn(newDoc));\n        } else if (!canDirectlyModifyDoc ||\n                   self._matcher.canBecomeTrueByModifier(op.o) ||\n                   (self._sorter && self._sorter.affectedByModifier(op.o))) {\n          self._needToFetch.set(id, op);\n          if (self._phase === PHASE.STEADY)\n            self._fetchModifiedDocuments();\n        }\n      } else {\n        throw Error(\"XXX SURPRISING OPERATION: \" + op);\n      }\n    });\n  },\n\n  async _runInitialQueryAsync() {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"oplog stopped surprisingly early\");\n\n    await self._runQuery({initial: true});  // yields\n\n    if (self._stopped)\n      return;  // can happen on queryError\n\n    // Allow observeChanges calls to return. (After this, it's possible for\n    // stop() to be called.)\n    await self._multiplexer.ready();\n\n    await self._doneQuerying();  // yields\n  },\n\n  // Yields!\n  _runInitialQuery: function () {\n    return this._runInitialQueryAsync();\n  },\n\n  // In various circumstances, we may just want to stop processing the oplog and\n  // re-run the initial query, just as if we were a PollingObserveDriver.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler.\n  //\n  // XXX We should call this when we detect that we've been in FETCHING for \"too\n  // long\".\n  //\n  // XXX We should call this when we detect Mongo failover (since that might\n  // mean that some of the oplog entries we have processed have been rolled\n  // back). The Node Mongo driver is in the middle of a bunch of huge\n  // refactorings, including the way that it notifies you when primary\n  // changes. Will put off implementing this until driver 1.4 is out.\n  _pollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // Yay, we get to forget about all the things we thought we had to fetch.\n      self._needToFetch = new LocalCollection._IdMap;\n      self._currentlyFetching = null;\n      ++self._fetchGeneration;  // ignore any in-flight fetches\n      self._registerPhaseChange(PHASE.QUERYING);\n\n      // Defer so that we don't yield.  We don't need finishIfNeedToPollQuery\n      // here because SwitchedToQuery is not thrown in QUERYING mode.\n      Meteor.defer(async function () {\n        await self._runQuery();\n        await self._doneQuerying();\n      });\n    });\n  },\n\n  // Yields!\n  async _runQueryAsync(options) {\n    var self = this;\n    options = options || {};\n    var newResults, newBuffer;\n\n    // This while loop is just to retry failures.\n    while (true) {\n      // If we've been stopped, we don't have to run anything any more.\n      if (self._stopped)\n        return;\n\n      newResults = new LocalCollection._IdMap;\n      newBuffer = new LocalCollection._IdMap;\n\n      // Query 2x documents as the half excluded from the original query will go\n      // into unpublished buffer to reduce additional Mongo lookups in cases\n      // when documents are removed from the published set and need a\n      // replacement.\n      // XXX needs more thought on non-zero skip\n      // XXX 2 is a \"magic number\" meaning there is an extra chunk of docs for\n      // buffer if such is needed.\n      var cursor = self._cursorForQuery({ limit: self._limit * 2 });\n      try {\n        await cursor.forEach(function (doc, i) {  // yields\n          if (!self._limit || i < self._limit) {\n            newResults.set(doc._id, doc);\n          } else {\n            newBuffer.set(doc._id, doc);\n          }\n        });\n        break;\n      } catch (e) {\n        if (options.initial && typeof(e.code) === 'number') {\n          // This is an error document sent to us by mongod, not a connection\n          // error generated by the client. And we've never seen this query work\n          // successfully. Probably it's a bad selector or something, so we\n          // should NOT retry. Instead, we should halt the observe (which ends\n          // up calling `stop` on us).\n          await self._multiplexer.queryError(e);\n          return;\n        }\n\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while polling query\", e);\n        await Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    self._publishNewResults(newResults, newBuffer);\n  },\n\n  // Yields!\n  _runQuery: function (options) {\n    return this._runQueryAsync(options);\n  },\n\n  // Transitions to QUERYING and runs another query, or (if already in QUERYING)\n  // ensures that we will query again later.\n  //\n  // This function may not block, because it is called from an oplog entry\n  // handler. However, if we were not already in the QUERYING phase, it throws\n  // an exception that is caught by the closest surrounding\n  // finishIfNeedToPollQuery call; this ensures that we don't continue running\n  // close that was designed for another phase inside PHASE.QUERYING.\n  //\n  // (It's also necessary whenever logic in this file yields to check that other\n  // phases haven't put us into QUERYING mode, though; eg,\n  // _fetchModifiedDocuments does this.)\n  _needToPollQuery: function () {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      if (self._stopped)\n        return;\n\n      // If we're not already in the middle of a query, we can query now\n      // (possibly pausing FETCHING).\n      if (self._phase !== PHASE.QUERYING) {\n        self._pollQuery();\n        throw new SwitchedToQuery;\n      }\n\n      // We're currently in QUERYING. Set a flag to ensure that we run another\n      // query when we're done.\n      self._requeryWhenDoneThisQuery = true;\n    });\n  },\n\n  // Yields!\n  _doneQuerying: async function () {\n    var self = this;\n\n    if (self._stopped)\n      return;\n\n    await self._mongoHandle._oplogHandle.waitUntilCaughtUp();\n\n    if (self._stopped)\n      return;\n\n    if (self._phase !== PHASE.QUERYING)\n      throw Error(\"Phase unexpectedly \" + self._phase);\n\n    if (self._requeryWhenDoneThisQuery) {\n      self._requeryWhenDoneThisQuery = false;\n      self._pollQuery();\n    } else if (self._needToFetch.empty()) {\n      await self._beSteady();\n    } else {\n      self._fetchModifiedDocuments();\n    }\n  },\n\n  _cursorForQuery: function (optionsOverwrite) {\n    var self = this;\n    return Meteor._noYieldsAllowed(function () {\n      // The query we run is almost the same as the cursor we are observing,\n      // with a few changes. We need to read all the fields that are relevant to\n      // the selector, not just the fields we are going to publish (that's the\n      // \"shared\" projection). And we don't want to apply any transform in the\n      // cursor, because observeChanges shouldn't use the transform.\n      var options = Object.assign({}, self._cursorDescription.options);\n\n      // Allow the caller to modify the options. Useful to specify different\n      // skip and limit values.\n      Object.assign(options, optionsOverwrite);\n\n      options.fields = self._sharedProjection;\n      delete options.transform;\n      // We are NOT deep cloning fields or selector here, which should be OK.\n      var description = new CursorDescription(\n        self._cursorDescription.collectionName,\n        self._cursorDescription.selector,\n        options);\n      return new Cursor(self._mongoHandle, description);\n    });\n  },\n\n\n  // Replace self._published with newResults (both are IdMaps), invoking observe\n  // callbacks on the multiplexer.\n  // Replace self._unpublishedBuffer with newBuffer.\n  //\n  // XXX This is very similar to LocalCollection._diffQueryUnorderedChanges. We\n  // should really: (a) Unify IdMap and OrderedDict into Unordered/OrderedDict\n  // (b) Rewrite diff.js to use these classes instead of arrays and objects.\n  _publishNewResults: function (newResults, newBuffer) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n\n      // If the query is limited and there is a buffer, shut down so it doesn't\n      // stay in a way.\n      if (self._limit) {\n        self._unpublishedBuffer.clear();\n      }\n\n      // First remove anything that's gone. Be careful not to modify\n      // self._published while iterating over it.\n      var idsToRemove = [];\n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          idsToRemove.push(id);\n      });\n      idsToRemove.forEach(function (id) {\n        self._removePublished(id);\n      });\n\n      // Now do adds and changes.\n      // If self has a buffer and limit, the new fetched result will be\n      // limited correctly as the query has sort specifier.\n      newResults.forEach(function (doc, id) {\n        self._handleDoc(id, doc);\n      });\n\n      // Sanity-check that everything we tried to put into _published ended up\n      // there.\n      // XXX if this is slow, remove it later\n      if (self._published.size() !== newResults.size()) {\n        Meteor._debug('The Mongo server and the Meteor query disagree on how ' +\n          'many documents match your query. Cursor description: ',\n          self._cursorDescription);\n      }\n      \n      self._published.forEach(function (doc, id) {\n        if (!newResults.has(id))\n          throw Error(\"_published has a doc that newResults doesn't; \" + id);\n      });\n\n      // Finally, replace the buffer\n      newBuffer.forEach(function (doc, id) {\n        self._addBuffered(id, doc);\n      });\n\n      self._safeAppendToBuffer = newBuffer.size() < self._limit;\n    });\n  },\n\n  // This stop function is invoked from the onStop of the ObserveMultiplexer, so\n  // it shouldn't actually be possible to call it until the multiplexer is\n  // ready.\n  //\n  // It's important to check self._stopped after every call in this file that\n  // can yield!\n  _stop: async function() {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n\n    // Note: we *don't* use multiplexer.onFlush here because this stop\n    // callback is actually invoked by the multiplexer itself when it has\n    // determined that there are no handles left. So nothing is actually going\n    // to get flushed (and it's probably not valid to call methods on the\n    // dying multiplexer).\n    for (const w of self._writesToCommitWhenWeReachSteady) {\n      await w.committed();\n    }\n    self._writesToCommitWhenWeReachSteady = null;\n\n    // Proactively drop references to potentially big things.\n    self._published = null;\n    self._unpublishedBuffer = null;\n    self._needToFetch = null;\n    self._currentlyFetching = null;\n    self._oplogEntryHandle = null;\n    self._listenersHandle = null;\n\n    Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n        \"mongo-livedata\", \"observe-drivers-oplog\", -1);\n\n    for await (const handle of self._stopHandles) {\n      await handle.stop();\n    }\n  },\n  stop: async function() {\n    const self = this;\n    return await self._stop();\n  },\n\n  _registerPhaseChange: function (phase) {\n    var self = this;\n    Meteor._noYieldsAllowed(function () {\n      var now = new Date;\n\n      if (self._phase) {\n        var timeDiff = now - self._phaseStartTime;\n        Package['facts-base'] && Package['facts-base'].Facts.incrementServerFact(\n          \"mongo-livedata\", \"time-spent-in-\" + self._phase + \"-phase\", timeDiff);\n      }\n\n      self._phase = phase;\n      self._phaseStartTime = now;\n    });\n  }\n});\n\n// Does our oplog tailing code support this cursor? For now, we are being very\n// conservative and allowing only simple queries with simple options.\n// (This is a \"static method\".)\nOplogObserveDriver.cursorSupported = function (cursorDescription, matcher) {\n  // First, check the options.\n  var options = cursorDescription.options;\n\n  // Did the user say no explicitly?\n  // underscored version of the option is COMPAT with 1.2\n  if (options.disableOplog || options._disableOplog)\n    return false;\n\n  // skip is not supported: to support it we would need to keep track of all\n  // \"skipped\" documents or at least their ids.\n  // limit w/o a sort specifier is not supported: current implementation needs a\n  // deterministic way to order documents.\n  if (options.skip || (options.limit && !options.sort)) return false;\n\n  // If a fields projection option is given check if it is supported by\n  // minimongo (some operators are not supported).\n  const fields = options.fields || options.projection;\n  if (fields) {\n    try {\n      LocalCollection._checkSupportedProjection(fields);\n    } catch (e) {\n      if (e.name === \"MinimongoError\") {\n        return false;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // We don't allow the following selectors:\n  //   - $where (not confident that we provide the same JS environment\n  //             as Mongo, and can yield!)\n  //   - $near (has \"interesting\" properties in MongoDB, like the possibility\n  //            of returning an ID multiple times, though even polling maybe\n  //            have a bug there)\n  //           XXX: once we support it, we would need to think more on how we\n  //           initialize the comparators when we create the driver.\n  return !matcher.hasWhere() && !matcher.hasGeoQuery();\n};\n\nvar modifierCanBeDirectlyApplied = function (modifier) {\n  return Object.entries(modifier).every(function ([operation, fields]) {\n    return Object.entries(fields).every(function ([field, value]) {\n      return !/EJSON\\$/.test(field);\n    });\n  });\n};","/**\n * Converter module for the new MongoDB Oplog format (>=5.0) to the one that Meteor\n * handles well, i.e., `$set` and `$unset`. The new format is completely new,\n * and looks as follows:\n *\n * ```js\n * { $v: 2, diff: Diff }\n * ```\n *\n * where `Diff` is a recursive structure:\n * ```js\n * {\n *   // Nested updates (sometimes also represented with an s-field).\n *   // Example: `{ $set: { 'foo.bar': 1 } }`.\n *   i: { <key>: <value>, ... },\n *\n *   // Top-level updates.\n *   // Example: `{ $set: { foo: { bar: 1 } } }`.\n *   u: { <key>: <value>, ... },\n *\n *   // Unsets.\n *   // Example: `{ $unset: { foo: '' } }`.\n *   d: { <key>: false, ... },\n *\n *   // Array operations.\n *   // Example: `{ $push: { foo: 'bar' } }`.\n *   s<key>: { a: true, u<index>: <value>, ... },\n *   ...\n *\n *   // Nested operations (sometimes also represented in the `i` field).\n *   // Example: `{ $set: { 'foo.bar': 1 } }`.\n *   s<key>: Diff,\n *   ...\n * }\n * ```\n *\n * (all fields are optional)\n */\n\nimport { EJSON } from 'meteor/ejson';\n\ninterface OplogEntry {\n  $v: number;\n  diff?: OplogDiff;\n  $set?: Record<string, any>;\n  $unset?: Record<string, true>;\n}\n\ninterface OplogDiff {\n  i?: Record<string, any>;\n  u?: Record<string, any>;\n  d?: Record<string, boolean>;\n  [key: `s${string}`]: ArrayOperator | Record<string, any>;\n}\n\ninterface ArrayOperator {\n  a: true;\n  [key: `u${number}`]: any;\n}\n\nconst arrayOperatorKeyRegex = /^(a|[su]\\d+)$/;\n\n/**\n * Checks if a field is an array operator key of form 'a' or 's1' or 'u1' etc\n */\nfunction isArrayOperatorKey(field: string): boolean {\n  return arrayOperatorKeyRegex.test(field);\n}\n\n/**\n * Type guard to check if an operator is a valid array operator.\n * Array operators have 'a: true' and keys that match the arrayOperatorKeyRegex\n */\nfunction isArrayOperator(operator: unknown): operator is ArrayOperator {\n  return (\n    operator !== null &&\n    typeof operator === 'object' &&\n    'a' in operator &&\n    (operator as ArrayOperator).a === true &&\n    Object.keys(operator).every(isArrayOperatorKey)\n  );\n}\n\n/**\n * Joins two parts of a field path with a dot.\n * Returns the key itself if prefix is empty.\n */\nfunction join(prefix: string, key: string): string {\n  return prefix ? `${prefix}.${key}` : key;\n}\n\n/**\n * Recursively flattens an object into a target object with dot notation paths.\n * Handles special cases:\n * - Arrays are assigned directly\n * - Custom EJSON types are preserved\n * - Mongo.ObjectIDs are preserved\n * - Plain objects are recursively flattened\n * - Empty objects are assigned directly\n */\nfunction flattenObjectInto(\n  target: Record<string, any>,\n  source: any,\n  prefix: string\n): void {\n  if (\n    Array.isArray(source) ||\n    typeof source !== 'object' ||\n    source === null ||\n    source instanceof Mongo.ObjectID ||\n    EJSON._isCustomType(source)\n  ) {\n    target[prefix] = source;\n    return;\n  }\n\n  const entries = Object.entries(source);\n  if (entries.length) {\n    entries.forEach(([key, value]) => {\n      flattenObjectInto(target, value, join(prefix, key));\n    });\n  } else {\n    target[prefix] = source;\n  }\n}\n\n/**\n * Converts an oplog diff to a series of $set and $unset operations.\n * Handles several types of operations:\n * - Direct unsets via 'd' field\n * - Nested sets via 'i' field\n * - Top-level sets via 'u' field\n * - Array operations and nested objects via 's' prefixed fields\n *\n * Preserves the structure of EJSON custom types and ObjectIDs while\n * flattening paths into dot notation for MongoDB updates.\n */\nfunction convertOplogDiff(\n  oplogEntry: OplogEntry,\n  diff: OplogDiff,\n  prefix = ''\n): void {\n  Object.entries(diff).forEach(([diffKey, value]) => {\n    if (diffKey === 'd') {\n      // Handle `$unset`s\n      oplogEntry.$unset ??= {};\n      Object.keys(value).forEach(key => {\n        oplogEntry.$unset![join(prefix, key)] = true;\n      });\n    } else if (diffKey === 'i') {\n      // Handle (potentially) nested `$set`s\n      oplogEntry.$set ??= {};\n      flattenObjectInto(oplogEntry.$set, value, prefix);\n    } else if (diffKey === 'u') {\n      // Handle flat `$set`s\n      oplogEntry.$set ??= {};\n      Object.entries(value).forEach(([key, fieldValue]) => {\n        oplogEntry.$set![join(prefix, key)] = fieldValue;\n      });\n    } else if (diffKey.startsWith('s')) {\n      // Handle s-fields (array operations and nested objects)\n      const key = diffKey.slice(1);\n      if (isArrayOperator(value)) {\n        // Array operator\n        Object.entries(value).forEach(([position, fieldValue]) => {\n          if (position === 'a') return;\n\n          const positionKey = join(prefix, `${key}.${position.slice(1)}`);\n          if (position[0] === 's') {\n            convertOplogDiff(oplogEntry, fieldValue, positionKey);\n          } else if (fieldValue === null) {\n            oplogEntry.$unset ??= {};\n            oplogEntry.$unset[positionKey] = true;\n          } else {\n            oplogEntry.$set ??= {};\n            oplogEntry.$set[positionKey] = fieldValue;\n          }\n        });\n      } else if (key) {\n        // Nested object\n        convertOplogDiff(oplogEntry, value, join(prefix, key));\n      }\n    }\n  });\n}\n\n/**\n * Converts a MongoDB v2 oplog entry to v1 format.\n * Returns the original entry unchanged if it's not a v2 oplog entry\n * or doesn't contain a diff field.\n *\n * The converted entry will contain $set and $unset operations that are\n * equivalent to the v2 diff format, with paths flattened to dot notation\n * and special handling for EJSON custom types and ObjectIDs.\n */\nexport function oplogV2V1Converter(oplogEntry: OplogEntry): OplogEntry {\n  if (oplogEntry.$v !== 2 || !oplogEntry.diff) {\n    return oplogEntry;\n  }\n\n  const convertedOplogEntry: OplogEntry = { $v: 2 };\n  convertOplogDiff(convertedOplogEntry, oplogEntry.diff);\n  return convertedOplogEntry;\n}","interface CursorOptions {\n  limit?: number;\n  skip?: number;\n  sort?: Record<string, 1 | -1>;\n  fields?: Record<string, 1 | 0>;\n  projection?: Record<string, 1 | 0>;\n  disableOplog?: boolean;\n  _disableOplog?: boolean;\n  tailable?: boolean;\n  transform?: (doc: any) => any;\n}\n\n/**\n * Represents the arguments used to construct a cursor.\n * Used as a key for cursor de-duplication.\n *\n * All properties must be either:\n * - JSON-stringifiable, or\n * - Not affect observeChanges output (e.g., options.transform functions)\n */\nexport class CursorDescription {\n  collectionName: string;\n  selector: Record<string, any>;\n  options: CursorOptions;\n\n  constructor(collectionName: string, selector: any, options?: CursorOptions) {\n    this.collectionName = collectionName;\n    // @ts-ignore\n    this.selector = Mongo.Collection._rewriteSelector(selector);\n    this.options = options || {};\n  }\n}","import { Meteor } from 'meteor/meteor';\nimport { CLIENT_ONLY_METHODS, getAsyncMethodName } from 'meteor/minimongo/constants';\nimport { MiniMongoQueryError } from 'meteor/minimongo/common';\nimport path from 'path';\nimport { AsynchronousCursor } from './asynchronous_cursor';\nimport { Cursor } from './cursor';\nimport { CursorDescription } from './cursor_description';\nimport { DocFetcher } from './doc_fetcher';\nimport { MongoDB, replaceMeteorAtomWithMongo, replaceTypes, transformResult } from './mongo_common';\nimport { ObserveHandle } from './observe_handle';\nimport { ObserveMultiplexer } from './observe_multiplex';\nimport { OplogObserveDriver } from './oplog_observe_driver';\nimport { OPLOG_COLLECTION, OplogHandle } from './oplog_tailing';\nimport { PollingObserveDriver } from './polling_observe_driver';\n\nconst FILE_ASSET_SUFFIX = 'Asset';\nconst ASSETS_FOLDER = 'assets';\nconst APP_FOLDER = 'app';\n\nconst oplogCollectionWarnings = [];\n\nexport const MongoConnection = function (url, options) {\n  var self = this;\n  options = options || {};\n  self._observeMultiplexers = {};\n  self._onFailoverHook = new Hook;\n\n  const userOptions = {\n    ...(Mongo._connectionOptions || {}),\n    ...(Meteor.settings?.packages?.mongo?.options || {})\n  };\n\n  var mongoOptions = Object.assign({\n    ignoreUndefined: true,\n  }, userOptions);\n\n\n\n  // Internally the oplog connections specify their own maxPoolSize\n  // which we don't want to overwrite with any user defined value\n  if ('maxPoolSize' in options) {\n    // If we just set this for \"server\", replSet will override it. If we just\n    // set it for replSet, it will be ignored if we're not using a replSet.\n    mongoOptions.maxPoolSize = options.maxPoolSize;\n  }\n  if ('minPoolSize' in options) {\n    mongoOptions.minPoolSize = options.minPoolSize;\n  }\n\n  // Transform options like \"tlsCAFileAsset\": \"filename.pem\" into\n  // \"tlsCAFile\": \"/<fullpath>/filename.pem\"\n  Object.entries(mongoOptions || {})\n    .filter(([key]) => key && key.endsWith(FILE_ASSET_SUFFIX))\n    .forEach(([key, value]) => {\n      const optionName = key.replace(FILE_ASSET_SUFFIX, '');\n      mongoOptions[optionName] = path.join(Assets.getServerDir(),\n        ASSETS_FOLDER, APP_FOLDER, value);\n      delete mongoOptions[key];\n    });\n\n  self.db = null;\n  self._oplogHandle = null;\n  self._docFetcher = null;\n\n  mongoOptions.driverInfo = {\n    name: 'Meteor',\n    version: Meteor.release\n  }\n\n  self.client = new MongoDB.MongoClient(url, mongoOptions);\n  self.db = self.client.db();\n\n  self.client.on('serverDescriptionChanged', Meteor.bindEnvironment(event => {\n    // When the connection is no longer against the primary node, execute all\n    // failover hooks. This is important for the driver as it has to re-pool the\n    // query when it happens.\n    if (\n      event.previousDescription.type !== 'RSPrimary' &&\n      event.newDescription.type === 'RSPrimary'\n    ) {\n      self._onFailoverHook.each(callback => {\n        callback();\n        return true;\n      });\n    }\n  }));\n\n  if (options.oplogUrl && ! Package['disable-oplog']) {\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n    self._docFetcher = new DocFetcher(self);\n  }\n\n};\n\nMongoConnection.prototype._close = async function() {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"close called before Connection created?\");\n\n  // XXX probably untested\n  var oplogHandle = self._oplogHandle;\n  self._oplogHandle = null;\n  if (oplogHandle)\n    await oplogHandle.stop();\n\n  // Use Future.wrap so that errors get thrown. This happens to\n  // work even outside a fiber since the 'close' method is not\n  // actually asynchronous.\n  await self.client.close();\n};\n\nMongoConnection.prototype.close = function () {\n  return this._close();\n};\n\nMongoConnection.prototype._setOplogHandle = function(oplogHandle) {\n  this._oplogHandle = oplogHandle;\n  return this;\n};\n\n// Returns the Mongo Collection object; may yield.\nMongoConnection.prototype.rawCollection = function (collectionName) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"rawCollection called before Connection created?\");\n\n  return self.db.collection(collectionName);\n};\n\nMongoConnection.prototype.createCappedCollectionAsync = async function (\n  collectionName, byteSize, maxDocuments) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"createCappedCollectionAsync called before Connection created?\");\n\n\n  await self.db.createCollection(collectionName,\n    { capped: true, size: byteSize, max: maxDocuments });\n};\n\n// This should be called synchronously with a write, to create a\n// transaction on the current write fence, if any. After we can read\n// the write, and after observers have been notified (or at least,\n// after the observer notifiers have added themselves to the write\n// fence), you should call 'committed()' on the object returned.\nMongoConnection.prototype._maybeBeginWrite = function () {\n  const fence = DDPServer._getCurrentFence();\n  if (fence) {\n    return fence.beginWrite();\n  } else {\n    return {committed: function () {}};\n  }\n};\n\n// Internal interface: adds a callback which is called when the Mongo primary\n// changes. Returns a stop handle.\nMongoConnection.prototype._onFailover = function (callback) {\n  return this._onFailoverHook.register(callback);\n};\n\nMongoConnection.prototype.insertAsync = async function (collection_name, document) {\n  const self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    const e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    throw e;\n  }\n\n  if (!(LocalCollection._isPlainObject(document) &&\n    !EJSON._isCustomType(document))) {\n    throw new Error(\"Only plain objects may be inserted into MongoDB\");\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await Meteor.refresh({collection: collection_name, id: document._id });\n  };\n  return self.rawCollection(collection_name).insertOne(\n    replaceTypes(document, replaceMeteorAtomWithMongo),\n    {\n      safe: true,\n    }\n  ).then(async ({insertedId}) => {\n    await refresh();\n    await write.committed();\n    return insertedId;\n  }).catch(async e => {\n    await write.committed();\n    throw e;\n  });\n};\n\n\n// Cause queries that may be affected by the selector to poll in this write\n// fence.\nMongoConnection.prototype._refresh = async function (collectionName, selector) {\n  var refreshKey = {collection: collectionName};\n  // If we know which documents we're removing, don't poll queries that are\n  // specific to other documents. (Note that multiple notifications here should\n  // not cause multiple polls, since all our listener is doing is enqueueing a\n  // poll.)\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    for (const id of specificIds) {\n      await Meteor.refresh(Object.assign({id: id}, refreshKey));\n    };\n  } else {\n    await Meteor.refresh(refreshKey);\n  }\n};\n\nMongoConnection.prototype.removeAsync = async function (collection_name, selector) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    throw e;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await self._refresh(collection_name, selector);\n  };\n\n  return self.rawCollection(collection_name)\n    .deleteMany(replaceTypes(selector, replaceMeteorAtomWithMongo), {\n      safe: true,\n    })\n    .then(async ({ deletedCount }) => {\n      await refresh();\n      await write.committed();\n      return transformResult({ result : {modifiedCount : deletedCount} }).numberAffected;\n    }).catch(async (err) => {\n      await write.committed();\n      throw err;\n    });\n};\n\nMongoConnection.prototype.dropCollectionAsync = async function(collectionName) {\n  var self = this;\n\n\n  var write = self._maybeBeginWrite();\n  var refresh = function() {\n    return Meteor.refresh({\n      collection: collectionName,\n      id: null,\n      dropCollection: true,\n    });\n  };\n\n  return self\n    .rawCollection(collectionName)\n    .drop()\n    .then(async result => {\n      await refresh();\n      await write.committed();\n      return result;\n    })\n    .catch(async e => {\n      await write.committed();\n      throw e;\n    });\n};\n\n// For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n// because it lets the test's fence wait for it to be complete.\nMongoConnection.prototype.dropDatabaseAsync = async function () {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await Meteor.refresh({ dropDatabase: true });\n  };\n\n  try {\n    await self.db._dropDatabase();\n    await refresh();\n    await write.committed();\n  } catch (e) {\n    await write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype.updateAsync = async function (collection_name, selector, mod, options) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e._expectedByTest = true;\n    throw e;\n  }\n\n  // explicit safety check. null and undefined can crash the mongo\n  // driver. Although the node driver and minimongo do 'support'\n  // non-object modifier in that they don't crash, they are not\n  // meaningful operations and do not do anything. Defensively throw an\n  // error here.\n  if (!mod || typeof mod !== 'object') {\n    const error = new Error(\"Invalid modifier. Modifier must be an object.\");\n\n    throw error;\n  }\n\n  if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n    const error = new Error(\n      \"Only plain objects may be used as replacement\" +\n      \" documents in MongoDB\");\n\n    throw error;\n  }\n\n  if (!options) options = {};\n\n  var write = self._maybeBeginWrite();\n  var refresh = async function () {\n    await self._refresh(collection_name, selector);\n  };\n\n  var collection = self.rawCollection(collection_name);\n  var mongoOpts = {safe: true};\n  // Add support for filtered positional operator\n  if (options.arrayFilters !== undefined) mongoOpts.arrayFilters = options.arrayFilters;\n  // explictly enumerate options that minimongo supports\n  if (options.upsert) mongoOpts.upsert = true;\n  if (options.multi) mongoOpts.multi = true;\n  // Lets you get a more more full result from MongoDB. Use with caution:\n  // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n  // with simulated upsert.\n  if (options.fullResult) mongoOpts.fullResult = true;\n\n  var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n  var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n  var isModify = LocalCollection._isModificationMod(mongoMod);\n\n  if (options._forbidReplace && !isModify) {\n    var err = new Error(\"Invalid modifier. Replacements are forbidden.\");\n    throw err;\n  }\n\n  // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n  // selector and mod.  We assume it doesn't matter, as far as\n  // the behavior of modifiers is concerned, whether `_modify`\n  // is run on EJSON or on mongo-converted EJSON.\n\n  // Run this code up front so that it fails fast if someone uses\n  // a Mongo update operator we don't support.\n  let knownId;\n  if (options.upsert) {\n    try {\n      let newDoc = LocalCollection._createUpsertDocument(selector, mod);\n      knownId = newDoc._id;\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (options.upsert &&\n    ! isModify &&\n    ! knownId &&\n    options.insertedId &&\n    ! (options.insertedId instanceof Mongo.ObjectID &&\n      options.generatedId)) {\n    // In case of an upsert with a replacement, where there is no _id defined\n    // in either the query or the replacement doc, mongo will generate an id itself.\n    // Therefore we need this special strategy if we want to control the id ourselves.\n\n    // We don't need to do this when:\n    // - This is not a replacement, so we can add an _id to $setOnInsert\n    // - The id is defined by query or mod we can just add it to the replacement doc\n    // - The user did not specify any id preference and the id is a Mongo ObjectId,\n    //     then we can just let Mongo generate the id\n    return await simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, options)\n      .then(async result => {\n        await refresh();\n        await write.committed();\n        if (result && ! options._returnObject) {\n          return result.numberAffected;\n        } else {\n          return result;\n        }\n      });\n  } else {\n    if (options.upsert && !knownId && options.insertedId && isModify) {\n      if (!mongoMod.hasOwnProperty('$setOnInsert')) {\n        mongoMod.$setOnInsert = {};\n      }\n      knownId = options.insertedId;\n      Object.assign(mongoMod.$setOnInsert, replaceTypes({_id: options.insertedId}, replaceMeteorAtomWithMongo));\n    }\n\n    const strings = Object.keys(mongoMod).filter((key) => !key.startsWith(\"$\"));\n    let updateMethod = strings.length > 0 ? 'replaceOne' : 'updateMany';\n    updateMethod =\n      updateMethod === 'updateMany' && !mongoOpts.multi\n        ? 'updateOne'\n        : updateMethod;\n    return collection[updateMethod]\n      .bind(collection)(mongoSelector, mongoMod, mongoOpts)\n      .then(async result => {\n        var meteorResult = transformResult({result});\n        if (meteorResult && options._returnObject) {\n          // If this was an upsertAsync() call, and we ended up\n          // inserting a new doc and we know its id, then\n          // return that id as well.\n          if (options.upsert && meteorResult.insertedId) {\n            if (knownId) {\n              meteorResult.insertedId = knownId;\n            } else if (meteorResult.insertedId instanceof MongoDB.ObjectId) {\n              meteorResult.insertedId = new Mongo.ObjectID(meteorResult.insertedId.toHexString());\n            }\n          }\n          await refresh();\n          await write.committed();\n          return meteorResult;\n        } else {\n          await refresh();\n          await write.committed();\n          return meteorResult.numberAffected;\n        }\n      }).catch(async (err) => {\n        await write.committed();\n        throw err;\n      });\n  }\n};\n\n// exposed for testing\nMongoConnection._isCannotChangeIdError = function (err) {\n\n  // Mongo 3.2.* returns error as next Object:\n  // {name: String, code: Number, errmsg: String}\n  // Older Mongo returns:\n  // {name: String, code: Number, err: String}\n  var error = err.errmsg || err.err;\n\n  // We don't use the error code here\n  // because the error code we observed it producing (16837) appears to be\n  // a far more generic error code based on examining the source.\n  if (error.indexOf('The _id field cannot be changed') === 0\n    || error.indexOf(\"the (immutable) field '_id' was found to have been altered to _id\") !== -1) {\n    return true;\n  }\n\n  return false;\n};\n\n// XXX MongoConnection.upsertAsync() does not return the id of the inserted document\n// unless you set it explicitly in the selector or modifier (as a replacement\n// doc).\nMongoConnection.prototype.upsertAsync = async function (collectionName, selector, mod, options) {\n  var self = this;\n\n\n\n  if (typeof options === \"function\" && ! callback) {\n    callback = options;\n    options = {};\n  }\n\n  return self.updateAsync(collectionName, selector, mod,\n    Object.assign({}, options, {\n      upsert: true,\n      _returnObject: true\n    }));\n};\n\nMongoConnection.prototype.find = function (collectionName, selector, options) {\n  var self = this;\n\n  if (arguments.length === 1)\n    selector = {};\n\n  return new Cursor(\n    self, new CursorDescription(collectionName, selector, options));\n};\n\nMongoConnection.prototype.findOneAsync = async function (collection_name, selector, options) {\n  var self = this;\n  if (arguments.length === 1) {\n    selector = {};\n  }\n\n  options = options || {};\n  options.limit = 1;\n\n  const results = await self.find(collection_name, selector, options).fetch();\n\n  return results[0];\n};\n\n// We'll actually design an index API later. For now, we just pass through to\n// Mongo's, but make it synchronous.\nMongoConnection.prototype.createIndexAsync = async function (collectionName, index,\n                                                             options) {\n  var self = this;\n\n  // We expect this function to be called at startup, not from within a method,\n  // so we don't interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  await collection.createIndex(index, options);\n};\n\n// just to be consistent with the other methods\nMongoConnection.prototype.createIndex =\n  MongoConnection.prototype.createIndexAsync;\n\nMongoConnection.prototype.countDocuments = function (collectionName, ...args) {\n  args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n  const collection = this.rawCollection(collectionName);\n  return collection.countDocuments(...args);\n};\n\nMongoConnection.prototype.estimatedDocumentCount = function (collectionName, ...args) {\n  args = args.map(arg => replaceTypes(arg, replaceMeteorAtomWithMongo));\n  const collection = this.rawCollection(collectionName);\n  return collection.estimatedDocumentCount(...args);\n};\n\nMongoConnection.prototype.ensureIndexAsync = MongoConnection.prototype.createIndexAsync;\n\nMongoConnection.prototype.dropIndexAsync = async function (collectionName, index) {\n  var self = this;\n\n\n  // This function is only used by test code, not within a method, so we don't\n  // interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var indexName =  await collection.dropIndex(index);\n};\n\n\nCLIENT_ONLY_METHODS.forEach(function (m) {\n  MongoConnection.prototype[m] = function () {\n    throw new Error(\n      `${m} +  is not available on the server. Please use ${getAsyncMethodName(\n        m\n      )}() instead.`\n    );\n  };\n});\n\n\nvar NUM_OPTIMISTIC_TRIES = 3;\n\n\n\nvar simulateUpsertWithInsertedId = async function (collection, selector, mod, options) {\n  // STRATEGY: First try doing an upsert with a generated ID.\n  // If this throws an error about changing the ID on an existing document\n  // then without affecting the database, we know we should probably try\n  // an update without the generated ID. If it affected 0 documents,\n  // then without affecting the database, we the document that first\n  // gave the error is probably removed and we need to try an insert again\n  // We go back to step one and repeat.\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's\n  // unlikely our writes will continue to be interfered with under normal\n  // circumstances (though sufficiently heavy contention with writers\n  // disagreeing on the existence of an object will cause writes to fail\n  // in theory).\n\n  var insertedId = options.insertedId; // must exist\n  var mongoOptsForUpdate = {\n    safe: true,\n    multi: options.multi\n  };\n  var mongoOptsForInsert = {\n    safe: true,\n    upsert: true\n  };\n\n  var replacementWithId = Object.assign(\n    replaceTypes({_id: insertedId}, replaceMeteorAtomWithMongo),\n    mod);\n\n  var tries = NUM_OPTIMISTIC_TRIES;\n\n  var doUpdate = async function () {\n    tries--;\n    if (! tries) {\n      throw new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\");\n    } else {\n      let method = collection.updateMany;\n      if(!Object.keys(mod).some(key => key.startsWith(\"$\"))){\n        method = collection.replaceOne.bind(collection);\n      }\n      return method(\n        selector,\n        mod,\n        mongoOptsForUpdate).then(result => {\n        if (result && (result.modifiedCount || result.upsertedCount)) {\n          return {\n            numberAffected: result.modifiedCount || result.upsertedCount,\n            insertedId: result.upsertedId || undefined,\n          };\n        } else {\n          return doConditionalInsert();\n        }\n      });\n    }\n  };\n\n  var doConditionalInsert = function() {\n    return collection.replaceOne(selector, replacementWithId, mongoOptsForInsert)\n      .then(result => ({\n        numberAffected: result.upsertedCount,\n        insertedId: result.upsertedId,\n      })).catch(err => {\n        if (MongoConnection._isCannotChangeIdError(err)) {\n          return doUpdate();\n        } else {\n          throw err;\n        }\n      });\n\n  };\n  return doUpdate();\n};\n\n// observeChanges for tailable cursors on capped collections.\n//\n// Some differences from normal cursors:\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you\n//     do update a document that has already been produced, this will not notice\n//     it.\n//   - If you disconnect and reconnect from Mongo, it will essentially restart\n//     the query, which will lead to duplicate results. This is pretty bad,\n//     but if you include a field called 'ts' which is inserted as\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n//     current Mongo-style timestamp), we'll be able to find the place to\n//     restart properly. (This field is specifically understood by Mongo with an\n//     optimization which allows it to find the right place to start without\n//     an index on ts. It's how the oplog works.)\n//   - No callbacks are triggered synchronously with the call (there's no\n//     differentiation between \"initial data\" and \"later changes\"; everything\n//     that matches the query gets sent asynchronously).\n//   - De-duplication is not implemented.\n//   - Does not yet interact with the write fence. Probably, this should work by\n//     ignoring removes (which don't work on capped collections) and updates\n//     (which don't affect tailable cursors), and just keeping track of the ID\n//     of the inserted object, and closing the write fence once you get to that\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match\n//     the query, though.  On the other hand, the write fence can close\n//     immediately if it does not match the query. So if we trust minimongo\n//     enough to accurately evaluate the query against the write fence, we\n//     should be able to do this...  Of course, minimongo doesn't even support\n//     Mongo Timestamps yet.\nMongoConnection.prototype._observeChangesTailable = function (\n  cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n  // error if you didn't provide them.\n  if ((ordered && !callbacks.addedBefore) ||\n    (!ordered && !callbacks.added)) {\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\")\n      + \" tailable cursor without a \"\n      + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }\n\n  return self.tail(cursorDescription, function (doc) {\n    var id = doc._id;\n    delete doc._id;\n    // The ts is an implementation detail. Hide it.\n    delete doc.ts;\n    if (ordered) {\n      callbacks.addedBefore(id, doc, null);\n    } else {\n      callbacks.added(id, doc);\n    }\n  });\n};\n\nMongoConnection.prototype._createAsynchronousCursor = function(\n  cursorDescription, options = {}) {\n  var self = this;\n  const { selfForIteration, useTransform } = options;\n  options = { selfForIteration, useTransform };\n\n  var collection = self.rawCollection(cursorDescription.collectionName);\n  var cursorOptions = cursorDescription.options;\n  var mongoOptions = {\n    sort: cursorOptions.sort,\n    limit: cursorOptions.limit,\n    skip: cursorOptions.skip,\n    projection: cursorOptions.fields || cursorOptions.projection,\n    readPreference: cursorOptions.readPreference,\n  };\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    mongoOptions.numberOfRetries = -1;\n  }\n\n  var dbCursor = collection.find(\n    replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo),\n    mongoOptions);\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    // We want a tailable cursor...\n    dbCursor.addCursorFlag(\"tailable\", true)\n    // ... and for the server to wait a bit if any getMore has no data (rather\n    // than making us put the relevant sleeps in the client)...\n    dbCursor.addCursorFlag(\"awaitData\", true)\n\n    // And if this is on the oplog collection and the cursor specifies a 'ts',\n    // then set the undocumented oplog replay flag, which does a special scan to\n    // find the first document (instead of creating an index on ts). This is a\n    // very hard-coded Mongo flag which only works on the oplog collection and\n    // only works with the ts field.\n    if (cursorDescription.collectionName === OPLOG_COLLECTION &&\n      cursorDescription.selector.ts) {\n      dbCursor.addCursorFlag(\"oplogReplay\", true)\n    }\n  }\n\n  if (typeof cursorOptions.maxTimeMs !== 'undefined') {\n    dbCursor = dbCursor.maxTimeMS(cursorOptions.maxTimeMs);\n  }\n  if (typeof cursorOptions.hint !== 'undefined') {\n    dbCursor = dbCursor.hint(cursorOptions.hint);\n  }\n\n  return new AsynchronousCursor(dbCursor, cursorDescription, options, collection);\n};\n\n// Tails the cursor described by cursorDescription, most likely on the\n// oplog. Calls docCallback with each document found. Ignores errors and just\n// restarts the tail on error.\n//\n// If timeoutMS is set, then if we don't get a new document every timeoutMS,\n// kill and restart the cursor. This is primarily a workaround for #8598.\nMongoConnection.prototype.tail = function (cursorDescription, docCallback, timeoutMS) {\n  var self = this;\n  if (!cursorDescription.options.tailable)\n    throw new Error(\"Can only tail a tailable cursor\");\n\n  var cursor = self._createAsynchronousCursor(cursorDescription);\n\n  var stopped = false;\n  var lastTS;\n\n  Meteor.defer(async function loop() {\n    var doc = null;\n    while (true) {\n      if (stopped)\n        return;\n      try {\n        doc = await cursor._nextObjectPromiseWithTimeout(timeoutMS);\n      } catch (err) {\n        // We should not ignore errors here unless we want to spend a lot of time debugging\n        console.error(err);\n        // There's no good way to figure out if this was actually an error from\n        // Mongo, or just client-side (including our own timeout error). Ah\n        // well. But either way, we need to retry the cursor (unless the failure\n        // was because the observe got stopped).\n        doc = null;\n      }\n      // Since we awaited a promise above, we need to check again to see if\n      // we've been stopped before calling the callback.\n      if (stopped)\n        return;\n      if (doc) {\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n        // the oplog, and there's a special flag that lets you do binary search\n        // on it instead of needing to use an index.)\n        lastTS = doc.ts;\n        docCallback(doc);\n      } else {\n        var newSelector = Object.assign({}, cursorDescription.selector);\n        if (lastTS) {\n          newSelector.ts = {$gt: lastTS};\n        }\n        cursor = self._createAsynchronousCursor(new CursorDescription(\n          cursorDescription.collectionName,\n          newSelector,\n          cursorDescription.options));\n        // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n        // setTimeout, we peg the CPU at 100% and never notice the actual\n        // failover.\n        setTimeout(loop, 100);\n        break;\n      }\n    }\n  });\n\n  return {\n    stop: function () {\n      stopped = true;\n      cursor.close();\n    }\n  };\n};\n\nObject.assign(MongoConnection.prototype, {\n  _observeChanges: async function (\n    cursorDescription, ordered, callbacks, nonMutatingCallbacks) {\n    var self = this;\n    const collectionName = cursorDescription.collectionName;\n\n    if (cursorDescription.options.tailable) {\n      return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n    }\n\n    // You may not filter out _id when observing changes, because the id is a core\n    // part of the observeChanges API.\n    const fieldsOptions = cursorDescription.options.projection || cursorDescription.options.fields;\n    if (fieldsOptions &&\n      (fieldsOptions._id === 0 ||\n        fieldsOptions._id === false)) {\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n    }\n\n    var observeKey = EJSON.stringify(\n      Object.assign({ordered: ordered}, cursorDescription));\n\n    var multiplexer, observeDriver;\n    var firstHandle = false;\n\n    // Find a matching ObserveMultiplexer, or create a new one. This next block is\n    // guaranteed to not yield (and it doesn't call anything that can observe a\n    // new query), so no other calls to this function can interleave with it.\n    if (observeKey in self._observeMultiplexers) {\n      multiplexer = self._observeMultiplexers[observeKey];\n    } else {\n      firstHandle = true;\n      // Create a new ObserveMultiplexer.\n      multiplexer = new ObserveMultiplexer({\n        ordered: ordered,\n        onStop: function () {\n          delete self._observeMultiplexers[observeKey];\n          return observeDriver.stop();\n        }\n      });\n    }\n\n    var observeHandle = new ObserveHandle(multiplexer,\n      callbacks,\n      nonMutatingCallbacks,\n    );\n\n    const oplogOptions = self?._oplogHandle?._oplogOptions || {};\n    const { includeCollections, excludeCollections } = oplogOptions;\n    if (firstHandle) {\n\n      var matcher, sorter;\n      var canUseOplog = [\n        function () {\n          // At a bare minimum, using the oplog requires us to have an oplog, to\n          // want unordered callbacks, and to not want a callback on the polls\n          // that won't happen.\n          return self._oplogHandle && !ordered &&\n            !callbacks._testOnlyPollCallback;\n        },\n        function () {\n          // We also need to check, if the collection of this Cursor is actually being \"watched\" by the Oplog handle\n          // if not, we have to fallback to long polling\n          if (excludeCollections?.length && excludeCollections.includes(collectionName)) {\n            if (!oplogCollectionWarnings.includes(collectionName)) {\n              console.warn(`Meteor.settings.packages.mongo.oplogExcludeCollections includes the collection ${collectionName} - your subscriptions will only use long polling!`);\n              oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n            }\n            return false;\n          }\n          if (includeCollections?.length && !includeCollections.includes(collectionName)) {\n            if (!oplogCollectionWarnings.includes(collectionName)) {\n              console.warn(`Meteor.settings.packages.mongo.oplogIncludeCollections does not include the collection ${collectionName} - your subscriptions will only use long polling!`);\n              oplogCollectionWarnings.push(collectionName); // we only want to show the warnings once per collection!\n            }\n            return false;\n          }\n          return true;\n        },\n        function () {\n          // We need to be able to compile the selector. Fall back to polling for\n          // some newfangled $selector that minimongo doesn't support yet.\n          try {\n            matcher = new Minimongo.Matcher(cursorDescription.selector);\n            return true;\n          } catch (e) {\n            // XXX make all compilation errors MinimongoError or something\n            //     so that this doesn't ignore unrelated exceptions\n            if (Meteor.isClient && e instanceof MiniMongoQueryError) {\n              throw e;\n            }\n            return false;\n          }\n        },\n        function () {\n          // ... and the selector itself needs to support oplog.\n          return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n        },\n        function () {\n          // And we need to be able to compile the sort, if any.  eg, can't be\n          // {$natural: 1}.\n          if (!cursorDescription.options.sort)\n            return true;\n          try {\n            sorter = new Minimongo.Sorter(cursorDescription.options.sort);\n            return true;\n          } catch (e) {\n            // XXX make all compilation errors MinimongoError or something\n            //     so that this doesn't ignore unrelated exceptions\n            return false;\n          }\n        }\n      ].every(f => f());  // invoke each function and check if all return true\n\n      var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n      observeDriver = new driverClass({\n        cursorDescription: cursorDescription,\n        mongoHandle: self,\n        multiplexer: multiplexer,\n        ordered: ordered,\n        matcher: matcher,  // ignored by polling\n        sorter: sorter,  // ignored by polling\n        _testOnlyPollCallback: callbacks._testOnlyPollCallback\n      });\n\n      if (observeDriver._init) {\n        await observeDriver._init();\n      }\n\n      // This field is only set for use in tests.\n      multiplexer._observeDriver = observeDriver;\n    }\n    self._observeMultiplexers[observeKey] = multiplexer;\n    // Blocks until the initial adds have been sent.\n    await multiplexer.addHandleAndSendInitialAdds(observeHandle);\n\n    return observeHandle;\n  },\n\n});\n","import clone from 'lodash.clone'\n\n/** @type {import('mongodb')} */\nexport const MongoDB = Object.assign(NpmModuleMongodb, {\n  ObjectID: NpmModuleMongodb.ObjectId,\n});\n\n// The write methods block until the database has confirmed the write (it may\n// not be replicated or stable on disk, but one server has confirmed it) if no\n// callback is provided. If a callback is provided, then they call the callback\n// when the write is confirmed. They return nothing on success, and raise an\n// exception on failure.\n//\n// After making a write (with insert, update, remove), observers are\n// notified asynchronously. If you want to receive a callback once all\n// of the observer notifications have landed for your write, do the\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n// _WriteFence, and then set a callback on the write fence.)\n//\n// Since our execution environment is single-threaded, this is\n// well-defined -- a write \"has been made\" if it's returned, and an\n// observer \"has been notified\" if its callback has returned.\n\nexport const writeCallback = function (write, refresh, callback) {\n  return function (err, result) {\n    if (! err) {\n      // XXX We don't have to run this on error, right?\n      try {\n        refresh();\n      } catch (refreshErr) {\n        if (callback) {\n          callback(refreshErr);\n          return;\n        } else {\n          throw refreshErr;\n        }\n      }\n    }\n    write.committed();\n    if (callback) {\n      callback(err, result);\n    } else if (err) {\n      throw err;\n    }\n  };\n};\n\n\nexport const transformResult = function (driverResult) {\n  var meteorResult = { numberAffected: 0 };\n  if (driverResult) {\n    var mongoResult = driverResult.result;\n    // On updates with upsert:true, the inserted values come as a list of\n    // upserted values -- even with options.multi, when the upsert does insert,\n    // it only inserts one element.\n    if (mongoResult.upsertedCount) {\n      meteorResult.numberAffected = mongoResult.upsertedCount;\n\n      if (mongoResult.upsertedId) {\n        meteorResult.insertedId = mongoResult.upsertedId;\n      }\n    } else {\n      // n was used before Mongo 5.0, in Mongo 5.0 we are not receiving this n\n      // field and so we are using modifiedCount instead\n      meteorResult.numberAffected = mongoResult.n || mongoResult.matchedCount || mongoResult.modifiedCount;\n    }\n  }\n\n  return meteorResult;\n};\n\nexport const replaceMeteorAtomWithMongo = function (document) {\n  if (EJSON.isBinary(document)) {\n    // This does more copies than we'd like, but is necessary because\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n    // serialize it correctly).\n    return new MongoDB.Binary(Buffer.from(document));\n  }\n  if (document instanceof MongoDB.Binary) {\n    return document;\n  }\n  if (document instanceof Mongo.ObjectID) {\n    return new MongoDB.ObjectId(document.toHexString());\n  }\n  if (document instanceof MongoDB.ObjectId) {\n    return new MongoDB.ObjectId(document.toHexString());\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  if (document instanceof Decimal) {\n    return MongoDB.Decimal128.fromString(document.toString());\n  }\n  if (EJSON._isCustomType(document)) {\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n  }\n  // It is not ordinarily possible to stick dollar-sign keys into mongo\n  // so we don't bother checking for things that need escaping at this time.\n  return undefined;\n};\n\nexport const replaceTypes = function (document, atomTransformer) {\n  if (typeof document !== 'object' || document === null)\n    return document;\n\n  var replacedTopLevelAtom = atomTransformer(document);\n  if (replacedTopLevelAtom !== undefined)\n    return replacedTopLevelAtom;\n\n  var ret = document;\n  Object.entries(document).forEach(function ([key, val]) {\n    var valReplaced = replaceTypes(val, atomTransformer);\n    if (val !== valReplaced) {\n      // Lazy clone. Shallow copy.\n      if (ret === document)\n        ret = clone(document);\n      ret[key] = valReplaced;\n    }\n  });\n  return ret;\n};\n\nexport const replaceMongoAtomWithMeteor = function (document) {\n  if (document instanceof MongoDB.Binary) {\n    // for backwards compatibility\n    if (document.sub_type !== 0) {\n      return document;\n    }\n    var buffer = document.value(true);\n    return new Uint8Array(buffer);\n  }\n  if (document instanceof MongoDB.ObjectId) {\n    return new Mongo.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Decimal128) {\n    return Decimal(document.toString());\n  }\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && Object.keys(document).length === 2) {\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  return undefined;\n};\n\nconst makeMongoLegal = name => \"EJSON\" + name;\nconst unmakeMongoLegal = name => name.substr(5);\n\nexport function replaceNames(filter, thing) {\n  if (typeof thing === \"object\" && thing !== null) {\n    if (Array.isArray(thing)) {\n      return thing.map(replaceNames.bind(null, filter));\n    }\n    var ret = {};\n    Object.entries(thing).forEach(function ([key, value]) {\n      ret[filter(key)] = replaceNames(filter, value);\n    });\n    return ret;\n  }\n  return thing;\n}\n","import LocalCollection from 'meteor/minimongo/local_collection';\nimport { replaceMongoAtomWithMeteor, replaceTypes } from './mongo_common';\n\n/**\n * This is just a light wrapper for the cursor. The goal here is to ensure compatibility even if\n * there are breaking changes on the MongoDB driver.\n *\n * This is an internal implementation detail and is created lazily by the main Cursor class.\n */\nexport class AsynchronousCursor {\n  _closing = false;\n  _pendingNext = null;\n  constructor(dbCursor, cursorDescription, options) {\n    this._dbCursor = dbCursor;\n    this._cursorDescription = cursorDescription;\n\n    this._selfForIteration = options.selfForIteration || this;\n    if (options.useTransform && cursorDescription.options.transform) {\n      this._transform = LocalCollection.wrapTransform(\n        cursorDescription.options.transform);\n    } else {\n      this._transform = null;\n    }\n\n    this._visitedIds = new LocalCollection._IdMap;\n  }\n\n  [Symbol.asyncIterator]() {\n    var cursor = this;\n    return {\n      async next() {\n        const value = await cursor._nextObjectPromise();\n        return { done: !value, value };\n      },\n    };\n  }\n\n  // Returns a Promise for the next object from the underlying cursor (before\n  // the Mongo->Meteor type replacement).\n  async _rawNextObjectPromise() {\n    if (this._closing) {\n      // Prevent next() after close is called\n      return null;\n    }\n    try {\n      this._pendingNext = this._dbCursor.next();\n      const result = await this._pendingNext;\n      this._pendingNext = null;\n      return result;\n    } catch (e) {\n      console.error(e);\n    } finally {\n      this._pendingNext = null;\n    }\n  }\n\n  // Returns a Promise for the next object from the cursor, skipping those whose\n  // IDs we've already seen and replacing Mongo atoms with Meteor atoms.\n  async _nextObjectPromise () {\n    while (true) {\n      var doc = await this._rawNextObjectPromise();\n\n      if (!doc) return null;\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n      if (!this._cursorDescription.options.tailable && '_id' in doc) {\n        // Did Mongo give us duplicate documents in the same cursor? If so,\n        // ignore this one. (Do this before the transform, since transform might\n        // return some unrelated value.) We don't do this for tailable cursors,\n        // because we want to maintain O(1) memory usage. And if there isn't _id\n        // for some reason (maybe it's the oplog), then we don't do this either.\n        // (Be careful to do this for falsey but existing _id, though.)\n        if (this._visitedIds.has(doc._id)) continue;\n        this._visitedIds.set(doc._id, true);\n      }\n\n      if (this._transform)\n        doc = this._transform(doc);\n\n      return doc;\n    }\n  }\n\n  // Returns a promise which is resolved with the next object (like with\n  // _nextObjectPromise) or rejected if the cursor doesn't return within\n  // timeoutMS ms.\n  _nextObjectPromiseWithTimeout(timeoutMS) {\n    const nextObjectPromise = this._nextObjectPromise();\n    if (!timeoutMS) {\n      return nextObjectPromise;\n    }\n\n    const timeoutPromise = new Promise(resolve => {\n      // On timeout, close the cursor.\n      const timeoutId = setTimeout(() => {\n        resolve(this.close());\n      }, timeoutMS);\n\n      // If the `_nextObjectPromise` returned first, cancel the timeout.\n      nextObjectPromise.finally(() => {\n        clearTimeout(timeoutId);\n      });\n    });\n\n    return Promise.race([nextObjectPromise, timeoutPromise]);\n  }\n\n  async forEach(callback, thisArg) {\n    // Get back to the beginning.\n    this._rewind();\n\n    let idx = 0;\n    while (true) {\n      const doc = await this._nextObjectPromise();\n      if (!doc) return;\n      await callback.call(thisArg, doc, idx++, this._selfForIteration);\n    }\n  }\n\n  async map(callback, thisArg) {\n    const results = [];\n    await this.forEach(async (doc, index) => {\n      results.push(await callback.call(thisArg, doc, index, this._selfForIteration));\n    });\n\n    return results;\n  }\n\n  _rewind() {\n    // known to be synchronous\n    this._dbCursor.rewind();\n\n    this._visitedIds = new LocalCollection._IdMap;\n  }\n\n  // Mostly usable for tailable cursors.\n  async close() {\n    this._closing = true;\n    // If there's a pending next(), wait for it to finish or abort\n    if (this._pendingNext) {\n      try {\n        await this._pendingNext;\n      } catch (e) {\n        // ignore\n      }\n    }\n    this._dbCursor.close();\n  }\n\n  fetch() {\n    return this.map(doc => doc);\n  }\n\n  /**\n   * FIXME: (node:34680) [MONGODB DRIVER] Warning: cursor.count is deprecated and will be\n   *  removed in the next major version, please use `collection.estimatedDocumentCount` or\n   *  `collection.countDocuments` instead.\n   */\n  count() {\n    return this._dbCursor.count();\n  }\n\n  // This method is NOT wrapped in Cursor.\n  async getRawObjects(ordered) {\n    var self = this;\n    if (ordered) {\n      return self.fetch();\n    } else {\n      var results = new LocalCollection._IdMap;\n      await self.forEach(function (doc) {\n        results.set(doc._id, doc);\n      });\n      return results;\n    }\n  }\n}","import { ASYNC_CURSOR_METHODS, getAsyncMethodName } from 'meteor/minimongo/constants';\nimport { replaceMeteorAtomWithMongo, replaceTypes } from './mongo_common';\nimport LocalCollection from 'meteor/minimongo/local_collection';\nimport { CursorDescription } from './cursor_description';\nimport { ObserveCallbacks, ObserveChangesCallbacks } from './types';\n\ninterface MongoInterface {\n  rawCollection: (collectionName: string) => any;\n  _createAsynchronousCursor: (cursorDescription: CursorDescription, options: CursorOptions) => any;\n  _observeChanges: (cursorDescription: CursorDescription, ordered: boolean, callbacks: any, nonMutatingCallbacks?: boolean) => any;\n}\n\ninterface CursorOptions {\n  selfForIteration: Cursor<any>;\n  useTransform: boolean;\n}\n\n/**\n * @class Cursor\n *\n * The main cursor object returned from find(), implementing the documented\n * Mongo.Collection cursor API.\n *\n * Wraps a CursorDescription and lazily creates an AsynchronousCursor\n * (only contacts MongoDB when methods like fetch or forEach are called).\n */\nexport class Cursor<T, U = T> {\n  public _mongo: MongoInterface;\n  public _cursorDescription: CursorDescription;\n  public _synchronousCursor: any | null;\n\n  constructor(mongo: MongoInterface, cursorDescription: CursorDescription) {\n    this._mongo = mongo;\n    this._cursorDescription = cursorDescription;\n    this._synchronousCursor = null;\n  }\n\n  async countAsync(): Promise<number> {\n    const collection = this._mongo.rawCollection(this._cursorDescription.collectionName);\n    return await collection.countDocuments(\n      replaceTypes(this._cursorDescription.selector, replaceMeteorAtomWithMongo),\n      replaceTypes(this._cursorDescription.options, replaceMeteorAtomWithMongo),\n    );\n  }\n\n  count(): never {\n    throw new Error(\n      \"count() is not available on the server. Please use countAsync() instead.\"\n    );\n  }\n\n  getTransform(): ((doc: any) => any) | undefined {\n    return this._cursorDescription.options.transform;\n  }\n\n  _publishCursor(sub: any): any {\n    const collection = this._cursorDescription.collectionName;\n    return Mongo.Collection._publishCursor(this, sub, collection);\n  }\n\n  _getCollectionName(): string {\n    return this._cursorDescription.collectionName;\n  }\n\n  observe(callbacks: ObserveCallbacks<U>): any {\n    return LocalCollection._observeFromObserveChanges(this, callbacks);\n  }\n\n  async observeAsync(callbacks: ObserveCallbacks<U>): Promise<any> {\n    return new Promise(resolve => resolve(this.observe(callbacks)));\n  }\n\n  observeChanges(callbacks: ObserveChangesCallbacks<U>, options: { nonMutatingCallbacks?: boolean } = {}): any {\n    const ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n    return this._mongo._observeChanges(\n      this._cursorDescription,\n      ordered,\n      callbacks,\n      options.nonMutatingCallbacks\n    );\n  }\n\n  async observeChangesAsync(callbacks: ObserveChangesCallbacks<U>, options: { nonMutatingCallbacks?: boolean } = {}): Promise<any> {\n    return this.observeChanges(callbacks, options);\n  }\n}\n\n// Add cursor methods dynamically\n[...ASYNC_CURSOR_METHODS, Symbol.iterator, Symbol.asyncIterator].forEach(methodName => {\n  if (methodName === 'count') return;\n\n  (Cursor.prototype as any)[methodName] = function(this: Cursor<any>, ...args: any[]): any {\n    const cursor = setupAsynchronousCursor(this, methodName);\n    return cursor[methodName](...args);\n  };\n\n  if (methodName === Symbol.iterator || methodName === Symbol.asyncIterator) return;\n\n  const methodNameAsync = getAsyncMethodName(methodName);\n\n  (Cursor.prototype as any)[methodNameAsync] = function(this: Cursor<any>, ...args: any[]): Promise<any> {\n    return this[methodName](...args);\n  };\n});\n\nfunction setupAsynchronousCursor(cursor: Cursor<any>, method: string | symbol): any {\n  if (cursor._cursorDescription.options.tailable) {\n    throw new Error(`Cannot call ${String(method)} on a tailable cursor`);\n  }\n\n  if (!cursor._synchronousCursor) {\n    cursor._synchronousCursor = cursor._mongo._createAsynchronousCursor(\n      cursor._cursorDescription,\n      {\n        selfForIteration: cursor,\n        useTransform: true,\n      }\n    );\n  }\n\n  return cursor._synchronousCursor;\n}","// singleton\nexport const LocalCollectionDriver = new (class LocalCollectionDriver {\n  constructor() {\n    this.noConnCollections = Object.create(null);\n  }\n\n  open(name, conn) {\n    if (! name) {\n      return new LocalCollection;\n    }\n\n    if (! conn) {\n      return ensureCollection(name, this.noConnCollections);\n    }\n\n    if (! conn._mongo_livedata_collections) {\n      conn._mongo_livedata_collections = Object.create(null);\n    }\n\n    // XXX is there a way to keep track of a connection's collections without\n    // dangling it off the connection object?\n    return ensureCollection(name, conn._mongo_livedata_collections);\n  }\n});\n\nfunction ensureCollection(name, collections) {\n  return (name in collections)\n    ? collections[name]\n    : collections[name] = new LocalCollection(name);\n}\n","import once from 'lodash.once';\nimport {\n  ASYNC_COLLECTION_METHODS,\n  getAsyncMethodName,\n  CLIENT_ONLY_METHODS\n} from \"meteor/minimongo/constants\";\nimport { MongoConnection } from './mongo_connection';\n\n// Define interfaces and types\ninterface IConnectionOptions {\n  oplogUrl?: string;\n  [key: string]: unknown;  // Changed from 'any' to 'unknown' for better type safety\n}\n\ninterface IMongoInternals {\n  RemoteCollectionDriver: typeof RemoteCollectionDriver;\n  defaultRemoteCollectionDriver: () => RemoteCollectionDriver;\n}\n\n// More specific typing for collection methods\ntype MongoMethodFunction = (...args: unknown[]) => unknown;\ninterface ICollectionMethods {\n  [key: string]: MongoMethodFunction;\n}\n\n// Type for MongoConnection\ninterface IMongoClient {\n  connect: () => Promise<void>;\n}\n\ninterface IMongoConnection {\n  client: IMongoClient;\n  [key: string]: MongoMethodFunction | IMongoClient;\n}\n\ndeclare global {\n  namespace NodeJS {\n    interface ProcessEnv {\n      MONGO_URL: string;\n      MONGO_OPLOG_URL?: string;\n    }\n  }\n\n  const MongoInternals: IMongoInternals;\n  const Meteor: {\n    startup: (callback: () => Promise<void>) => void;\n  };\n}\n\nclass RemoteCollectionDriver {\n  private readonly mongo: MongoConnection;\n\n  private static readonly REMOTE_COLLECTION_METHODS = [\n    'createCappedCollectionAsync',\n    'dropIndexAsync',\n    'ensureIndexAsync',\n    'createIndexAsync',\n    'countDocuments',\n    'dropCollectionAsync',\n    'estimatedDocumentCount',\n    'find',\n    'findOneAsync',\n    'insertAsync',\n    'rawCollection',\n    'removeAsync',\n    'updateAsync',\n    'upsertAsync',\n  ] as const;\n\n  constructor(mongoUrl: string, options: IConnectionOptions) {\n    this.mongo = new MongoConnection(mongoUrl, options);\n  }\n\n  public open(name: string): ICollectionMethods {\n    const ret: ICollectionMethods = {};\n\n    // Handle remote collection methods\n    RemoteCollectionDriver.REMOTE_COLLECTION_METHODS.forEach((method) => {\n      // Type assertion needed because we know these methods exist on MongoConnection\n      const mongoMethod = this.mongo[method] as MongoMethodFunction;\n      ret[method] = mongoMethod.bind(this.mongo, name);\n\n      if (!ASYNC_COLLECTION_METHODS.includes(method)) return;\n\n      const asyncMethodName = getAsyncMethodName(method);\n      ret[asyncMethodName] = (...args: unknown[]) => ret[method](...args);\n    });\n\n    // Handle client-only methods\n    CLIENT_ONLY_METHODS.forEach((method) => {\n      ret[method] = (...args: unknown[]): never => {\n        throw new Error(\n          `${method} is not available on the server. Please use ${getAsyncMethodName(\n            method\n          )}() instead.`\n        );\n      };\n    });\n\n    return ret;\n  }\n}\n\n// Assign the class to MongoInternals\nMongoInternals.RemoteCollectionDriver = RemoteCollectionDriver;\n\n// Create the singleton RemoteCollectionDriver only on demand\nMongoInternals.defaultRemoteCollectionDriver = once((): RemoteCollectionDriver => {\n  const connectionOptions: IConnectionOptions = {};\n  const mongoUrl = process.env.MONGO_URL;\n\n  if (!mongoUrl) {\n    throw new Error(\"MONGO_URL must be set in environment\");\n  }\n\n  if (process.env.MONGO_OPLOG_URL) {\n    connectionOptions.oplogUrl = process.env.MONGO_OPLOG_URL;\n  }\n\n  const driver = new RemoteCollectionDriver(mongoUrl, connectionOptions);\n\n  // Initialize database connection on startup\n  Meteor.startup(async (): Promise<void> => {\n    await driver.mongo.client.connect();\n  });\n\n  return driver;\n});\n\nexport { RemoteCollectionDriver, IConnectionOptions, ICollectionMethods };","import { normalizeProjection } from \"../mongo_utils\";\nimport { AsyncMethods } from './methods_async';\nimport { SyncMethods } from './methods_sync';\nimport { IndexMethods } from './methods_index';\nimport {\n  ID_GENERATORS,\n  normalizeOptions,\n  setupAutopublish,\n  setupConnection,\n  setupDriver,\n  setupMutationMethods,\n  validateCollectionName\n} from './collection_utils';\nimport { ReplicationMethods } from './methods_replication';\n\n/**\n * @summary Namespace for MongoDB-related items\n * @namespace\n */\nMongo = {};\n\n/**\n * @summary Constructor for a Collection\n * @locus Anywhere\n * @instancename collection\n * @class\n * @param {String} name The name of the collection.  If null, creates an unmanaged (unsynchronized) local collection.\n * @param {Object} [options]\n * @param {Object} options.connection The server connection that will manage this collection. Uses the default connection if not specified.  Pass the return value of calling [`DDP.connect`](#DDP-connect) to specify a different server. Pass `null` to specify no connection. Unmanaged (`name` is null) collections cannot specify a connection.\n * @param {String} options.idGeneration The method of generating the `_id` fields of new documents in this collection.  Possible values:\n\n - **`'STRING'`**: random strings\n - **`'MONGO'`**:  random [`Mongo.ObjectID`](#mongo_object_id) values\n\nThe default id generation technique is `'STRING'`.\n * @param {Function} options.transform An optional transformation function. Documents will be passed through this function before being returned from `fetch` or `findOneAsync`, and before being passed to callbacks of `observe`, `map`, `forEach`, `allow`, and `deny`. Transforms are *not* applied for the callbacks of `observeChanges` or to cursors returned from publish functions.\n * @param {Boolean} options.defineMutationMethods Set to `false` to skip setting up the mutation methods that enable insert/update/remove from client code. Default `true`.\n */\n// Main Collection constructor\nMongo.Collection = function Collection(name, options) {\n  name = validateCollectionName(name);\n\n  options = normalizeOptions(options);\n\n  this._makeNewID = ID_GENERATORS[options.idGeneration]?.(name);\n\n  this._transform = LocalCollection.wrapTransform(options.transform);\n  this.resolverType = options.resolverType;\n\n  this._connection = setupConnection(name, options);\n\n  const driver = setupDriver(name, this._connection, options);\n  this._driver = driver;\n\n  this._collection = driver.open(name, this._connection);\n  this._name = name;\n\n  this._settingUpReplicationPromise = this._maybeSetUpReplication(name, options);\n\n  setupMutationMethods(this, name, options);\n\n  setupAutopublish(this, name, options);\n\n  Mongo._collections.set(name, this);\n};\n\nObject.assign(Mongo.Collection.prototype, {\n  _getFindSelector(args) {\n    if (args.length == 0) return {};\n    else return args[0];\n  },\n\n  _getFindOptions(args) {\n    const [, options] = args || [];\n    const newOptions = normalizeProjection(options);\n\n    var self = this;\n    if (args.length < 2) {\n      return { transform: self._transform };\n    } else {\n      check(\n        newOptions,\n        Match.Optional(\n          Match.ObjectIncluding({\n            projection: Match.Optional(Match.OneOf(Object, undefined)),\n            sort: Match.Optional(\n              Match.OneOf(Object, Array, Function, undefined)\n            ),\n            limit: Match.Optional(Match.OneOf(Number, undefined)),\n            skip: Match.Optional(Match.OneOf(Number, undefined)),\n          })\n        )\n      );\n\n      return {\n        transform: self._transform,\n        ...newOptions,\n      };\n    }\n  },\n});\n\nObject.assign(Mongo.Collection, {\n  async _publishCursor(cursor, sub, collection) {\n    var observeHandle = await cursor.observeChanges(\n        {\n          added: function(id, fields) {\n            sub.added(collection, id, fields);\n          },\n          changed: function(id, fields) {\n            sub.changed(collection, id, fields);\n          },\n          removed: function(id) {\n            sub.removed(collection, id);\n          },\n        },\n        // Publications don't mutate the documents\n        // This is tested by the `livedata - publish callbacks clone` test\n        { nonMutatingCallbacks: true }\n    );\n\n    // We don't call sub.ready() here: it gets called in livedata_server, after\n    // possibly calling _publishCursor on multiple returned cursors.\n\n    // register stop callback (expects lambda w/ no args).\n    sub.onStop(async function() {\n      return await observeHandle.stop();\n    });\n\n    // return the observeHandle in case it needs to be stopped early\n    return observeHandle;\n  },\n\n  // protect against dangerous selectors.  falsey and {_id: falsey} are both\n  // likely programmer error, and not what you want, particularly for destructive\n  // operations. If a falsey _id is sent in, a new string _id will be\n  // generated and returned; if a fallbackId is provided, it will be returned\n  // instead.\n  _rewriteSelector(selector, { fallbackId } = {}) {\n    // shorthand -- scalars match _id\n    if (LocalCollection._selectorIsId(selector)) selector = { _id: selector };\n\n    if (Array.isArray(selector)) {\n      // This is consistent with the Mongo console itself; if we don't do this\n      // check passing an empty array ends up selecting all items\n      throw new Error(\"Mongo selector can't be an array.\");\n    }\n\n    if (!selector || ('_id' in selector && !selector._id)) {\n      // can't match anything\n      return { _id: fallbackId || Random.id() };\n    }\n\n    return selector;\n  },\n});\n\nObject.assign(Mongo.Collection.prototype, ReplicationMethods, SyncMethods, AsyncMethods, IndexMethods);\n\nObject.assign(Mongo.Collection.prototype, {\n  // Determine if this collection is simply a minimongo representation of a real\n  // database on another server\n  _isRemoteCollection() {\n    // XXX see #MeteorServerNull\n    return this._connection && this._connection !== Meteor.server;\n  },\n\n  async dropCollectionAsync() {\n    var self = this;\n    if (!self._collection.dropCollectionAsync)\n      throw new Error('Can only call dropCollectionAsync on server collections');\n   await self._collection.dropCollectionAsync();\n  },\n\n  async createCappedCollectionAsync(byteSize, maxDocuments) {\n    var self = this;\n    if (! await self._collection.createCappedCollectionAsync)\n      throw new Error(\n        'Can only call createCappedCollectionAsync on server collections'\n      );\n    await self._collection.createCappedCollectionAsync(byteSize, maxDocuments);\n  },\n\n  /**\n   * @summary Returns the [`Collection`](http://mongodb.github.io/node-mongodb-native/3.0/api/Collection.html) object corresponding to this collection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n   * @locus Server\n   * @memberof Mongo.Collection\n   * @instance\n   */\n  rawCollection() {\n    var self = this;\n    if (!self._collection.rawCollection) {\n      throw new Error('Can only call rawCollection on server collections');\n    }\n    return self._collection.rawCollection();\n  },\n\n  /**\n   * @summary Returns the [`Db`](http://mongodb.github.io/node-mongodb-native/3.0/api/Db.html) object corresponding to this collection's database connection from the [npm `mongodb` driver module](https://www.npmjs.com/package/mongodb) which is wrapped by `Mongo.Collection`.\n   * @locus Server\n   * @memberof Mongo.Collection\n   * @instance\n   */\n  rawDatabase() {\n    var self = this;\n    if (!(self._driver.mongo && self._driver.mongo.db)) {\n      throw new Error('Can only call rawDatabase on server collections');\n    }\n    return self._driver.mongo.db;\n  },\n});\n\nObject.assign(Mongo, {\n  /**\n   * @summary Retrieve a Meteor collection instance by name. Only collections defined with [`new Mongo.Collection(...)`](#collections) are available with this method. For plain MongoDB collections, you'll want to look at [`rawDatabase()`](#Mongo-Collection-rawDatabase).\n   * @locus Anywhere\n   * @memberof Mongo\n   * @static\n   * @param {string} name Name of your collection as it was defined with `new Mongo.Collection()`.\n   * @returns {Mongo.Collection | undefined}\n   */\n  getCollection(name) {\n    return this._collections.get(name);\n  },\n\n  /**\n   * @summary A record of all defined Mongo.Collection instances, indexed by collection name.\n   * @type {Map<string, Mongo.Collection>}\n   * @memberof Mongo\n   * @protected\n   */\n  _collections: new Map(),\n})\n\n\n\n/**\n * @summary Create a Mongo-style `ObjectID`.  If you don't specify a `hexString`, the `ObjectID` will be generated randomly (not using MongoDB's ID construction rules).\n * @locus Anywhere\n * @class\n * @param {String} [hexString] Optional.  The 24-character hexadecimal contents of the ObjectID to create\n */\nMongo.ObjectID = MongoID.ObjectID;\n\n/**\n * @summary To create a cursor, use find. To access the documents in a cursor, use forEach, map, or fetch.\n * @class\n * @instanceName cursor\n */\nMongo.Cursor = LocalCollection.Cursor;\n\n/**\n * @deprecated in 0.9.1\n */\nMongo.Collection.Cursor = Mongo.Cursor;\n\n/**\n * @deprecated in 0.9.1\n */\nMongo.Collection.ObjectID = Mongo.ObjectID;\n\n/**\n * @deprecated in 0.9.1\n */\nMeteor.Collection = Mongo.Collection;\n\n\n// Allow deny stuff is now in the allow-deny package\nObject.assign(Mongo.Collection.prototype, AllowDeny.CollectionPrototype);\n","export const ID_GENERATORS = {\n  MONGO(name) {\n    return function() {\n      const src = name ? DDP.randomStream('/collection/' + name) : Random.insecure;\n      return new Mongo.ObjectID(src.hexString(24));\n    }\n  },\n  STRING(name) {\n    return function() {\n      const src = name ? DDP.randomStream('/collection/' + name) : Random.insecure;\n      return src.id();\n    }\n  }\n};\n\nexport function setupConnection(name, options) {\n  if (!name || options.connection === null) return null;\n  if (options.connection) return options.connection;\n  return Meteor.isClient ? Meteor.connection : Meteor.server;\n}\n\nexport function setupDriver(name, connection, options) {\n  if (options._driver) return options._driver;\n\n  if (name &&\n    connection === Meteor.server &&\n    typeof MongoInternals !== 'undefined' &&\n    MongoInternals.defaultRemoteCollectionDriver) {\n    return MongoInternals.defaultRemoteCollectionDriver();\n  }\n\n  const { LocalCollectionDriver } = require('../local_collection_driver.js');\n  return LocalCollectionDriver;\n}\n\nexport function setupAutopublish(collection, name, options) {\n  if (Package.autopublish &&\n    !options._preventAutopublish &&\n    collection._connection &&\n    collection._connection.publish) {\n    collection._connection.publish(null, () => collection.find(), {\n      is_auto: true\n    });\n  }\n}\n\nexport function setupMutationMethods(collection, name, options) {\n  if (options.defineMutationMethods === false) return;\n\n  try {\n    collection._defineMutationMethods({\n      useExisting: options._suppressSameNameError === true\n    });\n  } catch (error) {\n    if (error.message === `A method named '/${name}/insertAsync' is already defined`) {\n      throw new Error(`There is already a collection named \"${name}\"`);\n    }\n    throw error;\n  }\n}\n\nexport function validateCollectionName(name) {\n  if (!name && name !== null) {\n    Meteor._debug(\n      'Warning: creating anonymous collection. It will not be ' +\n      'saved or synchronized over the network. (Pass null for ' +\n      'the collection name to turn off this warning.)'\n    );\n    name = null;\n  }\n\n  if (name !== null && typeof name !== 'string') {\n    throw new Error(\n      'First argument to new Mongo.Collection must be a string or null'\n    );\n  }\n\n  return name;\n}\n\nexport function normalizeOptions(options) {\n  if (options && options.methods) {\n    // Backwards compatibility hack with original signature\n    options = { connection: options };\n  }\n  // Backwards compatibility: \"connection\" used to be called \"manager\".\n  if (options && options.manager && !options.connection) {\n    options.connection = options.manager;\n  }\n\n  const cleanedOptions = Object.fromEntries(\n    Object.entries(options || {}).filter(([_, v]) => v !== undefined),\n  );\n\n  // 2) Spread defaults first, then only the defined overrides\n  return {\n    connection: undefined,\n    idGeneration: 'STRING',\n    transform: null,\n    _driver: undefined,\n    _preventAutopublish: false,\n    ...cleanedOptions,\n  };\n}\n","export const AsyncMethods = {\n  /**\n   * @summary Finds the first document that matches the selector, as ordered by sort and skip options. Returns `undefined` if no matching document is found.\n   * @locus Anywhere\n   * @method findOneAsync\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} [selector] A query describing the documents to find\n   * @param {Object} [options]\n   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n   * @param {Number} options.skip Number of results to skip at the beginning\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n   * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity\n   * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n   * @param {String} options.readPreference (Server only) Specifies a custom MongoDB [`readPreference`](https://docs.mongodb.com/manual/core/read-preference) for fetching the document. Possible values are `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred` and `nearest`.\n   * @returns {Object}\n   */\n  findOneAsync(...args) {\n    return this._collection.findOneAsync(\n      this._getFindSelector(args),\n      this._getFindOptions(args)\n    );\n  },\n\n  _insertAsync(doc, options = {}) {\n    // Make sure we were passed a document to insert\n    if (!doc) {\n      throw new Error('insert requires an argument');\n    }\n\n    // Make a shallow clone of the document, preserving its prototype.\n    doc = Object.create(\n      Object.getPrototypeOf(doc),\n      Object.getOwnPropertyDescriptors(doc)\n    );\n\n    if ('_id' in doc) {\n      if (\n        !doc._id ||\n        !(typeof doc._id === 'string' || doc._id instanceof Mongo.ObjectID)\n      ) {\n        throw new Error(\n          'Meteor requires document _id fields to be non-empty strings or ObjectIDs'\n        );\n      }\n    } else {\n      let generateId = true;\n\n      // Don't generate the id if we're the client and the 'outermost' call\n      // This optimization saves us passing both the randomSeed and the id\n      // Passing both is redundant.\n      if (this._isRemoteCollection()) {\n        const enclosing = DDP._CurrentMethodInvocation.get();\n        if (!enclosing) {\n          generateId = false;\n        }\n      }\n\n      if (generateId) {\n        doc._id = this._makeNewID();\n      }\n    }\n\n    // On inserts, always return the id that we generated; on all other\n    // operations, just return the result from the collection.\n    var chooseReturnValueFromCollectionResult = function(result) {\n      if (Meteor._isPromise(result)) return result;\n\n      if (doc._id) {\n        return doc._id;\n      }\n\n      // XXX what is this for??\n      // It's some iteraction between the callback to _callMutatorMethod and\n      // the return value conversion\n      doc._id = result;\n\n      return result;\n    };\n\n    if (this._isRemoteCollection()) {\n      const promise = this._callMutatorMethodAsync('insertAsync', [doc], options);\n      promise.then(chooseReturnValueFromCollectionResult);\n      promise.stubPromise = promise.stubPromise.then(chooseReturnValueFromCollectionResult);\n      promise.serverPromise = promise.serverPromise.then(chooseReturnValueFromCollectionResult);\n      return promise;\n    }\n\n    // it's my collection.  descend into the collection object\n    // and propagate any exception.\n    return this._collection.insertAsync(doc)\n      .then(chooseReturnValueFromCollectionResult);\n  },\n\n  /**\n   * @summary Insert a document in the collection.  Returns a promise that will return the document's unique _id when solved.\n   * @locus Anywhere\n   * @method  insert\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.\n   */\n  insertAsync(doc, options) {\n    return this._insertAsync(doc, options);\n  },\n\n\n  /**\n   * @summary Modify one or more documents in the collection. Returns the number of matched documents.\n   * @locus Anywhere\n   * @method update\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to modify\n   * @param {MongoModifier} modifier Specifies how to modify the documents\n   * @param {Object} [options]\n   * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n   * @param {Boolean} options.upsert True to insert a document if no matching documents are found.\n   * @param {Array} options.arrayFilters Optional. Used in combination with MongoDB [filtered positional operator](https://docs.mongodb.com/manual/reference/operator/update/positional-filtered/) to specify which elements to modify in an array field.\n   */\n  updateAsync(selector, modifier, ...optionsAndCallback) {\n\n    // We've already popped off the callback, so we are left with an array\n    // of one or zero items\n    const options = { ...(optionsAndCallback[0] || null) };\n    let insertedId;\n    if (options && options.upsert) {\n      // set `insertedId` if absent.  `insertedId` is a Meteor extension.\n      if (options.insertedId) {\n        if (\n          !(\n            typeof options.insertedId === 'string' ||\n            options.insertedId instanceof Mongo.ObjectID\n          )\n        )\n          throw new Error('insertedId must be string or ObjectID');\n        insertedId = options.insertedId;\n      } else if (!selector || !selector._id) {\n        insertedId = this._makeNewID();\n        options.generatedId = true;\n        options.insertedId = insertedId;\n      }\n    }\n\n    selector = Mongo.Collection._rewriteSelector(selector, {\n      fallbackId: insertedId,\n    });\n\n    if (this._isRemoteCollection()) {\n      const args = [selector, modifier, options];\n\n      return this._callMutatorMethodAsync('updateAsync', args, options);\n    }\n\n    // it's my collection.  descend into the collection object\n    // and propagate any exception.\n    // If the user provided a callback and the collection implements this\n    // operation asynchronously, then queryRet will be undefined, and the\n    // result will be returned through the callback instead.\n\n    return this._collection.updateAsync(\n      selector,\n      modifier,\n      options\n    );\n  },\n\n  /**\n   * @summary Asynchronously removes documents from the collection.\n   * @locus Anywhere\n   * @method remove\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to remove\n   */\n  removeAsync(selector, options = {}) {\n    selector = Mongo.Collection._rewriteSelector(selector);\n\n    if (this._isRemoteCollection()) {\n      return this._callMutatorMethodAsync('removeAsync', [selector], options);\n    }\n\n    // it's my collection.  descend into the collection1 object\n    // and propagate any exception.\n    return this._collection.removeAsync(selector);\n  },\n\n  /**\n   * @summary Asynchronously modifies one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).\n   * @locus Anywhere\n   * @method upsert\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to modify\n   * @param {MongoModifier} modifier Specifies how to modify the documents\n   * @param {Object} [options]\n   * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n   */\n  async upsertAsync(selector, modifier, options) {\n    return this.updateAsync(\n      selector,\n      modifier,\n      {\n        ...options,\n        _returnObject: true,\n        upsert: true,\n      });\n  },\n\n  /**\n   * @summary Gets the number of documents matching the filter. For a fast count of the total documents in a collection see `estimatedDocumentCount`.\n   * @locus Anywhere\n   * @method countDocuments\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} [selector] A query describing the documents to count\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://mongodb.github.io/node-mongodb-native/4.11/interfaces/CountDocumentsOptions.html). Please note that not all of them are available on the client.\n   * @returns {Promise<number>}\n   */\n  countDocuments(...args) {\n    return this._collection.countDocuments(...args);\n  },\n\n  /**\n   * @summary Gets an estimate of the count of documents in a collection using collection metadata. For an exact count of the documents in a collection see `countDocuments`.\n   * @locus Anywhere\n   * @method estimatedDocumentCount\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://mongodb.github.io/node-mongodb-native/4.11/interfaces/EstimatedDocumentCountOptions.html). Please note that not all of them are available on the client.\n   * @returns {Promise<number>}\n   */\n  estimatedDocumentCount(...args) {\n    return this._collection.estimatedDocumentCount(...args);\n  },\n}","import { Log } from 'meteor/logging';\n\nexport const IndexMethods = {\n  // We'll actually design an index API later. For now, we just pass through to\n  // Mongo's, but make it synchronous.\n  /**\n   * @summary Asynchronously creates the specified index on the collection.\n   * @locus server\n   * @method ensureIndexAsync\n   * @deprecated in 3.0\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} index A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field. For an ascending index on a field, specify a value of `1`; for descending index, specify a value of `-1`. Use `text` for text indexes.\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#options)\n   * @param {String} options.name Name of the index\n   * @param {Boolean} options.unique Define that the index values must be unique, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-unique/)\n   * @param {Boolean} options.sparse Define that the index is sparse, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-sparse/)\n   */\n  async ensureIndexAsync(index, options) {\n    var self = this;\n    if (!self._collection.ensureIndexAsync || !self._collection.createIndexAsync)\n      throw new Error('Can only call createIndexAsync on server collections');\n    if (self._collection.createIndexAsync) {\n      await self._collection.createIndexAsync(index, options);\n    } else {\n      Log.debug(`ensureIndexAsync has been deprecated, please use the new 'createIndexAsync' instead${ options?.name ? `, index name: ${ options.name }` : `, index: ${ JSON.stringify(index) }` }`)\n      await self._collection.ensureIndexAsync(index, options);\n    }\n  },\n\n  /**\n   * @summary Asynchronously creates the specified index on the collection.\n   * @locus server\n   * @method createIndexAsync\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} index A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field. For an ascending index on a field, specify a value of `1`; for descending index, specify a value of `-1`. Use `text` for text indexes.\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#options)\n   * @param {String} options.name Name of the index\n   * @param {Boolean} options.unique Define that the index values must be unique, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-unique/)\n   * @param {Boolean} options.sparse Define that the index is sparse, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-sparse/)\n   */\n  async createIndexAsync(index, options) {\n    var self = this;\n    if (!self._collection.createIndexAsync)\n      throw new Error('Can only call createIndexAsync on server collections');\n\n    try {\n      await self._collection.createIndexAsync(index, options);\n    } catch (e) {\n      if (\n        e.message.includes(\n          'An equivalent index already exists with the same name but different options.'\n        ) &&\n        Meteor.settings?.packages?.mongo?.reCreateIndexOnOptionMismatch\n      ) {\n        Log.info(`Re-creating index ${ index } for ${ self._name } due to options mismatch.`);\n        await self._collection.dropIndexAsync(index);\n        await self._collection.createIndexAsync(index, options);\n      } else {\n        console.error(e);\n        throw new Meteor.Error(`An error occurred when creating an index for collection \"${ self._name }: ${ e.message }`);\n      }\n    }\n  },\n\n  /**\n   * @summary Asynchronously creates the specified index on the collection.\n   * @locus server\n   * @method createIndex\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} index A document that contains the field and value pairs where the field is the index key and the value describes the type of index for that field. For an ascending index on a field, specify a value of `1`; for descending index, specify a value of `-1`. Use `text` for text indexes.\n   * @param {Object} [options] All options are listed in [MongoDB documentation](https://docs.mongodb.com/manual/reference/method/db.collection.createIndex/#options)\n   * @param {String} options.name Name of the index\n   * @param {Boolean} options.unique Define that the index values must be unique, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-unique/)\n   * @param {Boolean} options.sparse Define that the index is sparse, more at [MongoDB documentation](https://docs.mongodb.com/manual/core/index-sparse/)\n   */\n  createIndex(index, options){\n    return this.createIndexAsync(index, options);\n  },\n\n  async dropIndexAsync(index) {\n    var self = this;\n    if (!self._collection.dropIndexAsync)\n      throw new Error('Can only call dropIndexAsync on server collections');\n    await self._collection.dropIndexAsync(index);\n  },\n}\n","export const ReplicationMethods = {\n  async _maybeSetUpReplication(name) {\n    const self = this;\n    if (\n      !(\n        self._connection &&\n        self._connection.registerStoreClient &&\n        self._connection.registerStoreServer\n      )\n    ) {\n      return;\n    }\n\n\n    const wrappedStoreCommon = {\n      // Called around method stub invocations to capture the original versions\n      // of modified documents.\n      saveOriginals() {\n        self._collection.saveOriginals();\n      },\n      retrieveOriginals() {\n        return self._collection.retrieveOriginals();\n      },\n      // To be able to get back to the collection from the store.\n      _getCollection() {\n        return self;\n      },\n    };\n    const wrappedStoreClient = {\n      // Called at the beginning of a batch of updates. batchSize is the number\n      // of update calls to expect.\n      //\n      // XXX This interface is pretty janky. reset probably ought to go back to\n      // being its own function, and callers shouldn't have to calculate\n      // batchSize. The optimization of not calling pause/remove should be\n      // delayed until later: the first call to update() should buffer its\n      // message, and then we can either directly apply it at endUpdate time if\n      // it was the only update, or do pauseObservers/apply/apply at the next\n      // update() if there's another one.\n      async beginUpdate(batchSize, reset) {\n        // pause observers so users don't see flicker when updating several\n        // objects at once (including the post-reconnect reset-and-reapply\n        // stage), and so that a re-sorting of a query can take advantage of the\n        // full _diffQuery moved calculation instead of applying change one at a\n        // time.\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.remove({});\n      },\n\n      // Apply an update.\n      // XXX better specify this interface (not in terms of a wire message)?\n      update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        //When the server's mergebox is disabled for a collection, the client must gracefully handle it when:\n        // *We receive an added message for a document that is already there. Instead, it will be changed\n        // *We reeive a change message for a document that is not there. Instead, it will be added\n        // *We receive a removed messsage for a document that is not there. Instead, noting wil happen.\n\n        //Code is derived from client-side code originally in peerlibrary:control-mergebox\n        //https://github.com/peerlibrary/meteor-control-mergebox/blob/master/client.coffee\n\n        //For more information, refer to discussion \"Initial support for publication strategies in livedata server\":\n        //https://github.com/meteor/meteor/pull/11151\n        if (Meteor.isClient) {\n          if (msg.msg === 'added' && doc) {\n            msg.msg = 'changed';\n          } else if (msg.msg === 'removed' && !doc) {\n            return;\n          } else if (msg.msg === 'changed' && !doc) {\n            msg.msg = 'added';\n            const _ref = msg.fields;\n            for (let field in _ref) {\n              const value = _ref[field];\n              if (value === void 0) {\n                delete msg.fields[field];\n              }\n            }\n          }\n        }\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) self._collection.remove(mongoId);\n          } else if (!doc) {\n            self._collection.insert(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            self._collection.update(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          self._collection.insert({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          self._collection.remove(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              self._collection.update(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.livedata_connection.js:1287\n      endUpdate() {\n        self._collection.resumeObserversClient();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      getDoc(id) {\n        return self.findOne(id);\n      },\n\n      ...wrappedStoreCommon,\n    };\n    const wrappedStoreServer = {\n      async beginUpdate(batchSize, reset) {\n        if (batchSize > 1 || reset) self._collection.pauseObservers();\n\n        if (reset) await self._collection.removeAsync({});\n      },\n\n      async update(msg) {\n        var mongoId = MongoID.idParse(msg.id);\n        var doc = self._collection._docs.get(mongoId);\n\n        // Is this a \"replace the whole doc\" message coming from the quiescence\n        // of method writes to an object? (Note that 'undefined' is a valid\n        // value meaning \"remove it\".)\n        if (msg.msg === 'replace') {\n          var replace = msg.replace;\n          if (!replace) {\n            if (doc) await self._collection.removeAsync(mongoId);\n          } else if (!doc) {\n            await self._collection.insertAsync(replace);\n          } else {\n            // XXX check that replace has no $ ops\n            await self._collection.updateAsync(mongoId, replace);\n          }\n          return;\n        } else if (msg.msg === 'added') {\n          if (doc) {\n            throw new Error(\n              'Expected not to find a document already present for an add'\n            );\n          }\n          await self._collection.insertAsync({ _id: mongoId, ...msg.fields });\n        } else if (msg.msg === 'removed') {\n          if (!doc)\n            throw new Error(\n              'Expected to find a document already present for removed'\n            );\n          await self._collection.removeAsync(mongoId);\n        } else if (msg.msg === 'changed') {\n          if (!doc) throw new Error('Expected to find a document to change');\n          const keys = Object.keys(msg.fields);\n          if (keys.length > 0) {\n            var modifier = {};\n            keys.forEach(key => {\n              const value = msg.fields[key];\n              if (EJSON.equals(doc[key], value)) {\n                return;\n              }\n              if (typeof value === 'undefined') {\n                if (!modifier.$unset) {\n                  modifier.$unset = {};\n                }\n                modifier.$unset[key] = 1;\n              } else {\n                if (!modifier.$set) {\n                  modifier.$set = {};\n                }\n                modifier.$set[key] = value;\n              }\n            });\n            if (Object.keys(modifier).length > 0) {\n              await self._collection.updateAsync(mongoId, modifier);\n            }\n          }\n        } else {\n          throw new Error(\"I don't know how to deal with this message\");\n        }\n      },\n\n      // Called at the end of a batch of updates.\n      async endUpdate() {\n        await self._collection.resumeObserversServer();\n      },\n\n      // Used to preserve current versions of documents across a store reset.\n      async getDoc(id) {\n        return self.findOneAsync(id);\n      },\n      ...wrappedStoreCommon,\n    };\n\n\n    // OK, we're going to be a slave, replicating some remote\n    // database, except possibly with some temporary divergence while\n    // we have unacknowledged RPC's.\n    let registerStoreResult;\n    if (Meteor.isClient) {\n      registerStoreResult = self._connection.registerStoreClient(\n        name,\n        wrappedStoreClient\n      );\n    } else {\n      registerStoreResult = self._connection.registerStoreServer(\n        name,\n        wrappedStoreServer\n      );\n    }\n\n    const message = `There is already a collection named \"${name}\"`;\n    const logWarn = () => {\n      console.warn ? console.warn(message) : console.log(message);\n    };\n\n    if (!registerStoreResult) {\n      return logWarn();\n    }\n\n    return registerStoreResult?.then?.(ok => {\n      if (!ok) {\n        logWarn();\n      }\n    });\n  },\n}","export const SyncMethods = {\n  /**\n   * @summary Find the documents in a collection that match the selector.\n   * @locus Anywhere\n   * @method find\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} [selector] A query describing the documents to find\n   * @param {Object} [options]\n   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n   * @param {Number} options.skip Number of results to skip at the beginning\n   * @param {Number} options.limit Maximum number of results to return\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n   * @param {Boolean} options.reactive (Client only) Default `true`; pass `false` to disable reactivity\n   * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n   * @param {Boolean} options.disableOplog (Server only) Pass true to disable oplog-tailing on this query. This affects the way server processes calls to `observe` on this query. Disabling the oplog can be useful when working with data that updates in large batches.\n   * @param {Number} options.pollingIntervalMs (Server only) When oplog is disabled (through the use of `disableOplog` or when otherwise not available), the frequency (in milliseconds) of how often to poll this query when observing on the server. Defaults to 10000ms (10 seconds).\n   * @param {Number} options.pollingThrottleMs (Server only) When oplog is disabled (through the use of `disableOplog` or when otherwise not available), the minimum time (in milliseconds) to allow between re-polling when observing on the server. Increasing this will save CPU and mongo load at the expense of slower updates to users. Decreasing this is not recommended. Defaults to 50ms.\n   * @param {Number} options.maxTimeMs (Server only) If set, instructs MongoDB to set a time limit for this cursor's operations. If the operation reaches the specified time limit (in milliseconds) without the having been completed, an exception will be thrown. Useful to prevent an (accidental or malicious) unoptimized query from causing a full collection scan that would disrupt other database users, at the expense of needing to handle the resulting error.\n   * @param {String|Object} options.hint (Server only) Overrides MongoDB's default index selection and query optimization process. Specify an index to force its use, either by its name or index specification. You can also specify `{ $natural : 1 }` to force a forwards collection scan, or `{ $natural : -1 }` for a reverse collection scan. Setting this is only recommended for advanced users.\n   * @param {String} options.readPreference (Server only) Specifies a custom MongoDB [`readPreference`](https://docs.mongodb.com/manual/core/read-preference) for this particular cursor. Possible values are `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred` and `nearest`.\n   * @returns {Mongo.Cursor}\n   */\n  find(...args) {\n    // Collection.find() (return all docs) behaves differently\n    // from Collection.find(undefined) (return 0 docs).  so be\n    // careful about the length of arguments.\n    return this._collection.find(\n      this._getFindSelector(args),\n      this._getFindOptions(args)\n    );\n  },\n\n  /**\n   * @summary Finds the first document that matches the selector, as ordered by sort and skip options. Returns `undefined` if no matching document is found.\n   * @locus Anywhere\n   * @method findOne\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} [selector] A query describing the documents to find\n   * @param {Object} [options]\n   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)\n   * @param {Number} options.skip Number of results to skip at the beginning\n   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.\n   * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity\n   * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.\n   * @param {String} options.readPreference (Server only) Specifies a custom MongoDB [`readPreference`](https://docs.mongodb.com/manual/core/read-preference) for fetching the document. Possible values are `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred` and `nearest`.\n   * @returns {Object}\n   */\n  findOne(...args) {\n    return this._collection.findOne(\n      this._getFindSelector(args),\n      this._getFindOptions(args)\n    );\n  },\n\n\n  // 'insert' immediately returns the inserted document's new _id.\n  // The others return values immediately if you are in a stub, an in-memory\n  // unmanaged collection, or a mongo-backed collection and you don't pass a\n  // callback. 'update' and 'remove' return the number of affected\n  // documents. 'upsert' returns an object with keys 'numberAffected' and, if an\n  // insert happened, 'insertedId'.\n  //\n  // Otherwise, the semantics are exactly like other methods: they take\n  // a callback as an optional last argument; if no callback is\n  // provided, they block until the operation is complete, and throw an\n  // exception if it fails; if a callback is provided, then they don't\n  // necessarily block, and they call the callback when they finish with error and\n  // result arguments.  (The insert method provides the document ID as its result;\n  // update and remove provide the number of affected docs as the result; upsert\n  // provides an object with numberAffected and maybe insertedId.)\n  //\n  // On the client, blocking is impossible, so if a callback\n  // isn't provided, they just return immediately and any error\n  // information is lost.\n  //\n  // There's one more tweak. On the client, if you don't provide a\n  // callback, then if there is an error, a message will be logged with\n  // Meteor._debug.\n  //\n  // The intent (though this is actually determined by the underlying\n  // drivers) is that the operations should be done synchronously, not\n  // generating their result until the database has acknowledged\n  // them. In the future maybe we should provide a flag to turn this\n  // off.\n\n  _insert(doc, callback) {\n    // Make sure we were passed a document to insert\n    if (!doc) {\n      throw new Error('insert requires an argument');\n    }\n\n\n    // Make a shallow clone of the document, preserving its prototype.\n    doc = Object.create(\n      Object.getPrototypeOf(doc),\n      Object.getOwnPropertyDescriptors(doc)\n    );\n\n    if ('_id' in doc) {\n      if (\n        !doc._id ||\n        !(typeof doc._id === 'string' || doc._id instanceof Mongo.ObjectID)\n      ) {\n        throw new Error(\n          'Meteor requires document _id fields to be non-empty strings or ObjectIDs'\n        );\n      }\n    } else {\n      let generateId = true;\n\n      // Don't generate the id if we're the client and the 'outermost' call\n      // This optimization saves us passing both the randomSeed and the id\n      // Passing both is redundant.\n      if (this._isRemoteCollection()) {\n        const enclosing = DDP._CurrentMethodInvocation.get();\n        if (!enclosing) {\n          generateId = false;\n        }\n      }\n\n      if (generateId) {\n        doc._id = this._makeNewID();\n      }\n    }\n\n\n    // On inserts, always return the id that we generated; on all other\n    // operations, just return the result from the collection.\n    var chooseReturnValueFromCollectionResult = function(result) {\n      if (Meteor._isPromise(result)) return result;\n\n      if (doc._id) {\n        return doc._id;\n      }\n\n      // XXX what is this for??\n      // It's some iteraction between the callback to _callMutatorMethod and\n      // the return value conversion\n      doc._id = result;\n\n      return result;\n    };\n\n    const wrappedCallback = wrapCallback(\n      callback,\n      chooseReturnValueFromCollectionResult\n    );\n\n    if (this._isRemoteCollection()) {\n      const result = this._callMutatorMethod('insert', [doc], wrappedCallback);\n      return chooseReturnValueFromCollectionResult(result);\n    }\n\n    // it's my collection.  descend into the collection object\n    // and propagate any exception.\n    try {\n      // If the user provided a callback and the collection implements this\n      // operation asynchronously, then queryRet will be undefined, and the\n      // result will be returned through the callback instead.\n      let result;\n      if (!!wrappedCallback) {\n        this._collection.insert(doc, wrappedCallback);\n      } else {\n        // If we don't have the callback, we assume the user is using the promise.\n        // We can't just pass this._collection.insert to the promisify because it would lose the context.\n        result = this._collection.insert(doc);\n      }\n\n      return chooseReturnValueFromCollectionResult(result);\n    } catch (e) {\n      if (callback) {\n        callback(e);\n        return null;\n      }\n      throw e;\n    }\n  },\n\n  /**\n   * @summary Insert a document in the collection.  Returns its unique _id.\n   * @locus Anywhere\n   * @method  insert\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.\n   * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the _id as the second.\n   */\n  insert(doc, callback) {\n    return this._insert(doc, callback);\n  },\n\n  /**\n   * @summary Asynchronously modifies one or more documents in the collection. Returns the number of matched documents.\n   * @locus Anywhere\n   * @method update\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to modify\n   * @param {MongoModifier} modifier Specifies how to modify the documents\n   * @param {Object} [options]\n   * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n   * @param {Boolean} options.upsert True to insert a document if no matching documents are found.\n   * @param {Array} options.arrayFilters Optional. Used in combination with MongoDB [filtered positional operator](https://docs.mongodb.com/manual/reference/operator/update/positional-filtered/) to specify which elements to modify in an array field.\n   * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n   */\n  update(selector, modifier, ...optionsAndCallback) {\n    const callback = popCallbackFromArgs(optionsAndCallback);\n\n    // We've already popped off the callback, so we are left with an array\n    // of one or zero items\n    const options = { ...(optionsAndCallback[0] || null) };\n    let insertedId;\n    if (options && options.upsert) {\n      // set `insertedId` if absent.  `insertedId` is a Meteor extension.\n      if (options.insertedId) {\n        if (\n          !(\n            typeof options.insertedId === 'string' ||\n            options.insertedId instanceof Mongo.ObjectID\n          )\n        )\n          throw new Error('insertedId must be string or ObjectID');\n        insertedId = options.insertedId;\n      } else if (!selector || !selector._id) {\n        insertedId = this._makeNewID();\n        options.generatedId = true;\n        options.insertedId = insertedId;\n      }\n    }\n\n    selector = Mongo.Collection._rewriteSelector(selector, {\n      fallbackId: insertedId,\n    });\n\n    const wrappedCallback = wrapCallback(callback);\n\n    if (this._isRemoteCollection()) {\n      const args = [selector, modifier, options];\n      return this._callMutatorMethod('update', args, callback);\n    }\n\n    // it's my collection.  descend into the collection object\n    // and propagate any exception.\n    // If the user provided a callback and the collection implements this\n    // operation asynchronously, then queryRet will be undefined, and the\n    // result will be returned through the callback instead.\n    //console.log({callback, options, selector, modifier, coll: this._collection});\n    try {\n      // If the user provided a callback and the collection implements this\n      // operation asynchronously, then queryRet will be undefined, and the\n      // result will be returned through the callback instead.\n      return this._collection.update(\n        selector,\n        modifier,\n        options,\n        wrappedCallback\n      );\n    } catch (e) {\n      if (callback) {\n        callback(e);\n        return null;\n      }\n      throw e;\n    }\n  },\n\n  /**\n   * @summary Remove documents from the collection\n   * @locus Anywhere\n   * @method remove\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to remove\n   * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n   */\n  remove(selector, callback) {\n    selector = Mongo.Collection._rewriteSelector(selector);\n\n    if (this._isRemoteCollection()) {\n      return this._callMutatorMethod('remove', [selector], callback);\n    }\n\n\n    // it's my collection.  descend into the collection1 object\n    // and propagate any exception.\n    return this._collection.remove(selector);\n  },\n\n  /**\n   * @summary Asynchronously modifies one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).\n   * @locus Anywhere\n   * @method upsert\n   * @memberof Mongo.Collection\n   * @instance\n   * @param {MongoSelector} selector Specifies which documents to modify\n   * @param {MongoModifier} modifier Specifies how to modify the documents\n   * @param {Object} [options]\n   * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).\n   * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.\n   */\n  upsert(selector, modifier, options, callback) {\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return this.update(\n      selector,\n      modifier,\n      {\n        ...options,\n        _returnObject: true,\n        upsert: true,\n      });\n  },\n}\n\n// Convert the callback to not return a result if there is an error\nfunction wrapCallback(callback, convertResult) {\n  return (\n    callback &&\n    function(error, result) {\n      if (error) {\n        callback(error);\n      } else if (typeof convertResult === 'function') {\n        callback(error, convertResult(result));\n      } else {\n        callback(error, result);\n      }\n    }\n  );\n}\n\nfunction popCallbackFromArgs(args) {\n  // Pull off any callback (or perhaps a 'callback' variable that was passed\n  // in undefined, like how 'upsert' does it).\n  if (\n    args.length &&\n    (args[args.length - 1] === undefined ||\n      args[args.length - 1] instanceof Function)\n  ) {\n    return args.pop();\n  }\n}\n","/**\n * @summary Allows for user specified connection options\n * @example http://mongodb.github.io/node-mongodb-native/3.0/reference/connecting/connection-settings/\n * @locus Server\n * @param {Object} options User specified Mongo connection options\n */\nMongo.setConnectionOptions = function setConnectionOptions (options) {\n  check(options, Object);\n  Mongo._connectionOptions = options;\n};","export const normalizeProjection = options => {\n  // transform fields key in projection\n  const { fields, projection, ...otherOptions } = options || {};\n  // TODO: enable this comment when deprecating the fields option\n  // Log.debug(`fields option has been deprecated, please use the new 'projection' instead`)\n\n  return {\n    ...otherOptions,\n    ...(projection || fields ? { projection: fields || projection } : {}),\n  };\n};\n","import { ObserveHandleCallback, ObserveMultiplexer } from './observe_multiplex';\n\nlet nextObserveHandleId = 1;\n\nexport type ObserveHandleCallbackInternal = '_added' | '_addedBefore' | '_changed' | '_movedBefore' | '_removed';\n\n\nexport type Callback<T = any> = (...args: T[]) => Promise<void> | void;\n\n/**\n * The \"observe handle\" returned from observeChanges.\n * Contains a reference to an ObserveMultiplexer.\n * Used to stop observation and clean up resources.\n */\nexport class ObserveHandle<T = any> {\n  _id: number;\n  _multiplexer: ObserveMultiplexer;\n  nonMutatingCallbacks: boolean;\n  _stopped: boolean;\n\n  public initialAddsSentResolver: (value: void) => void = () => {};\n  public initialAddsSent: Promise<void>\n\n  _added?: Callback<T>;\n  _addedBefore?: Callback<T>;\n  _changed?: Callback<T>;\n  _movedBefore?: Callback<T>;\n  _removed?: Callback<T>;\n\n  constructor(multiplexer: ObserveMultiplexer, callbacks: Record<ObserveHandleCallback, Callback<T>>, nonMutatingCallbacks: boolean) {\n    this._multiplexer = multiplexer;\n\n    multiplexer.callbackNames().forEach((name: ObserveHandleCallback) => {\n      if (callbacks[name]) {\n        this[`_${name}` as ObserveHandleCallbackInternal] = callbacks[name];\n        return;\n      }\n\n      if (name === \"addedBefore\" && callbacks.added) {\n        this._addedBefore = async function (id, fields, before) {\n          await callbacks.added(id, fields);\n        };\n      }\n    });\n\n    this._stopped = false;\n    this._id = nextObserveHandleId++;\n    this.nonMutatingCallbacks = nonMutatingCallbacks;\n\n    this.initialAddsSent = new Promise(resolve => {\n      const ready = () => {\n        resolve();\n        this.initialAddsSent = Promise.resolve();\n      }\n\n      const timeout = setTimeout(ready, 30000)\n\n      this.initialAddsSentResolver = () => {\n        ready();\n        clearTimeout(timeout);\n      };\n    });\n  }\n\n  /**\n   * Using property syntax and arrow function syntax to avoid binding the wrong context on callbacks.\n   */\n  stop = async () => {\n    if (this._stopped) return;\n    this._stopped = true;\n    await this._multiplexer.removeHandle(this._id);\n  }\n}"]}