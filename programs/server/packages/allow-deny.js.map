{"version":3,"sources":["meteor://ðŸ’»app/packages/allow-deny/allow-deny.js"],"names":["hasOwn","Object","prototype","hasOwnProperty","AllowDeny","CollectionPrototype","allow","options","addValidator","deny","_defineMutationMethods","self","_restricted","_insecure","undefined","_validators","insert","update","remove","insertAsync","updateAsync","removeAsync","upsertAsync","fetch","fetchAllFields","_name","_prefix","_connection","Meteor","server","isClient","m","forEach","method","methodName","useExisting","handlerPropName","isInsert","name","includes","check","arguments","Match","Any","args","Array","from","generatedId","call","_makeNewID","isSimulation","_id","_collection","apply","throwIfSelectorIsNotId","syncMethodName","replace","syncValidatedMethodName","charAt","toUpperCase","slice","validatedMethodName","length","Error","unshift","userId","push","_isInsecure","syncMethodsMapper","e","toString","methods","_updateFetch","fields","union","create","add","names","keys","Package","insecure","asyncSome","array","predicate","item","asyncEvery","_validatedInsertAsync","doc","validator","result","docToValidate","_isPromise","_validatedUpdateAsync","selector","mutator","assign","LocalCollection","_selectorIsIdPerhapsAsObject","upsert","noReplaceError","mutatorKeys","modifiedFields","op","params","ALLOWED_UPDATE_OPERATIONS","field","indexOf","substring","findOptions","transform","fieldName","findOneAsync","factoriedDoc","transformDoc","_forbidReplace","$inc","$set","$unset","$addToSet","$pop","$pullAll","$pull","$pushAll","$push","$bit","_validatedRemoveAsync","_callMutatorMethodAsync","firstArgIsSelector","alreadyInSimulation","mutatorMethodName","applyAsync","returnStubValue","resolverType","returnServerResultPromise","_stream","_isStub","_callMutatorMethod","callback","err","_debug","ret","EJSON","clone","collection","allowOrDeny","validKeysRegEx","key","test","isAsyncKey","syncKey","deprecate","Function","_transform","wrapTransform","isAsyncName","validatorSyncName","CurrentInvocation","DDP","_CurrentMethodInvocation","_CurrentInvocation","enclosing","get"],"mappings":"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","file":"/packages/allow-deny.js","sourcesContent":["///\n/// Remote methods and access control.\n///\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// Restrict default mutators on collection. allow() and deny() take the\n// same options:\n//\n// options.insertAsync {Function(userId, doc)}\n//   return true to allow/deny adding this document\n//\n// options.updateAsync {Function(userId, docs, fields, modifier)}\n//   return true to allow/deny updating these documents.\n//   `fields` is passed as an array of fields that are to be modified\n//\n// options.removeAsync {Function(userId, docs)}\n//   return true to allow/deny removing these documents\n//\n// options.fetch {Array}\n//   Fields to fetch for these validators. If any call to allow or deny\n//   does not have this option then all fields are loaded.\n//\n// allow and deny can be called multiple times. The validators are\n// evaluated as follows:\n// - If neither deny() nor allow() has been called on the collection,\n//   then the request is allowed if and only if the \"insecure\" smart\n//   package is in use.\n// - Otherwise, if any deny() function returns true, the request is denied.\n// - Otherwise, if any allow() function returns true, the request is allowed.\n// - Otherwise, the request is denied.\n//\n// Meteor may call your deny() and allow() functions in any order, and may not\n// call all of them if it is able to make a decision without calling them all\n// (so don't include side effects).\n\nAllowDeny = {\n  CollectionPrototype: {}\n};\n\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\n// methods\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\n\n/**\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n * @locus Server\n * @method allow\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.allow = function(options) {\n  addValidator(this, 'allow', options);\n};\n\n/**\n * @summary Override `allow` rules.\n * @locus Server\n * @method deny\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.deny = function(options) {\n  addValidator(this, 'deny', options);\n};\n\nCollectionPrototype._defineMutationMethods = function(options) {\n  const self = this;\n  options = options || {};\n\n  // set to true once we call any allow or deny methods. If true, use\n  // allow/deny semantics. If false, use insecure mode semantics.\n  self._restricted = false;\n\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\n  // means insecure iff the insecure package is loaded. This property can be\n  // overriden by tests or packages wishing to change insecure mode behavior of\n  // their collections.\n  self._insecure = undefined;\n\n  self._validators = {\n    insert: {allow: [], deny: []},\n    update: {allow: [], deny: []},\n    remove: {allow: [], deny: []},\n    insertAsync: {allow: [], deny: []},\n    updateAsync: {allow: [], deny: []},\n    removeAsync: {allow: [], deny: []},\n    upsertAsync: {allow: [], deny: []}, // dummy arrays; can't set these!\n    fetch: [],\n    fetchAllFields: false\n  };\n\n  if (!self._name)\n    return; // anonymous collection\n\n  // XXX Think about method namespacing. Maybe methods should be\n  // \"Meteor:Mongo:insertAsync/NAME\"?\n  self._prefix = '/' + self._name + '/';\n\n  // Mutation Methods\n  // Minimongo on the server gets no stubs; instead, by default\n  // it wait()s until its result is ready, yielding.\n  // This matches the behavior of macromongo on the server better.\n  // XXX see #MeteorServerNull\n  if (self._connection && (self._connection === Meteor.server || Meteor.isClient)) {\n    const m = {};\n\n    [\n      'insertAsync',\n      'updateAsync',\n      'removeAsync',\n      'insert',\n      'update',\n      'remove',\n    ].forEach(method => {\n      const methodName = self._prefix + method;\n\n      if (options.useExisting) {\n        const handlerPropName = Meteor.isClient\n          ? '_methodHandlers'\n          : 'method_handlers';\n        // Do not try to create additional methods if this has already been called.\n        // (Otherwise the .methods() call below will throw an error.)\n        if (\n          self._connection[handlerPropName] &&\n          typeof self._connection[handlerPropName][methodName] === 'function'\n        )\n          return;\n      }\n\n      const isInsert = name => name.includes('insert');\n\n      m[methodName] = function (/* ... */) {\n        // All the methods do their own validation, instead of using check().\n        check(arguments, [Match.Any]);\n        const args = Array.from(arguments);\n        try {\n          // For an insert/insertAsync, if the client didn't specify an _id, generate one\n          // now; because this uses DDP.randomStream, it will be consistent with\n          // what the client generated. We generate it now rather than later so\n          // that if (eg) an allow/deny rule does an insert/insertAsync to the same\n          // collection (not that it really should), the generated _id will\n          // still be the first use of the stream and will be consistent.\n          //\n          // However, we don't actually stick the _id onto the document yet,\n          // because we want allow/deny rules to be able to differentiate\n          // between arbitrary client-specified _id fields and merely\n          // client-controlled-via-randomSeed fields.\n          let generatedId = null;\n          if (isInsert(method) && !hasOwn.call(args[0], '_id')) {\n            generatedId = self._makeNewID();\n          }\n\n          if (this.isSimulation) {\n            // In a client simulation, you can do any mutation (even with a\n            // complex selector).\n            if (generatedId !== null) {\n              args[0]._id = generatedId;\n            }\n            return self._collection[method].apply(self._collection, args);\n          }\n\n          // This is the server receiving a method call from the client.\n\n          // We don't allow arbitrary selectors in mutations from the client: only\n          // single-ID selectors.\n          if (!isInsert(method)) throwIfSelectorIsNotId(args[0], method);\n\n          const syncMethodName = method.replace('Async', '');\n          const syncValidatedMethodName = '_validated' + method.charAt(0).toUpperCase() + syncMethodName.slice(1);\n          // it forces to use async validated behavior\n          const validatedMethodName = syncValidatedMethodName + 'Async';\n\n          if (self._restricted) {\n            // short circuit if there is no way it will pass.\n            if (self._validators[syncMethodName].allow.length === 0) {\n              throw new Meteor.Error(\n                403,\n                'Access denied. No allow validators set on restricted ' +\n                  \"collection for method '\" +\n                  method +\n                  \"'.\"\n              );\n            }\n\n            args.unshift(this.userId);\n            isInsert(method) && args.push(generatedId);\n            return self[validatedMethodName].apply(self, args);\n          } else if (self._isInsecure()) {\n            if (generatedId !== null) args[0]._id = generatedId;\n            // In insecure mode we use the server _collection methods, and these sync methods\n            // do not exist in the server anymore, so we have this mapper to call the async methods\n            // instead.\n            const syncMethodsMapper = {\n              insert: \"insertAsync\",\n              update: \"updateAsync\",\n              remove: \"removeAsync\",\n            };\n\n\n            // In insecure mode, allow any mutation (with a simple selector).\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\n            //     we get from the network to this function, we should actually\n            //     know the correct arguments for the function and pass just\n            //     them.  For example, if you have an extraneous extra null\n            //     argument and this is Mongo on the server, the .wrapAsync'd\n            //     functions like update will get confused and pass the\n            //     \"fut.resolver()\" in the wrong slot, where _update will never\n            //     invoke it. Bam, broken DDP connection.  Probably should just\n            //     take this whole method and write it three times, invoking\n            //     helpers for the common code.\n            return self._collection[syncMethodsMapper[method] || method].apply(self._collection, args);\n          } else {\n            // In secure mode, if we haven't called allow or deny, then nothing\n            // is permitted.\n            throw new Meteor.Error(403, 'Access denied');\n          }\n        } catch (e) {\n          if (\n            e.name === 'MongoError' ||\n            // for old versions of MongoDB (probably not necessary but it's here just in case)\n            e.name === 'BulkWriteError' ||\n            // for newer versions of MongoDB (https://docs.mongodb.com/drivers/node/current/whats-new/#bulkwriteerror---mongobulkwriteerror)\n            e.name === 'MongoBulkWriteError' ||\n            e.name === 'MinimongoError'\n          ) {\n            throw new Meteor.Error(409, e.toString());\n          } else {\n            throw e;\n          }\n        }\n      };\n    });\n\n    self._connection.methods(m);\n  }\n};\n\nCollectionPrototype._updateFetch = function (fields) {\n  const self = this;\n\n  if (!self._validators.fetchAllFields) {\n    if (fields) {\n      const union = Object.create(null);\n      const add = names => names && names.forEach(name => union[name] = 1);\n      add(self._validators.fetch);\n      add(fields);\n      self._validators.fetch = Object.keys(union);\n    } else {\n      self._validators.fetchAllFields = true;\n      // clear fetch just to make sure we don't accidentally read it\n      self._validators.fetch = null;\n    }\n  }\n};\n\nCollectionPrototype._isInsecure = function () {\n  const self = this;\n  if (self._insecure === undefined)\n    return !!Package.insecure;\n  return self._insecure;\n};\n\nasync function asyncSome(array, predicate) {\n  for (let item of array) {\n    if (await predicate(item)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nasync function asyncEvery(array, predicate) {\n  for (let item of array) {\n    if (!await predicate(item)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nCollectionPrototype._validatedInsertAsync = async function(userId, doc,\n                                                           generatedId) {\n  const self = this;\n  // call user validators.\n  // Any deny returns true means denied.\n  if (await asyncSome(self._validators.insert.deny, async (validator) => {\n    const result = validator(userId, docToValidate(validator, doc, generatedId));\n    return Meteor._isPromise(result) ? await result : result;\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n\n  if (await asyncEvery(self._validators.insert.allow, async (validator) => {\n    const result = validator(userId, docToValidate(validator, doc, generatedId));\n    return !(Meteor._isPromise(result) ? await result : result);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // If we generated an ID above, insertAsync it now: after the validation, but\n  // before actually inserting.\n  if (generatedId !== null)\n    doc._id = generatedId;\n\n  return self._collection.insertAsync.call(self._collection, doc);\n};\n\n// Simulate a mongo `update` operation while validating that the access\n// control rules set by calls to `allow/deny` are satisfied. If all\n// pass, rewrite the mongo operation to use $in to set the list of\n// document ids to change ##ValidatedChange\nCollectionPrototype._validatedUpdateAsync = async function(\n    userId, selector, mutator, options) {\n  const self = this;\n\n  check(mutator, Object);\n\n  options = Object.assign(Object.create(null), options);\n\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\n    throw new Error(\"validated update should be of a single ID\");\n\n  // We don't support upserts because they don't fit nicely into allow/deny\n  // rules.\n  if (options.upsert)\n    throw new Meteor.Error(403, \"Access denied. Upserts not \" +\n                           \"allowed in a restricted collection.\");\n\n  const noReplaceError = \"Access denied. In a restricted collection you can only\" +\n        \" update documents, not replace them. Use a Mongo update operator, such \" +\n        \"as '$set'.\";\n\n  const mutatorKeys = Object.keys(mutator);\n\n  // compute modified fields\n  const modifiedFields = {};\n\n  if (mutatorKeys.length === 0) {\n    throw new Meteor.Error(403, noReplaceError);\n  }\n  mutatorKeys.forEach((op) => {\n    const params = mutator[op];\n    if (op.charAt(0) !== '$') {\n      throw new Meteor.Error(403, noReplaceError);\n    } else if (!hasOwn.call(ALLOWED_UPDATE_OPERATIONS, op)) {\n      throw new Meteor.Error(\n        403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");\n    } else {\n      Object.keys(params).forEach((field) => {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1)\n          field = field.substring(0, field.indexOf('.'));\n\n        // record the field we are trying to change\n        modifiedFields[field] = true;\n      });\n    }\n  });\n\n  const fields = Object.keys(modifiedFields);\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    self._validators.fetch.forEach((fieldName) => {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = await self._collection.findOneAsync(selector, findOptions);\n  if (!doc)  // none satisfied!\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (await asyncSome(self._validators.update.deny, async (validator) => {\n    const factoriedDoc = transformDoc(validator, doc);\n    const result = validator(userId,\n      factoriedDoc,\n      fields,\n      mutator);\n    return Meteor._isPromise(result) ? await result : result;\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (await asyncEvery(self._validators.update.allow, async (validator) => {\n    const factoriedDoc = transformDoc(validator, doc);\n    const result = validator(userId,\n      factoriedDoc,\n      fields,\n      mutator);\n    return !(Meteor._isPromise(result) ? await result : result);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  options._forbidReplace = true;\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to include an _id clause before passing to Mongo to\n  // avoid races, but since selector is guaranteed to already just be an ID, we\n  // don't have to any more.\n\n  return self._collection.updateAsync.call(\n    self._collection, selector, mutator, options);\n};\n\n// Only allow these operations in validated updates. Specifically\n// whitelist operations, rather than blacklist, so new complex\n// operations that are added aren't automatically allowed. A complex\n// operation is one that does more than just modify its target\n// field. For now this contains all update operations except '$rename'.\n// http://docs.mongodb.org/manual/reference/operators/#update\nconst ALLOWED_UPDATE_OPERATIONS = {\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\n  $pushAll:1, $push:1, $bit:1\n};\n\n// Simulate a mongo `remove` operation while validating access control\n// rules. See #ValidatedChange\nCollectionPrototype._validatedRemoveAsync = async function(userId, selector) {\n  const self = this;\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    self._validators.fetch.forEach((fieldName) => {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = await self._collection.findOneAsync(selector, findOptions);\n  if (!doc)\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (await asyncSome(self._validators.remove.deny, async (validator) => {\n    const result = validator(userId, transformDoc(validator, doc));\n    return Meteor._isPromise(result) ? await result : result;\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (await asyncEvery(self._validators.remove.allow, async (validator) => {\n    const result = validator(userId, transformDoc(validator, doc));\n    return !(Meteor._isPromise(result) ? await result : result);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\n  // Mongo to avoid races, but since selector is guaranteed to already just be\n  // an ID, we don't have to any more.\n\n  return self._collection.removeAsync.call(self._collection, selector);\n};\n\nCollectionPrototype._callMutatorMethodAsync = function _callMutatorMethodAsync(name, args, options = {}) {\n\n  // For two out of three mutator methods, the first argument is a selector\n  const firstArgIsSelector = name === \"updateAsync\" || name === \"removeAsync\";\n  if (firstArgIsSelector && !alreadyInSimulation()) {\n    // If we're about to actually send an RPC, we should throw an error if\n    // this is a non-ID selector, because the mutation methods only allow\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\n    throwIfSelectorIsNotId(args[0], name);\n  }\n\n  const mutatorMethodName = this._prefix + name;\n  return this._connection.applyAsync(mutatorMethodName, args, {\n    returnStubValue: this.resolverType === 'stub' || this.resolverType == null,\n    // StubStream is only used for testing where you don't care about the server\n    returnServerResultPromise: !this._connection._stream._isStub && this.resolverType !== 'stub',\n    ...options,\n  });\n}\n\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\n    // Client can't block, so it can't report errors by exception,\n    // only by callback. If they forget the callback, give them a\n    // default one that logs the error, so they aren't totally\n    // baffled if their writes don't work because their database is\n    // down.\n    // Don't give a default callback in simulation, because inside stubs we\n    // want to return the results from the local collection immediately and\n    // not force a callback.\n    callback = function (err) {\n      if (err)\n        Meteor._debug(name + \" failed\", err);\n    };\n  }\n\n  // For two out of three mutator methods, the first argument is a selector\n  const firstArgIsSelector = name === \"update\" || name === \"remove\";\n  if (firstArgIsSelector && !alreadyInSimulation()) {\n    // If we're about to actually send an RPC, we should throw an error if\n    // this is a non-ID selector, because the mutation methods only allow\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\n    throwIfSelectorIsNotId(args[0], name);\n  }\n\n  const mutatorMethodName = this._prefix + name;\n  return this._connection.apply(\n    mutatorMethodName, args, { returnStubValue: true }, callback);\n}\n\nfunction transformDoc(validator, doc) {\n  if (validator.transform)\n    return validator.transform(doc);\n  return doc;\n}\n\nfunction docToValidate(validator, doc, generatedId) {\n  let ret = doc;\n  if (validator.transform) {\n    ret = EJSON.clone(doc);\n    // If you set a server-side transform on your collection, then you don't get\n    // to tell the difference between \"client specified the ID\" and \"server\n    // generated the ID\", because transforms expect to get _id.  If you want to\n    // do that check, you can do it with a specific\n    // `C.allow({insertAsync: f, transform: null})` validator.\n    if (generatedId !== null) {\n      ret._id = generatedId;\n    }\n    ret = validator.transform(ret);\n  }\n  return ret;\n}\n\nfunction addValidator(collection, allowOrDeny, options) {\n  // validate keys\n  const validKeysRegEx = /^(?:insertAsync|updateAsync|removeAsync|insert|update|remove|fetch|transform)$/;\n  Object.keys(options).forEach((key) => {\n    if (!validKeysRegEx.test(key))\n      throw new Error(allowOrDeny + \": Invalid key: \" + key);\n\n    // TODO deprecated async config on future versions\n    const isAsyncKey = key.includes('Async');\n    if (isAsyncKey) {\n      const syncKey = key.replace('Async', '');\n      Meteor.deprecate(allowOrDeny + `: The \"${key}\" key is deprecated. Use \"${syncKey}\" instead.`);\n    }\n  });\n\n  collection._restricted = true;\n\n  [\n    'insertAsync',\n    'updateAsync',\n    'removeAsync',\n    'insert',\n    'update',\n    'remove',\n  ].forEach(name => {\n    if (hasOwn.call(options, name)) {\n      if (!(options[name] instanceof Function)) {\n        throw new Error(\n          allowOrDeny + ': Value for `' + name + '` must be a function'\n        );\n      }\n\n      // If the transform is specified at all (including as 'null') in this\n      // call, then take that; otherwise, take the transform from the\n      // collection.\n      if (options.transform === undefined) {\n        options[name].transform = collection._transform; // already wrapped\n      } else {\n        options[name].transform = LocalCollection.wrapTransform(\n          options.transform\n        );\n      }\n      const isAsyncName = name.includes('Async');\n      const validatorSyncName = isAsyncName ? name.replace('Async', '') : name;\n      collection._validators[validatorSyncName][allowOrDeny].push(options[name]);\n    }\n  });\n\n  // Only updateAsync the fetch fields if we're passed things that affect\n  // fetching. This way allow({}) and allow({insertAsync: f}) don't result in\n  // setting fetchAllFields\n  if (options.updateAsync || options.removeAsync || options.fetch) {\n    if (options.fetch && !(options.fetch instanceof Array)) {\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");\n    }\n    collection._updateFetch(options.fetch);\n  }\n}\n\nfunction throwIfSelectorIsNotId(selector, methodName) {\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    throw new Meteor.Error(\n      403, \"Not permitted. Untrusted code may only \" + methodName +\n        \" documents by ID.\");\n  }\n};\n\n// Determine if we are in a DDP method simulation\nfunction alreadyInSimulation() {\n  var CurrentInvocation =\n    DDP._CurrentMethodInvocation ||\n    // For backwards compatibility, as explained in this issue:\n    // https://github.com/meteor/meteor/issues/8947\n    DDP._CurrentInvocation;\n\n  const enclosing = CurrentInvocation.get();\n  return enclosing && enclosing.isSimulation;\n}\n"]}