{"version":3,"sources":["meteor://ðŸ’»app/packages/routepolicy/main.js","meteor://ðŸ’»app/packages/routepolicy/routepolicy.js"],"names":["default","RoutePolicyConstructor","RoutePolicy","urlPrefixMatches","urlPrefix","url","startsWith","checkType","type","includes","checkUrlPrefix","existingType","urlPrefixTypes","checkForConflictWithStatic","_testManifest","policy","check","manifest","conflict","find","resource","where","WebApp","require","errorMessage","Object","keys","clientPrograms","some","arch","declare","problem","Error","isValidUrl","classify","prefix","urlPrefixesFor","entries","filter","_prefix","_type","map","sort"],"mappings":"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","file":"/packages/routepolicy.js","sourcesContent":["import { default as RoutePolicyConstructor } from './routepolicy';\nexport const RoutePolicy = new RoutePolicyConstructor();\n","// In addition to listing specific files to be cached, the browser\n// application cache manifest allows URLs to be designated as NETWORK\n// (always fetched from the Internet) and FALLBACK (which we use to\n// serve app HTML on arbitrary URLs).\n//\n// The limitation of the manifest file format is that the designations\n// are by prefix only: if \"/foo\" is declared NETWORK then \"/foobar\"\n// will also be treated as a network route.\n//\n// RoutePolicy is a low-level API for declaring the route type of URL prefixes:\n//\n// \"network\": for network routes that should not conflict with static\n// resources.  (For example, if \"/sockjs/\" is a network route, we\n// shouldn't have \"/sockjs/red-sock.jpg\" as a static resource).\n//\n// \"static-online\": for static resources which should not be cached in\n// the app cache.  This is implemented by also adding them to the\n// NETWORK section (as otherwise the browser would receive app HTML\n// for them because of the FALLBACK section), but static-online routes\n// don't need to be checked for conflict with static resources.\n\n\nexport default class RoutePolicy {\n  constructor() {\n    // maps prefix to a type\n    this.urlPrefixTypes = {};\n  }\n\n  urlPrefixMatches(urlPrefix, url) {\n    return url.startsWith(urlPrefix);\n  }\n\n  checkType(type) {\n    if (!['network', 'static-online'].includes(type)) {\n      return 'the route type must be \"network\" or \"static-online\"';\n    }\n    return null;\n  }\n\n  checkUrlPrefix(urlPrefix, type) {\n    if (!urlPrefix.startsWith('/')) {\n      return 'a route URL prefix must begin with a slash';\n    }\n\n    if (urlPrefix === '/') {\n      return 'a route URL prefix cannot be /';\n    }\n\n    const existingType = this.urlPrefixTypes[urlPrefix];\n    if (existingType && existingType !== type) {\n      return `the route URL prefix ${urlPrefix} has already been declared ` +\n        `to be of type ${existingType}`;\n    }\n\n    return null;\n  }\n\n  checkForConflictWithStatic(urlPrefix, type, _testManifest) {\n    if (type === 'static-online') {\n      return null;\n    }\n\n    const policy = this;\n\n    function check(manifest) {\n      const conflict = manifest.find(resource => (\n        resource.type === 'static' &&\n        resource.where === 'client' &&\n        policy.urlPrefixMatches(urlPrefix, resource.url)\n      ));\n\n      if (conflict) {\n        return `static resource ${conflict.url} conflicts with ${type} ` +\n          `route ${urlPrefix}`;\n      }\n\n      return null;\n    };\n\n    if (_testManifest) {\n      return check(_testManifest);\n    }\n\n    const { WebApp } = require(\"meteor/webapp\");\n    let errorMessage = null;\n\n    Object.keys(WebApp.clientPrograms).some(arch => {\n      const { manifest } = WebApp.clientPrograms[arch];\n      return errorMessage = check(manifest);\n    });\n\n    return errorMessage;\n  }\n\n  declare(urlPrefix, type) {\n    const problem =\n      this.checkType(type) ||\n      this.checkUrlPrefix(urlPrefix, type) ||\n      this.checkForConflictWithStatic(urlPrefix, type);\n    if (problem) {\n      throw new Error(problem);\n    }\n    // TODO overlapping prefixes, e.g. /foo/ and /foo/bar/\n    this.urlPrefixTypes[urlPrefix] = type;\n  }\n\n  isValidUrl(url) {\n    return url.startsWith('/');\n  }\n\n  classify(url) {\n    if (!this.isValidUrl(url)) {\n      throw new Error(`url must be a relative URL: ${url}`);\n    }\n\n    const prefix = Object.keys(this.urlPrefixTypes).find(prefix =>\n      this.urlPrefixMatches(prefix, url)\n    );\n\n    return prefix ? this.urlPrefixTypes[prefix] : null;\n  }\n\n  urlPrefixesFor(type) {\n    return Object.entries(this.urlPrefixTypes)\n      .filter(([_prefix, _type]) => _type === type)\n      .map(([_prefix]) => _prefix)\n      .sort();\n  }\n}\n"]}