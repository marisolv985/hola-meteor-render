{"version":3,"sources":["meteor://ðŸ’»app/packages/binary-heap/binary-heap.js","meteor://ðŸ’»app/packages/binary-heap/max-heap.js","meteor://ðŸ’»app/packages/binary-heap/min-heap.js","meteor://ðŸ’»app/packages/binary-heap/min-max-heap.js"],"names":["MaxHeap","_initFromData","data","_heap","map","id","value","forEach","i","_heapIdx","set","length","parentIdx","_downHeap","idx","leftChildIdx","size","left","right","rightChildIdx","largest","_maxIndex","_swap","_upHeap","parent","idxA","idxB","valueA","_get","valueB","_comparator","recA","recB","get","has","push","remove","last","pop","empty","clear","iterator","obj","setDefault","def","clone","maxElementId","_selfCheck","Error","comparator","options","IdMap","Array","isArray","initData","MinHeap","minElementId","a","b","MinMaxHeap","args","_minHeap"],"mappings":"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","file":"/packages/binary-heap.js","sourcesContent":["export { MaxHeap } from './max-heap.js';\nexport { MinHeap } from './min-heap.js';\nexport { MinMaxHeap } from './min-max-heap.js';\n","// Constructor of Heap\n// - comparator - Function - given two items returns a number\n// - options:\n//   - initData - Array - Optional - the initial data in a format:\n//        Object:\n//          - id - String - unique id of the item\n//          - value - Any - the data value\n//      each value is retained\n//   - IdMap - Constructor - Optional - custom IdMap class to store id->index\n//       mappings internally. Standard IdMap is used by default.\nexport class MaxHeap { \n  constructor(comparator, options = {}) {\n    if (typeof comparator !== 'function') {\n      throw new Error('Passed comparator is invalid, should be a comparison function');\n    }\n\n    // a C-style comparator that is given two values and returns a number,\n    // negative if the first value is less than the second, positive if the second\n    // value is greater than the first and zero if they are equal.\n    this._comparator = comparator;\n\n    if (! options.IdMap) {\n      options.IdMap = IdMap;\n    }\n\n    // _heapIdx maps an id to an index in the Heap array the corresponding value\n    // is located on.\n    this._heapIdx = new options.IdMap;\n\n    // The Heap data-structure implemented as a 0-based contiguous array where\n    // every item on index idx is a node in a complete binary tree. Every node can\n    // have children on indexes idx*2+1 and idx*2+2, except for the leaves. Every\n    // node has a parent on index (idx-1)/2;\n    this._heap = [];\n\n    // If the initial array is passed, we can build the heap in linear time\n    // complexity (O(N)) compared to linearithmic time complexity (O(nlogn)) if\n    // we push elements one by one.\n    if (Array.isArray(options.initData)) {\n      this._initFromData(options.initData);\n    }\n  }\n\n  // Builds a new heap in-place in linear time based on passed data\n  _initFromData(data) {\n    this._heap = data.map(({ id, value }) => ({ id, value }));\n\n    data.forEach(({ id }, i) => this._heapIdx.set(id, i));\n\n    if (! data.length) {\n      return;\n    }\n\n    // start from the first non-leaf - the parent of the last leaf\n    for (let i = parentIdx(data.length - 1); i >= 0; i--) {\n      this._downHeap(i);\n    }\n  }\n\n  _downHeap(idx) {\n    while (leftChildIdx(idx) < this.size()) {\n      const left = leftChildIdx(idx);\n      const right = rightChildIdx(idx);\n      let largest = idx;\n\n      if (left < this.size()) {\n        largest = this._maxIndex(largest, left);\n      }\n\n      if (right < this.size()) {\n        largest = this._maxIndex(largest, right);\n      }\n\n      if (largest === idx) {\n        break;\n      }\n\n      this._swap(largest, idx);\n      idx = largest;\n    }\n  }\n\n  _upHeap(idx) {\n    while (idx > 0) {\n      const parent = parentIdx(idx);\n      if (this._maxIndex(parent, idx) === idx) {\n        this._swap(parent, idx)\n        idx = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  _maxIndex(idxA, idxB) {\n    const valueA = this._get(idxA);\n    const valueB = this._get(idxB);\n    return this._comparator(valueA, valueB) >= 0 ? idxA : idxB;\n  }\n\n  // Internal: gets raw data object placed on idxth place in heap\n  _get(idx) {\n    return this._heap[idx].value;\n  }\n\n  _swap(idxA, idxB) {\n    const recA = this._heap[idxA];\n    const recB = this._heap[idxB];\n\n    this._heapIdx.set(recA.id, idxB);\n    this._heapIdx.set(recB.id, idxA);\n\n    this._heap[idxA] = recB;\n    this._heap[idxB] = recA;\n  }\n\n  get(id) {\n    return this.has(id) ?\n      this._get(this._heapIdx.get(id)) :\n      null;\n  }\n\n  set(id, value) {\n    if (this.has(id)) {\n      if (this.get(id) === value) {\n        return;\n      }\n\n      const idx = this._heapIdx.get(id);\n      this._heap[idx].value = value;\n\n      // Fix the new value's position\n      // Either bubble new value up if it is greater than its parent\n      this._upHeap(idx);\n      // or bubble it down if it is smaller than one of its children\n      this._downHeap(idx);\n    } else {\n      this._heapIdx.set(id, this._heap.length);\n      this._heap.push({ id, value });\n      this._upHeap(this._heap.length - 1);\n    }\n  }\n\n  remove(id) {\n    if (this.has(id)) {\n      const last = this._heap.length - 1;\n      const idx = this._heapIdx.get(id);\n\n      if (idx !== last) {\n        this._swap(idx, last);\n        this._heap.pop();\n        this._heapIdx.remove(id);\n\n        // Fix the swapped value's position\n        this._upHeap(idx);\n        this._downHeap(idx);\n      } else {\n        this._heap.pop();\n        this._heapIdx.remove(id);\n      }\n    }\n  }\n\n  has(id) {\n    return this._heapIdx.has(id);\n  }\n\n  empty() {\n    return !this.size();\n  }\n\n  clear() {\n    this._heap = [];\n    this._heapIdx.clear();\n  }\n\n  // iterate over values in no particular order\n  forEach(iterator) {\n    this._heap.forEach(obj => iterator(obj.value, obj.id));\n  }\n\n  size() {\n    return this._heap.length;\n  }\n\n  setDefault(id, def) {\n    if (this.has(id)) {\n      return this.get(id);\n    }\n\n    this.set(id, def);\n    return def;\n  }\n\n  clone() {\n    const clone = new MaxHeap(this._comparator, this._heap);\n    return clone;\n  }\n\n  maxElementId() {\n    return this.size() ? this._heap[0].id : null;\n  }\n\n  _selfCheck() {\n    for (let i = 1; i < this._heap.length; i++) {\n      if (this._maxIndex(parentIdx(i), i) !== parentIdx(i)) {\n          throw new Error(`An item with id ${this._heap[i].id}` +\n                          \" has a parent younger than it: \" +\n                          this._heap[parentIdx(i)].id);\n      }\n    }\n  }\n}\n\nconst leftChildIdx = i => i * 2 + 1;\nconst rightChildIdx = i => i * 2 + 2;\nconst parentIdx = i => (i - 1) >> 1;\n","import { MaxHeap } from './max-heap.js';\n\nexport class MinHeap extends MaxHeap {\n  constructor(comparator, options) {\n    super((a, b) => -comparator(a, b), options);\n  }\n\n  maxElementId() {\n    throw new Error(\"Cannot call maxElementId on MinHeap\");\n  }\n\n  minElementId() {\n    return super.maxElementId();\n  }\n};\n","import { MaxHeap } from './max-heap.js';\nimport { MinHeap } from './min-heap.js';\n\n// This implementation of Min/Max-Heap is just a subclass of Max-Heap\n// with a Min-Heap as an encapsulated property.\n//\n// Most of the operations are just proxy methods to call the same method on both\n// heaps.\n//\n// This implementation takes 2*N memory but is fairly simple to write and\n// understand. And the constant factor of a simple Heap is usually smaller\n// compared to other two-way priority queues like Min/Max Heaps\n// (http://www.cs.otago.ac.nz/staffpriv/mike/Papers/MinMaxHeaps/MinMaxHeaps.pdf)\n// and Interval Heaps\n// (http://www.cise.ufl.edu/~sahni/dsaac/enrich/c13/double.htm)\nexport class MinMaxHeap extends MaxHeap {\n  constructor(comparator, options) {\n    super(comparator, options);\n    this._minHeap = new MinHeap(comparator, options);\n  }\n\n  set(...args) {\n    super.set(...args);\n    this._minHeap.set(...args);\n  }\n\n  remove(...args) {\n    super.remove(...args);\n    this._minHeap.remove(...args);\n  }\n\n  clear(...args) {\n    super.clear(...args);\n    this._minHeap.clear(...args);\n  }\n\n  setDefault(...args) {\n    super.setDefault(...args);\n    return this._minHeap.setDefault(...args);\n  }\n\n  clone() {\n    const clone = new MinMaxHeap(this._comparator, this._heap);\n    return clone;\n  }\n\n  minElementId() {\n    return this._minHeap.minElementId();\n  }\n\n};\n"]}