{"version":3,"sources":["meteor://ðŸ’»app/packages/retry/retry.js"],"names":["Retry","clear","retryTimer","clearTimeout","_timeout","count","minCount","minTimeout","timeout","Math","min","maxTimeout","baseTimeout","pow","exponent","Random","fraction","fuzz","retryLater","fn","Meteor","setTimeout"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,2CAA2C;AAC3C,EAAE;AACF,WAAW;AACX,yDAAyD;AACzD,kEAAkE;AAClE,kDAAkD;AAClD,sDAAsD;AACtD,mEAAmE;AACnE,qEAAqE;AAErE,OAAO,MAAMA;IAoBX,iCAAiC;IACjCC,QAAQ;QACN,IAAI,IAAI,CAACC,UAAU,EAAE;YACnBC,aAAa,IAAI,CAACD,UAAU;QAC9B;QACA,IAAI,CAACA,UAAU,GAAG;IACpB;IAEA,oEAAoE;IACpE,kCAAkC;IAClCE,SAASC,KAAK,EAAE;QACd,IAAIA,QAAQ,IAAI,CAACC,QAAQ,EAAE;YACzB,OAAO,IAAI,CAACC,UAAU;QACxB;QAEA,8DAA8D;QAC9D,oBAAoB;QACpB,IAAIC,UAAUC,KAAKC,GAAG,CACpB,IAAI,CAACC,UAAU,EACf,IAAI,CAACC,WAAW,GAAGH,KAAKI,GAAG,CAAC,IAAI,CAACC,QAAQ,EAAET,UAE3CU,QAAOC,QAAQ,KAAK,IAAI,CAACC,IAAI,GAAI,KAAI,IAAI,CAACA,IAAI,GAAG,EAAC;QAGpD,OAAOT;IACT;IAEA,wEAAwE;IACxEU,WAAWb,KAAK,EAAEc,EAAE,EAAE;QACpB,IAAIX,UAAU,IAAI,CAACJ,QAAQ,CAACC;QAC5B,IAAI,IAAI,CAACH,UAAU,EACjBC,aAAa,IAAI,CAACD,UAAU;QAC9B,IAAI,CAACA,UAAU,GAAGkB,OAAOC,UAAU,CAACF,IAAIX;QACxC,OAAOA;IACT;IArDA,YAAY,EACVI,cAAc,IAAI,EAClBE,WAAW,GAAG,EACd,gEAAgE;IAChE,0BAA0B;IAC1BH,aAAa,IAAI,KAAK,IAAI,EAC1BJ,aAAa,EAAE,EACfD,WAAW,CAAC,EACZW,OAAO,GAAG,EACX,GAAG,CAAC,CAAC,CAAE;QACN,IAAI,CAACL,WAAW,GAAGA;QACnB,IAAI,CAACE,QAAQ,GAAGA;QAChB,IAAI,CAACH,UAAU,GAAGA;QAClB,IAAI,CAACJ,UAAU,GAAGA;QAClB,IAAI,CAACD,QAAQ,GAAGA;QAChB,IAAI,CAACW,IAAI,GAAGA;QACZ,IAAI,CAACf,UAAU,GAAG;IACpB;AAqCF","file":"/packages/retry.js","sourcesContent":["// Retry logic with an exponential backoff.\n//\n// options:\n//  baseTimeout: time for initial reconnect attempt (ms).\n//  exponent: exponential factor to increase timeout each attempt.\n//  maxTimeout: maximum time between retries (ms).\n//  minCount: how many times to reconnect \"instantly\".\n//  minTimeout: time to wait for the first `minCount` retries (ms).\n//  fuzz: factor to randomize retry times by (to avoid retry storms).\n\nexport class Retry {\n  constructor({\n    baseTimeout = 1000,\n    exponent = 2.2,\n    // The default is high-ish to ensure a server can recover from a\n    // failure caused by load.\n    maxTimeout = 5 * 60 * 1000,\n    minTimeout = 10,\n    minCount = 2,\n    fuzz = 0.5,\n  } = {}) {\n    this.baseTimeout = baseTimeout;\n    this.exponent = exponent;\n    this.maxTimeout = maxTimeout;\n    this.minTimeout = minTimeout;\n    this.minCount = minCount;\n    this.fuzz = fuzz;\n    this.retryTimer = null;\n  }\n\n  // Reset a pending retry, if any.\n  clear() {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer);\n    }\n    this.retryTimer = null;\n  }\n\n  // Calculate how long to wait in milliseconds to retry, based on the\n  // `count` of which retry this is.\n  _timeout(count) {\n    if (count < this.minCount) {\n      return this.minTimeout;\n    }\n\n    // fuzz the timeout randomly, to avoid reconnect storms when a\n    // server goes down.\n    var timeout = Math.min(\n      this.maxTimeout,\n      this.baseTimeout * Math.pow(this.exponent, count)\n    ) * (\n      Random.fraction() * this.fuzz + (1 - this.fuzz / 2)\n    );\n\n    return timeout;\n  }\n\n  // Call `fn` after a delay, based on the `count` of which retry this is.\n  retryLater(count, fn) {\n    var timeout = this._timeout(count);\n    if (this.retryTimer)\n      clearTimeout(this.retryTimer);\n    this.retryTimer = Meteor.setTimeout(fn, timeout);\n    return timeout;\n  }\n}\n"]}