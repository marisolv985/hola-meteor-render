{"version":3,"sources":["meteor://ðŸ’»app/packages/minifier-css/minifier.js"],"names":["CssTools","parseCss","cssText","options","source","from","postcss","parse","stringifyCss","cssAst","sourcemap","map","inline","annotation","sourcesContent","transformResult","toResult","code","css","toJSON","minifyCss","minifyCssAsync","cssnano","safe","process","then","result","mergeCssAsts","cssAsts","warnCb","rulesPredicate","rules","exclude","Array","isArray","node","nodeMatchesRule","includes","name","type","newAst","root","forEach","ast","nodes","charsetRules","filter","some","rule","test","params","filename","importCount","i","length","rewriteCssUrls","imports","splice","push","mergedCssPath","rewriteRules","Profile","funcName","hasOwn","Object","prototype","hasOwnProperty","call","appDir","cwd","sourceFile","input","file","sourceFileFromAppRoot","replace","basePath","pathJoin","pathDirname","match","value","cssUrlRegex","parts","exec","oldCssUrl","quote","resource","url","protocol","href","startsWith","absolutePath","isRelative","path","hash","relativeToMergedCss","pathRelative","newCssUrl","charAt","toOSPath","p","platform","toStandardPath","a","b","join","dirname","p1","p2","relative"],"mappings":"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","file":"/packages/minifier-css.js","sourcesContent":["import path from 'path';\nimport url from 'url';\nimport postcss from 'postcss';\nimport cssnano from 'cssnano';\n\nconst CssTools = {\n  /**\n   * Parse the incoming CSS string; return a CSS AST.\n   *\n   * @param {string} cssText The CSS string to be parsed.\n   * @param {Object} options Options to pass to the PostCSS parser.\n   * @return {postcss#Root} PostCSS Root AST.\n   */\n  parseCss(cssText, options = {}) {\n    // This function previously used the `css-parse` npm package, which\n    // set the name of the css file being parsed using  { source: 'filename' }.\n    // If included, we'll convert this to the `postcss` equivalent, to maintain\n    // backwards compatibility.\n    if (options.source) {\n      options.from = options.source;\n      delete options.source;\n    }\n    return postcss.parse(cssText, options);\n  },\n\n  /**\n   * Using the incoming CSS AST, create and return a new object with the\n   * generated CSS string, and optional sourcemap details.\n   *\n   * @param {postcss#Root} cssAst PostCSS Root AST.\n   * @param {Object} options Options to pass to the PostCSS parser.\n   * @return {Object} Format: { code: 'css string', map: 'sourcemap deatils' }.\n   */\n  stringifyCss(cssAst, options = {}) {\n    // This function previously used the `css-stringify` npm package, which\n    // controlled sourcemap generation by passing in { sourcemap: true }.\n    // If included, we'll convert this to the `postcss` equivalent, to maintain\n    // backwards compatibility.\n    if (options.sourcemap) {\n      options.map = {\n        inline: false,\n        annotation: false,\n        sourcesContent: false,\n      };\n      delete options.sourcemap;\n    }\n    // explicitly set from to undefined to prevent postcss warnings\n    if (!options.from){\n      options.from = void 0;\n    }\n\n    transformResult = cssAst.toResult(options);\n\n    return {\n      code: transformResult.css,\n      map: transformResult.map ? transformResult.map.toJSON() : null,\n    };\n  },\n\n  /**\n   * Minify the passed in CSS string.\n   *\n   * @param {string} cssText CSS string to minify.\n   * @return {Promise<String[]>} Array containing the minified CSS.\n   */\n  minifyCss(cssText) {\n    return CssTools.minifyCssAsync(cssText);\n  },\n\n  /**\n   * Minify the passed in CSS string.\n   *\n   * @param {string} cssText CSS string to minify.\n   * @return {Promise<String[]>} Array containing the minified CSS.\n   */\n  async minifyCssAsync(cssText) {\n    return await postcss([cssnano({ safe: true })])\n      .process(cssText, {\n        from: void 0,\n      })\n      .then((result) => [result.css]);\n  },\n\n  /**\n   * Merge multiple CSS AST's into one.\n   *\n   * @param {postcss#Root[]} cssAsts Array of PostCSS Root objects.\n   * @callback warnCb Callback used to handle warning messages.\n   * @return {postcss#Root} PostCSS Root object.\n   */\n  mergeCssAsts(cssAsts, warnCb) {\n    const rulesPredicate = (rules, exclude = false) => {\n      if (! Array.isArray(rules)) {\n        rules = [rules];\n      }\n      return node => {\n        // PostCSS AtRule nodes have `type: 'atrule'` and a descriptive name,\n        // e.g. 'import' or 'charset', while Comment nodes have type only.\n        const nodeMatchesRule = rules.includes(node.name || node.type);\n\n        return exclude ? !nodeMatchesRule : nodeMatchesRule;\n      }\n    };\n\n    // Simple concatenation of CSS files would break @import rules\n    // located in the beginning of a file. Before concatenation, pull\n    // @import rules to the beginning of a new syntax tree so they always\n    // precede other rules.\n    const newAst = postcss.root();\n\n    cssAsts.forEach((ast) => {\n      if (ast.nodes) {\n        // Pick only the imports from the beginning of file ignoring @charset\n        // rules as every file is assumed to be in UTF-8.\n        const charsetRules = ast.nodes.filter(rulesPredicate('charset'));\n\n        if (charsetRules.some((rule) => {\n          // According to MDN, only 'UTF-8' and \"UTF-8\" are the correct\n          // encoding directives representing UTF-8.\n          return ! /^(['\"])UTF-8\\1$/.test(rule.params);\n        })) {\n          warnCb(\n            ast.filename,\n            '@charset rules in this file will be ignored as UTF-8 is the ' +\n            'only encoding supported'\n          );\n        }\n\n        ast.nodes = ast.nodes.filter(rulesPredicate('charset', true));\n        let importCount = 0;\n        for (let i = 0; i < ast.nodes.length; i++) {\n          if (! rulesPredicate(['import', 'comment'])(ast.nodes[i])) {\n            importCount = i;\n            break;\n          }\n        }\n\n        CssTools.rewriteCssUrls(ast);\n\n        const imports = ast.nodes.splice(0, importCount);\n        newAst.nodes.push(...imports);\n\n        // If there are imports left in the middle of a file, warn users as it\n        // might be a potential bug (imports are only valid at the beginning of\n        // a file).\n        if (ast.nodes.some(rulesPredicate('import'))) {\n          warnCb(\n            ast.filename,\n            'There are some @import rules in the middle of a file. This ' +\n            'might be a bug, as imports are only valid at the beginning of ' +\n            'a file.'\n          );\n        }\n      }\n    });\n\n    // Now we can put the rest of CSS rules into new AST.\n    cssAsts.forEach((ast) => {\n      if (ast.nodes) {\n        newAst.nodes.push(...ast.nodes);\n      }\n    });\n\n    return newAst;\n  },\n\n  /**\n   * We are looking for all relative urls defined with the `url()` functional\n   * notation and rewriting them to the equivalent absolute url using the\n   * `source` path provided by postcss. For performance reasons this function\n   * acts by side effect by modifying the given AST without doing a deep copy.\n   *\n   * @param {postcss#Root} ast PostCSS Root object.\n   * @return Modifies the ast param in place.\n   */\n  rewriteCssUrls(ast) {\n    const mergedCssPath = '/';\n    rewriteRules(ast.nodes, mergedCssPath);\n  }\n};\n\nif (typeof Profile !== 'undefined') {\n  [\n    'parseCss',\n    'stringifyCss',\n    'minifyCss',\n    'minifyCssAsync',\n    'mergeCssAsts',\n    'rewriteCssUrls',\n  ].forEach(funcName => {\n    CssTools[funcName] = Profile(`CssTools.${funcName}`, CssTools[funcName]);\n  });\n}\n\nexport { CssTools };\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nconst rewriteRules = (rules, mergedCssPath) => {\n  rules.forEach((rule) => {\n    // Recurse if there are sub-rules. An example:\n    //     @media (...) {\n    //         .rule { url(...); }\n    //     }\n    if (hasOwn.call(rule, 'nodes')) {\n      rewriteRules(rule.nodes, mergedCssPath);\n    }\n\n    const appDir = process.cwd();\n    const sourceFile = rule.source.input.file;\n    const sourceFileFromAppRoot =\n      sourceFile ? sourceFile.replace(appDir, '') : '';\n    let basePath = pathJoin('/', pathDirname(sourceFileFromAppRoot));\n\n    // Set the correct basePath based on how the linked asset will be served.\n    // XXX This is wrong. We are coupling the information about how files will\n    // be served by the web server to the information how they were stored\n    // originally on the filesystem in the project structure. Ideally, there\n    // should be some module that tells us precisely how each asset will be\n    // served but for now we are just assuming that everything that comes from\n    // a folder starting with \"/packages/\" is served on the same path as\n    // it was on the filesystem and everything else is served on root \"/\".\n    if (! basePath.match(/^\\/?packages\\//i)) {\n      basePath = \"/\";\n    }\n\n    let value = rule.value;\n\n    // Match css values containing some functional calls to `url(URI)` where\n    // URI is optionally quoted.\n    // Note that a css value can contains other elements, for instance:\n    //   background: top center url(\"background.png\") black;\n    // or even multiple url(), for instance for multiple backgrounds.\n    var cssUrlRegex = /url\\s*\\(\\s*(['\"]?)(.+?)\\1\\s*\\)/gi;\n    let parts;\n    while (parts = cssUrlRegex.exec(value)) {\n      const oldCssUrl = parts[0];\n      const quote = parts[1];\n      const resource = url.parse(parts[2]);\n\n      // We don't rewrite URLs starting with a protocol definition such as\n      // http, https, or data, or those with network-path references\n      // i.e. //img.domain.com/cat.gif\n      if (resource.protocol !== null ||\n          resource.href.startsWith('//') ||\n          resource.href.startsWith('#')) {\n        continue;\n      }\n\n      // Rewrite relative paths (that refers to the internal application tree)\n      // to absolute paths (addressable from the public build).\n      let absolutePath = isRelative(resource.path)\n        ? pathJoin(basePath, resource.path)\n        : resource.path;\n\n      if (resource.hash) {\n        absolutePath += resource.hash;\n      }\n\n      // We used to finish the rewriting process at the absolute path step\n      // above. But it didn't work in case the Meteor application was deployed\n      // under a sub-path (eg `ROOT_URL=http://localhost:3000/myapp meteor`)\n      // in which case the resources linked in the merged CSS file would miss\n      // the `myapp/` prefix. Since this path prefix is only known at launch\n      // time (rather than build time) we can't use absolute paths to link\n      // resources in the generated CSS.\n      //\n      // Instead we transform absolute paths to make them relative to the\n      // merged CSS, leaving to the browser the responsibility to calculate\n      // the final resource links (by adding the application deployment\n      // prefix, here `myapp/`, if applicable).\n      const relativeToMergedCss = pathRelative(mergedCssPath, absolutePath);\n      const newCssUrl = `url(${quote}${relativeToMergedCss}${quote})`;\n      value = value.replace(oldCssUrl, newCssUrl);\n    }\n\n    rule.value = value;\n  });\n};\n\nconst isRelative = path => path && path.charAt(0) !== '/';\n\n// These are duplicates of functions in tools/files.js, because we don't have\n// a good way of exporting them into packages.\n// XXX deduplicate files.js into a package at some point so that we can use it\n// in core\nconst toOSPath =\n  p => process.platform === 'win32' ? p.replace(/\\//g, '\\\\') : p;\nconst toStandardPath =\n  p => process.platform === 'win32' ? p.replace(/\\\\/g, '/') : p;\nconst pathJoin =\n  (a, b) => toStandardPath(path.join(toOSPath(a), toOSPath(b)));\nconst pathDirname =\n  p => toStandardPath(path.dirname(toOSPath(p)));\nconst pathRelative =\n  (p1, p2) => toStandardPath(path.relative(toOSPath(p1), toOSPath(p2)));\n"]}