{"version":3,"sources":["meteor://ðŸ’»app/packages/shell-server/main.js","meteor://ðŸ’»app/packages/shell-server/shell-server.js"],"names":["shellDir","process","env","METEOR_SHELL_DIR","listen","assert","INFO_FILE_MODE","parseInt","EXITING_MESSAGE","callback","Server","Meteor","startup","__meteor_bootstrap__","hooks","startupHooks","push","setImmediate","disable","writeFileSync","getInfoFile","JSON","stringify","status","reason","mode","ignored","evalCommandPromise","Promise","resolve","infoFile","unlink","server","port","address","key","onConnection","socket","on","timeout","setTimeout","removeAllListeners","end","readJSONFromStream","error","options","replInputSocket","clearTimeout","console","stack","columns","Object","assign","create","prompt","terminal","useColors","ignoreUndefined","input","useGlobal","output","evaluateAndExit","startREPL","_wrappedDefaultEval","call","command","global","filename","result","sendResultToSocket","message","toString","code","enableInteractiveMode","repl","replStart","context","setRequireAndModule","defaultEval","eval","wrappedDefaultEval","file","Package","Babel","compileForShell","cacheDirectory","getCacheDirectory","err","then","resolvedResult","catch","rejectedError","initializeHistory","defineProperty","get","last","set","val","configurable","addHelp","cmd","helpText","info","commands","help","write","defineCommand","action","sendMessage","exit","historyFile","getHistoryFile","historyFd","openSync","historyLines","readFileSync","split","seenLines","history","historyIndex","length","line","pop","test","addListener","writeSync","closeSync","ok","Math","random","slice","createServer","inputStream","outputStream","PassThrough","dataSoFar","onData","buffer","lines","shift","json","parse","SyntaxError","finish","join","pipe","onClose","Error","finished","removeListener","pathJoin","modules","toBeInstalled","shellModuleName","require","exports","module","extensions","meteorInstall"],"mappings":"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","file":"/packages/shell-server.js","sourcesContent":["export * from \"./shell-server.js\";\nimport { listen } from \"./shell-server.js\";\n\nconst shellDir = process.env.METEOR_SHELL_DIR;\nif (shellDir) {\n  listen(shellDir);\n}\n","import assert from \"assert\";\nimport { join as pathJoin } from \"path\";\nimport { PassThrough } from \"stream\";\nimport {\n  closeSync,\n  openSync,\n  readFileSync,\n  unlink,\n  writeFileSync,\n  writeSync,\n} from \"fs\";\nimport { createServer } from \"net\";\nimport { start as replStart } from \"repl\";\n\n// Enable process.sendMessage for communication with build process.\nimport \"meteor/inter-process-messaging\";\n\nconst INFO_FILE_MODE = parseInt(\"600\", 8); // Only the owner can read or write.\nconst EXITING_MESSAGE = \"Shell exiting...\";\n\n// Invoked by the server process to listen for incoming connections from\n// shell clients. Each connection gets its own REPL instance.\nexport function listen(shellDir) {\n  function callback() {\n    new Server(shellDir).listen();\n  }\n\n  // If the server is still in the very early stages of starting up,\n  // Meteor.startup may not available yet.\n  if (typeof Meteor === \"object\") {\n    Meteor.startup(callback);\n  } else if (typeof __meteor_bootstrap__ === \"object\") {\n    const hooks = __meteor_bootstrap__.startupHooks;\n    if (hooks) {\n      hooks.push(callback);\n    } else {\n      // As a fallback, just call the callback asynchronously.\n      setImmediate(callback);\n    }\n  }\n}\n\n// Disabling the shell causes all attached clients to disconnect and exit.\nexport function disable(shellDir) {\n  try {\n    // Replace info.json with a file that says the shell server is\n    // disabled, so that any connected shell clients will fail to\n    // reconnect after the server process closes their sockets.\n    writeFileSync(\n      getInfoFile(shellDir),\n      JSON.stringify({\n        status: \"disabled\",\n        reason: \"Shell server has shut down.\"\n      }) + \"\\n\",\n      { mode: INFO_FILE_MODE }\n    );\n  } catch (ignored) {}\n}\n\n// Shell commands need to be executed in a Fiber in case they call into\n// code that yields. Using a Promise is an even better idea, since it runs\n// its callbacks in Fibers drawn from a pool, so the Fibers are recycled.\nconst evalCommandPromise = Promise.resolve();\n\nclass Server {\n  constructor(shellDir) {\n    assert.ok(this instanceof Server);\n\n    this.shellDir = shellDir;\n    this.key = Math.random().toString(36).slice(2);\n\n    this.server =\n      createServer((socket) => {\n        this.onConnection(socket);\n      })\n      .on(\"error\", (err) => {\n        console.error(err.stack);\n      });\n  }\n\n  listen() {\n    const infoFile = getInfoFile(this.shellDir);\n\n    unlink(infoFile, () => {\n      this.server.listen(0, \"127.0.0.1\", () => {\n        writeFileSync(infoFile, JSON.stringify({\n          status: \"enabled\",\n          port: this.server.address().port,\n          key: this.key\n        }) + \"\\n\", {\n          mode: INFO_FILE_MODE\n        });\n      });\n    });\n  }\n\n  onConnection(socket) {\n    // Make sure this function doesn't try to write anything to the socket\n    // after it has been closed.\n    socket.on(\"close\", function() {\n      socket = null;\n    });\n\n    // If communication is not established within 1000ms of the first\n    // connection, forcibly close the socket.\n    const timeout = setTimeout(function() {\n      if (socket) {\n        socket.removeAllListeners(\"data\");\n        socket.end(EXITING_MESSAGE + \"\\n\");\n      }\n    }, 1000);\n\n    // Let connecting clients configure certain REPL options by sending a\n    // JSON object over the socket. For example, only the client knows\n    // whether it's running a TTY or an Emacs subshell or some other kind of\n    // terminal, so the client must decide the value of options.terminal.\n    readJSONFromStream(socket, (error, options, replInputSocket) => {\n      clearTimeout(timeout);\n\n      if (error) {\n        socket = null;\n        console.error(error.stack);\n        return;\n      }\n\n      if (options.key !== this.key) {\n        if (socket) {\n          socket.end(EXITING_MESSAGE + \"\\n\");\n        }\n        return;\n      }\n      delete options.key;\n\n      // Set the columns to what is being requested by the client.\n      if (options.columns && socket) {\n        socket.columns = options.columns;\n      }\n      delete options.columns;\n\n      options = Object.assign(\n        Object.create(null),\n\n        // Defaults for configurable options.\n        {\n          prompt: \"> \",\n          terminal: true,\n          useColors: true,\n          ignoreUndefined: true,\n        },\n\n        // Configurable options\n        options,\n\n        // Immutable options.\n        {\n          input: replInputSocket,\n          useGlobal: false,\n          output: socket\n        }\n      );\n\n      // The prompt during an evaluateAndExit must be blank to ensure\n      // that the prompt doesn't inadvertently get parsed as part of\n      // the JSON communication channel.\n      if (options.evaluateAndExit) {\n        options.prompt = \"\";\n      }\n\n      // Start the REPL.\n      this.startREPL(options);\n\n      if (options.evaluateAndExit) {\n        this._wrappedDefaultEval.call(\n          Object.create(null),\n          options.evaluateAndExit.command,\n          global,\n          options.evaluateAndExit.filename || \"<meteor shell>\",\n          function (error, result) {\n            if (socket) {\n              function sendResultToSocket(message) {\n                // Sending back a JSON payload allows the client to\n                // distinguish between errors and successful results.\n                socket.end(JSON.stringify(message) + \"\\n\");\n              }\n\n              if (error) {\n                sendResultToSocket({\n                  error: error.toString(),\n                  code: 1\n                });\n              } else {\n                sendResultToSocket({\n                  result,\n                });\n              }\n            }\n          }\n        );\n        return;\n      }\n      delete options.evaluateAndExit;\n\n      this.enableInteractiveMode(options);\n    });\n  }\n\n  startREPL(options) {\n    // Make sure this function doesn't try to write anything to the output\n    // stream after it has been closed.\n    options.output.on(\"close\", function() {\n      options.output = null;\n    });\n\n    const repl = this.repl = replStart(options);\n    const { shellDir } = this;\n\n    // This is technique of setting `repl.context` is similar to how the\n    // `useGlobal` option would work during a normal `repl.start()` and\n    // allows shell access (and tab completion!) to Meteor globals (i.e.\n    // Underscore _, Meteor, etc.). By using this technique, which changes\n    // the context after startup, we avoid stomping on the special `_`\n    // variable (in `repl` this equals the value of the last command) from\n    // being overridden in the client/server socket-handshaking.  Furthermore,\n    // by setting `useGlobal` back to true, we allow the default eval function\n    // to use the desired `runInThisContext` method (https://git.io/vbvAB).\n    repl.context = global;\n    repl.useGlobal = true;\n\n    setRequireAndModule(repl.context);\n\n    // In order to avoid duplicating code here, specifically the complexities\n    // of catching so-called \"Recoverable Errors\" (https://git.io/vbvbl),\n    // we will wrap the default eval, run it in a Fiber (via a Promise), and\n    // give it the opportunity to decide if the user is mid-code-block.\n    const defaultEval = repl.eval;\n\n    function wrappedDefaultEval(code, context, file, callback) {\n      if (Package['babel-compiler']) {\n        try {\n          code = Package['babel-compiler'].Babel.compileForShell(code, {\n            cacheDirectory: getCacheDirectory(shellDir)\n          });\n        } catch (err) {\n          // Any Babel error here might be just fine since it's\n          // possible the code was incomplete (multi-line code on the REPL).\n          // The defaultEval below will use its own functionality to determine\n          // if this error is \"recoverable\".\n        }\n      }\n\n      evalCommandPromise\n        .then(() => defaultEval(code, context, file, (error, result) => {\n          if (error) {\n            callback(error);\n          } else {\n            // Check if the result is a Promise\n            if (result && typeof result.then === 'function') {\n              // Handle the Promise resolution and rejection\n              result\n                .then(resolvedResult => {\n                  callback(null, resolvedResult);\n                })\n                .catch(rejectedError => {\n                  callback(rejectedError);\n                });\n            } else {\n              callback(null, result);\n            }\n          }\n        }))\n        .catch(callback);\n    }\n\n    // Have the REPL use the newly wrapped function instead and store the\n    // _wrappedDefaultEval so that evalulateAndExit calls can use it directly.\n    repl.eval = this._wrappedDefaultEval = wrappedDefaultEval;\n  }\n\n  enableInteractiveMode(options) {\n    // History persists across shell sessions!\n    this.initializeHistory();\n\n    const repl = this.repl;\n\n    // Implement an alternate means of fetching the return value,\n    // via `__` (double underscore) as originally implemented in:\n    // https://github.com/meteor/meteor/commit/2443d832265c7d1c\n    Object.defineProperty(repl.context, \"__\", {\n      get: () => repl.last,\n      set: (val) => {\n        repl.last = val;\n      },\n\n      // Allow this property to be (re)defined more than once (e.g. each\n      // time the server restarts).\n      configurable: true\n    });\n\n    // Some improvements to the existing help messages.\n    function addHelp(cmd, helpText) {\n      const info = repl.commands[cmd] || repl.commands[\".\" + cmd];\n      if (info) {\n        info.help = helpText;\n      }\n    }\n    addHelp(\"break\", \"Terminate current command input and display new prompt\");\n    addHelp(\"exit\", \"Disconnect from server and leave shell\");\n    addHelp(\"help\", \"Show this help information\");\n\n    // When the REPL exits, signal the attached client to exit by sending it\n    // the special EXITING_MESSAGE.\n    repl.on(\"exit\", function() {\n      if (options.output) {\n        options.output.write(EXITING_MESSAGE + \"\\n\");\n        options.output.end();\n      }\n    });\n\n    // When the server process exits, end the output stream but do not\n    // signal the attached client to exit.\n    process.on(\"exit\", function() {\n      if (options.output) {\n        options.output.end();\n      }\n    });\n\n    // This Meteor-specific shell command rebuilds the application as if a\n    // change was made to server code.\n    repl.defineCommand(\"reload\", {\n      help: \"Restart the server and the shell\",\n      action: function() {\n        if (process.sendMessage) {\n          process.sendMessage(\"shell-server\", { command: \"reload\" });\n        } else {\n          process.exit(0);\n        }\n      }\n    });\n  }\n\n  // This function allows a persistent history of shell commands to be saved\n  // to and loaded from .meteor/local/shell/history.\n  initializeHistory() {\n    const repl = this.repl;\n    const historyFile = getHistoryFile(this.shellDir);\n    let historyFd = openSync(historyFile, \"a+\");\n    const historyLines = readFileSync(historyFile, \"utf8\").split(\"\\n\");\n    const seenLines = Object.create(null);\n\n    if (! repl.history) {\n      repl.history = [];\n      repl.historyIndex = -1;\n    }\n\n    while (repl.history && historyLines.length > 0) {\n      const line = historyLines.pop();\n      if (line && /\\S/.test(line) && ! seenLines[line]) {\n        repl.history.push(line);\n        seenLines[line] = true;\n      }\n    }\n\n    repl.addListener(\"line\", function(line) {\n      if (historyFd >= 0 && /\\S/.test(line)) {\n        writeSync(historyFd, line + \"\\n\");\n      }\n    });\n\n    this.repl.on(\"exit\", function() {\n      closeSync(historyFd);\n      historyFd = -1;\n    });\n  }\n}\n\nfunction readJSONFromStream(inputStream, callback) {\n  const outputStream = new PassThrough();\n  let dataSoFar = \"\";\n\n  function onData(buffer) {\n    const lines = buffer.toString(\"utf8\").split(\"\\n\");\n\n    while (lines.length > 0) {\n      dataSoFar += lines.shift();\n\n      let json;\n      try {\n        json = JSON.parse(dataSoFar);\n      } catch (error) {\n        if (error instanceof SyntaxError) {\n          continue;\n        }\n\n        return finish(error);\n      }\n\n      if (lines.length > 0) {\n        outputStream.write(lines.join(\"\\n\"));\n      }\n\n      inputStream.pipe(outputStream);\n\n      return finish(null, json);\n    }\n  }\n\n  function onClose() {\n    finish(new Error(\"stream unexpectedly closed\"));\n  }\n\n  let finished = false;\n  function finish(error, json) {\n    if (! finished) {\n      finished = true;\n      inputStream.removeListener(\"data\", onData);\n      inputStream.removeListener(\"error\", finish);\n      inputStream.removeListener(\"close\", onClose);\n      callback(error, json, outputStream);\n    }\n  }\n\n  inputStream.on(\"data\", onData);\n  inputStream.on(\"error\", finish);\n  inputStream.on(\"close\", onClose);\n}\n\nfunction getInfoFile(shellDir) {\n  return pathJoin(shellDir, \"info.json\");\n}\n\nfunction getHistoryFile(shellDir) {\n  return pathJoin(shellDir, \"history\");\n}\n\nfunction getCacheDirectory(shellDir) {\n  return pathJoin(shellDir, \"cache\");\n}\n\nfunction setRequireAndModule(context) {\n  if (Package.modules) {\n    // Use the same `require` function and `module` object visible to the\n    // application.\n    const toBeInstalled = {};\n    const shellModuleName = \"meteor-shell-\" +\n      Math.random().toString(36).slice(2) + \".js\";\n\n    toBeInstalled[shellModuleName] = function (require, exports, module) {\n      context.module = module;\n      context.require = require;\n\n      // Tab completion sometimes uses require.extensions, but only for\n      // the keys.\n      require.extensions = {\n        \".js\": true,\n        \".json\": true,\n        \".node\": true,\n      };\n    };\n\n    // This populates repl.context.{module,require} by evaluating the\n    // module defined above.\n    Package.modules.meteorInstall(toBeInstalled)(\"./\" + shellModuleName);\n  }\n}\n"]}