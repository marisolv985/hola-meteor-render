{"version":3,"sources":["meteor://ðŸ’»app/packages/logging/logging.js","meteor://ðŸ’»app/packages/logging/logging_server.js"],"names":["hasOwn","Object","prototype","hasOwnProperty","Log","args","info","intercept","interceptedLines","suppress","_intercept","count","_suppress","_intercepted","lines","outputFormat","showTime","LEVEL_COLORS","debug","warn","error","META_COLOR","isWin32","process","platform","platformColor","color","endsWith","RESTRICTED_KEYS","FORMATTED_KEYS","logInBrowser","obj","str","format","level","console","log","apply","Function","bind","call","_getCallerDetails","getStack","err","Error","stack","line","split","slice","match","file","details","exec","forEach","arg","intercepted","RegExp","Date","message","String","toString","key","omitCallerDetails","time","Meteor","isProduction","push","EJSON","stringify","isServer","parse","startsWith","e","options","timeInexact","lineNumber","app","appName","originApp","program","satellite","stderr","keys","length","pad2","n","padStart","pad3","dateStamp","getFullYear","getMonth","getDate","timeStamp","getHours","getMinutes","getSeconds","getMilliseconds","utcOffsetStr","getTimezoneOffset","appInfo","sourceInfoParts","sourceInfo","join","stderrIndicator","timeString","metaPrefix","charAt","toUpperCase","Formatter","prettify","metaColor","objFromText","override","require"],"mappings":"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","file":"/packages/logging.js","sourcesContent":["import { Meteor } from 'meteor/meteor';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Log(...args) {\n  Log.info(...args);\n}\n\n/// FOR TESTING\nlet intercept = 0;\nlet interceptedLines = [];\nlet suppress = 0;\n\n// Intercept the next 'count' calls to a Log function. The actual\n// lines printed to the console can be cleared and read by calling\n// Log._intercepted().\nLog._intercept = (count) => {\n  intercept += count;\n};\n\n// Suppress the next 'count' calls to a Log function. Use this to stop\n// tests from spamming the console, especially with red errors that\n// might look like a failing test.\nLog._suppress = (count) => {\n  suppress += count;\n};\n\n// Returns intercepted lines and resets the intercept counter.\nLog._intercepted = () => {\n  const lines = interceptedLines;\n  interceptedLines = [];\n  intercept = 0;\n  return lines;\n};\n\n// Either 'json' or 'colored-text'.\n//\n// When this is set to 'json', print JSON documents that are parsed by another\n// process ('satellite' or 'meteor run'). This other process should call\n// 'Log.format' for nice output.\n//\n// When this is set to 'colored-text', call 'Log.format' before printing.\n// This should be used for logging from within satellite, since there is no\n// other process that will be reading its standard output.\nLog.outputFormat = 'json';\n\n// Defaults to true for local development and for backwards compatibility.\n// for cloud environments is interesting to leave it false as most of them have the timestamp in the console.\n// Only works in server with colored-text\nLog.showTime = true;\n\nconst LEVEL_COLORS = {\n  debug: 'green',\n  // leave info as the default color\n  warn: 'magenta',\n  error: 'red'\n};\n\nconst META_COLOR = 'blue';\n\n// Default colors cause readability problems on Windows Powershell,\n// switch to bright variants. While still capable of millions of\n// operations per second, the benchmark showed a 25%+ increase in\n// ops per second (on Node 8) by caching \"process.platform\".\nconst isWin32 = typeof process === 'object' && process.platform === 'win32';\nconst platformColor = (color) => {\n  if (isWin32 && typeof color === 'string' && !color.endsWith('Bright')) {\n    return `${color}Bright`;\n  }\n  return color;\n};\n\n// XXX package\nconst RESTRICTED_KEYS = ['time', 'timeInexact', 'level', 'file', 'line',\n                        'program', 'originApp', 'satellite', 'stderr'];\n\nconst FORMATTED_KEYS = [...RESTRICTED_KEYS, 'app', 'message'];\n\nconst logInBrowser = obj => {\n  const str = Log.format(obj);\n\n  // XXX Some levels should be probably be sent to the server\n  const level = obj.level;\n\n  if ((typeof console !== 'undefined') && console[level]) {\n    console[level](str);\n  } else {\n    // IE doesn't have console.log.apply, it's not a real Object.\n    // http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9\n    // http://patik.com/blog/complete-cross-browser-console-log/\n    if (typeof console.log.apply === \"function\") {\n      // Most browsers\n      console.log.apply(console, [str]);\n\n    } else if (typeof Function.prototype.bind === \"function\") {\n      // IE9\n      const log = Function.prototype.bind.call(console.log, console);\n      log.apply(console, [str]);\n    }\n  }\n};\n\n// @returns {Object: { line: Number, file: String }}\nLog._getCallerDetails = () => {\n  const getStack = () => {\n    // We do NOT use Error.prepareStackTrace here (a V8 extension that gets us a\n    // pre-parsed stack) since it's impossible to compose it with the use of\n    // Error.prepareStackTrace used on the server for source maps.\n    const err = new Error;\n    const stack = err.stack;\n    return stack;\n  };\n\n  const stack = getStack();\n\n  if (!stack) return {};\n\n  // looking for the first line outside the logging package (or an\n  // eval if we find that first)\n  let line;\n  const lines = stack.split('\\n').slice(1);\n  for (line of lines) {\n    if (line.match(/^\\s*(at eval \\(eval)|(eval:)/)) {\n      return {file: \"eval\"};\n    }\n\n    if (!line.match(/packages\\/(?:local-test[:_])?logging(?:\\/|\\.js)/)) {\n      break;\n    }\n  }\n\n  const details = {};\n\n  // The format for FF is 'functionName@filePath:lineNumber'\n  // The format for V8 is 'functionName (packages/logging/logging.js:81)' or\n  //                      'packages/logging/logging.js:81'\n  const match = /(?:[@(]| at )([^(]+?):([0-9:]+)(?:\\)|$)/.exec(line);\n  if (!match) {\n    return details;\n  }\n\n  // in case the matched block here is line:column\n  details.line = match[2].split(':')[0];\n\n  // Possible format: https://foo.bar.com/scripts/file.js?random=foobar\n  // XXX: if you can write the following in better way, please do it\n  // XXX: what about evals?\n  details.file = match[1].split('/').slice(-1)[0].split('?')[0];\n\n  return details;\n};\n\n['debug', 'info', 'warn', 'error'].forEach((level) => {\n // @param arg {String|Object}\n Log[level] = (arg) => {\n  if (suppress) {\n    suppress--;\n    return;\n  }\n\n  let intercepted = false;\n  if (intercept) {\n    intercept--;\n    intercepted = true;\n  }\n\n  let obj = (arg === Object(arg)\n    && !(arg instanceof RegExp)\n    && !(arg instanceof Date))\n    ? arg\n    : { message: new String(arg).toString() };\n\n  RESTRICTED_KEYS.forEach(key => {\n    if (obj[key]) {\n      throw new Error(`Can't set '${key}' in log message`);\n    }\n  });\n\n  if (hasOwn.call(obj, 'message') && typeof obj.message !== 'string') {\n    throw new Error(\"The 'message' field in log objects must be a string\");\n  }\n\n  if (!obj.omitCallerDetails) {\n    obj = { ...Log._getCallerDetails(), ...obj };\n  }\n\n  obj.time = new Date();\n  obj.level = level;\n\n  // If we are in production don't write out debug logs.\n  if (level === 'debug' && Meteor.isProduction) {\n    return;\n  }\n\n  if (intercepted) {\n    interceptedLines.push(EJSON.stringify(obj));\n  } else if (Meteor.isServer) {\n    if (Log.outputFormat === 'colored-text') {\n      console.log(Log.format(obj, {color: true}));\n    } else if (Log.outputFormat === 'json') {\n      console.log(EJSON.stringify(obj));\n    } else {\n      throw new Error(`Unknown logging output format: ${Log.outputFormat}`);\n    }\n  } else {\n    logInBrowser(obj);\n  }\n};\n});\n\n\n// tries to parse line as EJSON. returns object if parse is successful, or null if not\nLog.parse = (line) => {\n  let obj = null;\n  if (line && line.startsWith('{')) { // might be json generated from calling 'Log'\n    try { obj = EJSON.parse(line); } catch (e) {}\n  }\n\n  // XXX should probably check fields other than 'time'\n  if (obj && obj.time && (obj.time instanceof Date)) {\n    return obj;\n  } else {\n    return null;\n  }\n};\n\n// formats a log object into colored human and machine-readable text\nLog.format = (obj, options = {}) => {\n  obj = { ...obj }; // don't mutate the argument\n  let {\n    time,\n    timeInexact,\n    level = 'info',\n    file,\n    line: lineNumber,\n    app: appName = '',\n    originApp,\n    message = '',\n    program = '',\n    satellite = '',\n    stderr = '',\n  } = obj;\n\n  if (!(time instanceof Date)) {\n    throw new Error(\"'time' must be a Date object\");\n  }\n\n  FORMATTED_KEYS.forEach((key) => { delete obj[key]; });\n\n  if (Object.keys(obj).length > 0) {\n    if (message) {\n      message += ' ';\n    }\n    message += EJSON.stringify(obj);\n  }\n\n  const pad2 = n => n.toString().padStart(2, '0');\n  const pad3 = n => n.toString().padStart(3, '0');\n\n  const dateStamp = time.getFullYear().toString() +\n    pad2(time.getMonth() + 1 /*0-based*/) +\n    pad2(time.getDate());\n  const timeStamp = pad2(time.getHours()) +\n        ':' +\n        pad2(time.getMinutes()) +\n        ':' +\n        pad2(time.getSeconds()) +\n        '.' +\n        pad3(time.getMilliseconds());\n\n  // eg in San Francisco in June this will be '(-7)'\n  const utcOffsetStr = `(${(-(new Date().getTimezoneOffset() / 60))})`;\n\n  let appInfo = '';\n  if (appName) {\n    appInfo += appName;\n  }\n  if (originApp && originApp !== appName) {\n    appInfo += ` via ${originApp}`;\n  }\n  if (appInfo) {\n    appInfo = `[${appInfo}] `;\n  }\n\n  const sourceInfoParts = [];\n  if (program) {\n    sourceInfoParts.push(program);\n  }\n  if (file) {\n    sourceInfoParts.push(file);\n  }\n  if (lineNumber) {\n    sourceInfoParts.push(lineNumber);\n  }\n\n  let sourceInfo = !sourceInfoParts.length ?\n    '' : `(${sourceInfoParts.join(':')}) `;\n\n  if (satellite)\n    sourceInfo += `[${satellite}]`;\n\n  const stderrIndicator = stderr ? '(STDERR) ' : '';\n\n  const timeString = Log.showTime\n    ? `${dateStamp}-${timeStamp}${utcOffsetStr}${timeInexact ? '? ' : ' '}`\n    : ' ';\n\n\n\n  const metaPrefix = [\n    level.charAt(0).toUpperCase(),\n    timeString,\n    appInfo,\n    sourceInfo,\n    stderrIndicator].join('');\n\n\n  return Formatter.prettify(metaPrefix, options.color && platformColor(options.metaColor || META_COLOR)) +\n      Formatter.prettify(message, options.color && platformColor(LEVEL_COLORS[level]));\n};\n\n// Turn a line of text into a loggable object.\n// @param line {String}\n// @param override {Object}\nLog.objFromText = (line, override) => {\n  return {\n    message: line,\n    level: 'info',\n    time: new Date(),\n    timeInexact: true,\n    ...override\n  };\n};\n\nexport { Log };\n","Formatter = {};\nFormatter.prettify = function(line, color){\n    if(!color) return line;\n    return require(\"chalk\")[color](line);\n};\n"]}