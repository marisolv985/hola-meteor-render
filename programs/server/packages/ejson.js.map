{"version":3,"sources":["meteor://ðŸ’»app/packages/ejson/ejson.js","meteor://ðŸ’»app/packages/ejson/stringify.js","meteor://ðŸ’»app/packages/ejson/utils.js"],"names":["isFunction","isObject","keysOf","lengthOf","hasOwn","convertMapToObject","isArguments","isInfOrNaN","handleError","EJSON","customTypes","Map","addType","name","factory","has","Error","set","builtinConverters","matchJSONValue","obj","matchObject","Date","toJSONValue","$date","getTime","fromJSONValue","RegExp","regexp","$regexp","source","$flags","flags","slice","replace","sign","Number","isNaN","Infinity","$InfNaN","Uint8Array","$binary","Base64","encode","decode","match","keyCount","some","converter","newObj","forEach","key","$escape","_isCustomType","jsonValue","Meteor","_noYieldsAllowed","$type","typeName","$value","get","_getTypes","isOriginal","_getConverters","toJSONValueHelper","item","i","length","undefined","adjustTypesToJSONValue","maybeChanged","value","changed","_adjustTypesToJSONValue","newItem","clone","fromJSONValueHelper","keys","every","k","substr","adjustTypesFromJSONValue","_adjustTypesFromJSONValue","stringify","options","serialized","json","canonical","indent","canonicalStringify","JSON","parse","isBinary","$Uint8ArrayPolyfill","equals","a","b","keyOrderSensitive","valueOf","aIsArray","Array","isArray","bIsArray","ret","aKeys","bKeys","v","newBinary","map","from","quote","string","str","holder","singleIndent","outerIndent","isFinite","String","innerIndent","partial","hasOwnProperty","call","join","Object","sort","push","allOptions","assign","newIndent","fn","prop","prototype","reduce","acc","checkError","maxStack","msgError","test","apply","arguments","error","isMaxStack","message"],"mappings":"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","file":"/packages/ejson.js","sourcesContent":["import {\n  isFunction,\n  isObject,\n  keysOf,\n  lengthOf,\n  hasOwn,\n  convertMapToObject,\n  isArguments,\n  isInfOrNaN,\n  handleError,\n} from './utils';\nimport canonicalStringify from './stringify';\n\n/**\n * @namespace\n * @summary Namespace for EJSON functions\n */\nconst EJSON = {};\n\n// Custom type interface definition\n/**\n * @class CustomType\n * @instanceName customType\n * @memberOf EJSON\n * @summary The interface that a class must satisfy to be able to become an\n * EJSON custom type via EJSON.addType.\n */\n\n/**\n * @function typeName\n * @memberOf EJSON.CustomType\n * @summary Return the tag used to identify this type.  This must match the\n *          tag used to register this type with\n *          [`EJSON.addType`](#ejson_add_type).\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function toJSONValue\n * @memberOf EJSON.CustomType\n * @summary Serialize this instance into a JSON-compatible value.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function clone\n * @memberOf EJSON.CustomType\n * @summary Return a value `r` such that `this.equals(r)` is true, and\n *          modifications to `r` do not affect `this` and vice versa.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function equals\n * @memberOf EJSON.CustomType\n * @summary Return `true` if `other` has a value equal to `this`; `false`\n *          otherwise.\n * @locus Anywhere\n * @param {Object} other Another object to compare this to.\n * @instance\n */\n\nconst customTypes = new Map();\n\n// Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n// EJSON.clone will use toJSONValue and the given factory to produce\n// a clone, but you may specify a method clone() that will be\n// used instead.\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\n// but you may provide a method equals() instead.\n/**\n * @summary Add a custom datatype to EJSON.\n * @locus Anywhere\n * @param {String} name A tag for your custom type; must be unique among\n *                      custom data types defined in your project, and must\n *                      match the result of your type's `typeName` method.\n * @param {Function} factory A function that deserializes a JSON-compatible\n *                           value into an instance of your type.  This should\n *                           match the serialization performed by your\n *                           type's `toJSONValue` method.\n */\nEJSON.addType = (name, factory) => {\n  if (customTypes.has(name)) {\n    throw new Error(`Type ${name} already present`);\n  }\n  customTypes.set(name, factory);\n};\n\nconst builtinConverters = [\n  { // Date\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$date') && lengthOf(obj) === 1;\n    },\n    matchObject(obj) {\n      return obj instanceof Date;\n    },\n    toJSONValue(obj) {\n      return {$date: obj.getTime()};\n    },\n    fromJSONValue(obj) {\n      return new Date(obj.$date);\n    },\n  },\n  { // RegExp\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$regexp')\n        && hasOwn(obj, '$flags')\n        && lengthOf(obj) === 2;\n    },\n    matchObject(obj) {\n      return obj instanceof RegExp;\n    },\n    toJSONValue(regexp) {\n      return {\n        $regexp: regexp.source,\n        $flags: regexp.flags\n      };\n    },\n    fromJSONValue(obj) {\n      // Replaces duplicate / invalid flags.\n      return new RegExp(\n        obj.$regexp,\n        obj.$flags\n          // Cut off flags at 50 chars to avoid abusing RegExp for DOS.\n          .slice(0, 50)\n          .replace(/[^gimuy]/g,'')\n          .replace(/(.)(?=.*\\1)/g, '')\n      );\n    },\n  },\n  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n    // which we match.)\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$InfNaN') && lengthOf(obj) === 1;\n    },\n    matchObject: isInfOrNaN,\n    toJSONValue(obj) {\n      let sign;\n      if (Number.isNaN(obj)) {\n        sign = 0;\n      } else if (obj === Infinity) {\n        sign = 1;\n      } else {\n        sign = -1;\n      }\n      return {$InfNaN: sign};\n    },\n    fromJSONValue(obj) {\n      return obj.$InfNaN / 0;\n    },\n  },\n  { // Binary\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$binary') && lengthOf(obj) === 1;\n    },\n    matchObject(obj) {\n      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array\n        || (obj && hasOwn(obj, '$Uint8ArrayPolyfill'));\n    },\n    toJSONValue(obj) {\n      return {$binary: Base64.encode(obj)};\n    },\n    fromJSONValue(obj) {\n      return Base64.decode(obj.$binary);\n    },\n  },\n  { // Escaping one level\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$escape') && lengthOf(obj) === 1;\n    },\n    matchObject(obj) {\n      let match = false;\n      if (obj) {\n        const keyCount = lengthOf(obj);\n        if (keyCount === 1 || keyCount === 2) {\n          match =\n            builtinConverters.some(converter => converter.matchJSONValue(obj));\n        }\n      }\n      return match;\n    },\n    toJSONValue(obj) {\n      const newObj = {};\n      keysOf(obj).forEach(key => {\n        newObj[key] = EJSON.toJSONValue(obj[key]);\n      });\n      return {$escape: newObj};\n    },\n    fromJSONValue(obj) {\n      const newObj = {};\n      keysOf(obj.$escape).forEach(key => {\n        newObj[key] = EJSON.fromJSONValue(obj.$escape[key]);\n      });\n      return newObj;\n    },\n  },\n  { // Custom\n    matchJSONValue(obj) {\n      return hasOwn(obj, '$type')\n        && hasOwn(obj, '$value') && lengthOf(obj) === 2;\n    },\n    matchObject(obj) {\n      return EJSON._isCustomType(obj);\n    },\n    toJSONValue(obj) {\n      const jsonValue = Meteor._noYieldsAllowed(() => obj.toJSONValue());\n      return {$type: obj.typeName(), $value: jsonValue};\n    },\n    fromJSONValue(obj) {\n      const typeName = obj.$type;\n      if (!customTypes.has(typeName)) {\n        throw new Error(`Custom EJSON type ${typeName} is not defined`);\n      }\n      const converter = customTypes.get(typeName);\n      return Meteor._noYieldsAllowed(() => converter(obj.$value));\n    },\n  },\n];\n\nEJSON._isCustomType = (obj) => (\n  obj &&\n  isFunction(obj.toJSONValue) &&\n  isFunction(obj.typeName) &&\n  customTypes.has(obj.typeName())\n);\n\nEJSON._getTypes = (isOriginal = false) => (isOriginal ? customTypes : convertMapToObject(customTypes));\n\nEJSON._getConverters = () => builtinConverters;\n\n// Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\nconst toJSONValueHelper = item => {\n  for (let i = 0; i < builtinConverters.length; i++) {\n    const converter = builtinConverters[i];\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n  return undefined;\n};\n\n// for both arrays and objects, in-place modification.\nconst adjustTypesToJSONValue = obj => {\n  // Is it an atom that we need to adjust?\n  if (obj === null) {\n    return null;\n  }\n\n  const maybeChanged = toJSONValueHelper(obj);\n  if (maybeChanged !== undefined) {\n    return maybeChanged;\n  }\n\n  // Other atoms are unchanged.\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  // Iterate over array or object structure.\n  keysOf(obj).forEach(key => {\n    const value = obj[key];\n    if (!isObject(value) && value !== undefined &&\n        !isInfOrNaN(value)) {\n      return; // continue\n    }\n\n    const changed = toJSONValueHelper(value);\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    }\n    // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\nEJSON._adjustTypesToJSONValue = adjustTypesToJSONValue;\n\n/**\n * @summary Serialize an EJSON-compatible value into its plain JSON\n *          representation.\n * @locus Anywhere\n * @param {EJSON} val A value to serialize to plain JSON.\n */\nEJSON.toJSONValue = item => {\n  const changed = toJSONValueHelper(item);\n  if (changed !== undefined) {\n    return changed;\n  }\n\n  let newItem = item;\n  if (isObject(item)) {\n    newItem = EJSON.clone(item);\n    adjustTypesToJSONValue(newItem);\n  }\n  return newItem;\n};\n\n// Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\nconst fromJSONValueHelper = value => {\n  if (isObject(value) && value !== null) {\n    const keys = keysOf(value);\n    if (keys.length <= 2\n        && keys.every(k => typeof k === 'string' && k.substr(0, 1) === '$')) {\n      for (let i = 0; i < builtinConverters.length; i++) {\n        const converter = builtinConverters[i];\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n  return value;\n};\n\n// for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\nconst adjustTypesFromJSONValue = obj => {\n  if (obj === null) {\n    return null;\n  }\n\n  const maybeChanged = fromJSONValueHelper(obj);\n  if (maybeChanged !== obj) {\n    return maybeChanged;\n  }\n\n  // Other atoms are unchanged.\n  if (!isObject(obj)) {\n    return obj;\n  }\n\n  keysOf(obj).forEach(key => {\n    const value = obj[key];\n    if (isObject(value)) {\n      const changed = fromJSONValueHelper(value);\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      }\n      // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\nEJSON._adjustTypesFromJSONValue = adjustTypesFromJSONValue;\n\n/**\n * @summary Deserialize an EJSON value from its plain JSON representation.\n * @locus Anywhere\n * @param {JSONCompatible} val A value to deserialize into EJSON.\n */\nEJSON.fromJSONValue = item => {\n  let changed = fromJSONValueHelper(item);\n  if (changed === item && isObject(item)) {\n    changed = EJSON.clone(item);\n    adjustTypesFromJSONValue(changed);\n  }\n  return changed;\n};\n\n/**\n * @summary Serialize a value to a string. For EJSON values, the serialization\n *          fully represents the value. For non-EJSON values, serializes the\n *          same way as `JSON.stringify`.\n * @locus Anywhere\n * @param {EJSON} val A value to stringify.\n * @param {Object} [options]\n * @param {Boolean | Integer | String} [options.indent] Indents objects and\n * arrays for easy readability.  When `true`, indents by 2 spaces; when an\n * integer, indents by that number of spaces; and when a string, uses the\n * string as the indentation pattern.\n * @param {Boolean} [options.canonical] When `true`, stringifies keys in an\n *                                    object in sorted order.\n */\nEJSON.stringify = handleError((item, options) => {\n  let serialized;\n  const json = EJSON.toJSONValue(item);\n  if (options && (options.canonical || options.indent)) {\n    serialized = canonicalStringify(json, options);\n  } else {\n    serialized = JSON.stringify(json);\n  }\n  return serialized;\n});\n\n/**\n * @summary Parse a string into an EJSON value. Throws an error if the string\n *          is not valid EJSON.\n * @locus Anywhere\n * @param {String} str A string to parse into an EJSON value.\n */\nEJSON.parse = item => {\n  if (typeof item !== 'string') {\n    throw new Error('EJSON.parse argument should be a string');\n  }\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n\n/**\n * @summary Returns true if `x` is a buffer of binary data, as returned from\n *          [`EJSON.newBinary`](#ejson_new_binary).\n * @param {Object} x The variable to check.\n * @locus Anywhere\n */\nEJSON.isBinary = obj => {\n  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\n    (obj && obj.$Uint8ArrayPolyfill));\n};\n\n/**\n * @summary Return true if `a` and `b` are equal to each other.  Return false\n *          otherwise.  Uses the `equals` method on `a` if present, otherwise\n *          performs a deep comparison.\n * @locus Anywhere\n * @param {EJSON} a\n * @param {EJSON} b\n * @param {Object} [options]\n * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order,\n * if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}`\n * is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The\n * default is `false`.\n */\nEJSON.equals = (a, b, options) => {\n  let i;\n  const keyOrderSensitive = !!(options && options.keyOrderSensitive);\n  if (a === b) {\n    return true;\n  }\n\n  // This differs from the IEEE spec for NaN equality, b/c we don't want\n  // anything ever with a NaN to be poisoned from becoming equal to anything.\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  }\n\n  // if either one is falsy, they'd have to be === to be equal\n  if (!a || !b) {\n    return false;\n  }\n\n  if (!(isObject(a) && isObject(b))) {\n    return false;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (isFunction(a.equals)) {\n    return a.equals(b, options);\n  }\n\n  if (isFunction(b.equals)) {\n    return b.equals(a, options);\n  }\n\n  // Array.isArray works across iframes while instanceof won't\n  const aIsArray = Array.isArray(a);\n  const bIsArray = Array.isArray(b);\n\n  // if not both or none are array they are not equal\n  if (aIsArray !== bIsArray) {\n    return false;\n  }\n\n  if (aIsArray && bIsArray) {\n    if (a.length !== b.length) {\n      return false;\n    }\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // fallback for custom types that don't implement their own equals\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\n    case 1: return false;\n    case 2: return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\n    default: // Do nothing\n  }\n\n  // fall back to structural equality of objects\n  let ret;\n  const aKeys = keysOf(a);\n  const bKeys = keysOf(b);\n  if (keyOrderSensitive) {\n    i = 0;\n    ret = aKeys.every(key => {\n      if (i >= bKeys.length) {\n        return false;\n      }\n      if (key !== bKeys[i]) {\n        return false;\n      }\n      if (!EJSON.equals(a[key], b[bKeys[i]], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n  } else {\n    i = 0;\n    ret = aKeys.every(key => {\n      if (!hasOwn(b, key)) {\n        return false;\n      }\n      if (!EJSON.equals(a[key], b[key], options)) {\n        return false;\n      }\n      i++;\n      return true;\n    });\n  }\n  return ret && i === bKeys.length;\n};\n\n/**\n * @summary Return a deep copy of `val`.\n * @locus Anywhere\n * @param {EJSON} val A value to copy.\n */\nEJSON.clone = v => {\n  let ret;\n  if (!isObject(v)) {\n    return v;\n  }\n\n  if (v === null) {\n    return null; // null has typeof \"object\"\n  }\n\n  if (v instanceof Date) {\n    return new Date(v.getTime());\n  }\n\n  // RegExps are not really EJSON elements (eg we don't define a serialization\n  // for them), but they're immutable anyway, so we can support them in clone.\n  if (v instanceof RegExp) {\n    return v;\n  }\n\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n    for (let i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n    return ret;\n  }\n\n  if (Array.isArray(v)) {\n    return v.map(EJSON.clone);\n  }\n\n  if (isArguments(v)) {\n    return Array.from(v).map(EJSON.clone);\n  }\n\n  // handle general user-defined typed Objects if they have a clone method\n  if (isFunction(v.clone)) {\n    return v.clone();\n  }\n\n  // handle other custom types\n  if (EJSON._isCustomType(v)) {\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\n  }\n\n  // handle other objects\n  ret = {};\n  keysOf(v).forEach((key) => {\n    ret[key] = EJSON.clone(v[key]);\n  });\n  return ret;\n};\n\n/**\n * @summary Allocate a new buffer of binary data that EJSON can serialize.\n * @locus Anywhere\n * @param {Number} size The number of bytes of binary data to allocate.\n */\n// EJSON.newBinary is the public documented API for this functionality,\n// but the implementation is in the 'base64' package to avoid\n// introducing a circular dependency. (If the implementation were here,\n// then 'base64' would have to use EJSON.newBinary, and 'ejson' would\n// also have to use 'base64'.)\nEJSON.newBinary = Base64.newBinary;\n\nexport { EJSON };\n","// Based on json2.js from https://github.com/douglascrockford/JSON-js\n//\n//    json2.js\n//    2012-10-08\n//\n//    Public Domain.\n//\n//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\nfunction quote(string) {\n  return JSON.stringify(string);\n}\n\nconst str = (key, holder, singleIndent, outerIndent, canonical) => {\n  const value = holder[key];\n\n  // What happens next depends on the value's type.\n  switch (typeof value) {\n  case 'string':\n    return quote(value);\n  case 'number':\n    // JSON numbers must be finite. Encode non-finite numbers as null.\n    return isFinite(value) ? String(value) : 'null';\n  case 'boolean':\n    return String(value);\n  // If the type is 'object', we might be dealing with an object or an array or\n  // null.\n  case 'object': {\n    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n    // so watch out for that case.\n    if (!value) {\n      return 'null';\n    }\n    // Make an array to hold the partial results of stringifying this object\n    // value.\n    const innerIndent = outerIndent + singleIndent;\n    const partial = [];\n    let v;\n\n    // Is the value an array?\n    if (Array.isArray(value) || ({}).hasOwnProperty.call(value, 'callee')) {\n      // The value is an array. Stringify every element. Use null as a\n      // placeholder for non-JSON values.\n      const length = value.length;\n      for (let i = 0; i < length; i += 1) {\n        partial[i] =\n          str(i, value, singleIndent, innerIndent, canonical) || 'null';\n      }\n\n      // Join all of the elements together, separated with commas, and wrap\n      // them in brackets.\n      if (partial.length === 0) {\n        v = '[]';\n      } else if (innerIndent) {\n        v = '[\\n' +\n          innerIndent +\n          partial.join(',\\n' +\n          innerIndent) +\n          '\\n' +\n          outerIndent +\n          ']';\n      } else {\n        v = '[' + partial.join(',') + ']';\n      }\n      return v;\n    }\n\n    // Iterate through all of the keys in the object.\n    let keys = Object.keys(value);\n    if (canonical) {\n      keys = keys.sort();\n    }\n    keys.forEach(k => {\n      v = str(k, value, singleIndent, innerIndent, canonical);\n      if (v) {\n        partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\n      }\n    });\n\n    // Join all of the member texts together, separated with commas,\n    // and wrap them in braces.\n    if (partial.length === 0) {\n      v = '{}';\n    } else if (innerIndent) {\n      v = '{\\n' +\n        innerIndent +\n        partial.join(',\\n' +\n        innerIndent) +\n        '\\n' +\n        outerIndent +\n        '}';\n    } else {\n      v = '{' + partial.join(',') + '}';\n    }\n    return v;\n  }\n\n  default: // Do nothing\n  }\n};\n\n// If the JSON object does not yet have a stringify method, give it one.\nconst canonicalStringify = (value, options) => {\n  // Make a fake root object containing our value under the key of ''.\n  // Return the result of stringifying the value.\n  const allOptions = Object.assign({\n    indent: '',\n    canonical: false,\n  }, options);\n  if (allOptions.indent === true) {\n    allOptions.indent = '  ';\n  } else if (typeof allOptions.indent === 'number') {\n    let newIndent = '';\n    for (let i = 0; i < allOptions.indent; i++) {\n      newIndent += ' ';\n    }\n    allOptions.indent = newIndent;\n  }\n  return str('', {'': value}, allOptions.indent, '', allOptions.canonical);\n};\n\nexport default canonicalStringify;\n","export const isFunction = (fn) => typeof fn === 'function';\n\nexport const isObject = (fn) => typeof fn === 'object';\n\nexport const keysOf = (obj) => Object.keys(obj);\n\nexport const lengthOf = (obj) => Object.keys(obj).length;\n\nexport const hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport const convertMapToObject = (map) => Array.from(map).reduce((acc, [key, value]) => {\n  // reassign to not create new object\n  acc[key] = value;\n  return acc;\n}, {});\n\nexport const isArguments = obj => obj != null && hasOwn(obj, 'callee');\n\nexport const isInfOrNaN =\n  obj => Number.isNaN(obj) || obj === Infinity || obj === -Infinity;\n\nexport const checkError = {\n  maxStack: (msgError) => new RegExp('Maximum call stack size exceeded', 'g').test(msgError),\n};\n\nexport const handleError = (fn) => function() {\n  try {\n    return fn.apply(this, arguments);\n  } catch (error) {\n    const isMaxStack = checkError.maxStack(error.message);\n    if (isMaxStack) {\n      throw new Error('Converting circular structure to JSON')\n    }\n    throw error;\n  }\n};\n"]}